

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="SamuelZhou">
  <meta name="keywords" content="">
  
    <meta name="description" content="JAVA创建线程的四种方式继承Thread类 定义thread类的子类，并重写run方法，该方法的方法体就是线程需要完成的任务，run方法也称为线程执行体。 创建Thread类的实例，也就是创建了线程对象 启动线程，即调用线程的start方法  实现Runnable接口 定义Runnable接口的实现类，重写run方法，run方法同样是线程执行体 创建实现类的实例，并用这个实例作为Thread类的">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC">
<meta property="og:url" content="http://example.com/post/JUC.html">
<meta property="og:site_name" content="welcome">
<meta property="og:description" content="JAVA创建线程的四种方式继承Thread类 定义thread类的子类，并重写run方法，该方法的方法体就是线程需要完成的任务，run方法也称为线程执行体。 创建Thread类的实例，也就是创建了线程对象 启动线程，即调用线程的start方法  实现Runnable接口 定义Runnable接口的实现类，重写run方法，run方法同样是线程执行体 创建实现类的实例，并用这个实例作为Thread类的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/executor.png">
<meta property="og:image" content="http://example.com/img/executor1.png">
<meta property="og:image" content="http://example.com/img/thread.png">
<meta property="og:image" content="http://example.com/img/CAS.png">
<meta property="og:image" content="http://example.com/img/ThreadLocal.png">
<meta property="og:image" content="http://example.com/img/threadLocal1.png">
<meta property="og:image" content="http://example.com/img/ThreadLocal2.png">
<meta property="og:image" content="http://example.com/img/volatile1.png">
<meta property="og:image" content="http://example.com/img/volatile2.png">
<meta property="og:image" content="http://example.com/img/reentrantLock.png">
<meta property="og:image" content="http://example.com/img/reentrantLock1.png">
<meta property="og:image" content="http://example.com/img/Atomic%E8%AF%A6%E8%A7%A3.png">
<meta property="og:image" content="http://example.com/img/longadder.png">
<meta property="og:image" content="http://example.com/img/LongAdder1.png">
<meta property="article:published_time" content="2022-10-20T06:09:39.000Z">
<meta property="article:modified_time" content="2022-12-19T06:20:12.569Z">
<meta property="article:author" content="SamuelZhou">
<meta property="article:tag" content="Java基础知识">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/executor.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>JUC - welcome</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>samuel`s world</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="JUC"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        SamuelZhou
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-10-20 14:09" pubdate>
          2022年10月20日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          16k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          138 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">JUC</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="JAVA创建线程的四种方式"><a href="#JAVA创建线程的四种方式" class="headerlink" title="JAVA创建线程的四种方式"></a>JAVA创建线程的四种方式</h1><h2 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h2><ol>
<li>定义thread类的子类，并重写run方法，该方法的方法体就是线程需要完成的任务，run方法也称为线程执行体。</li>
<li>创建Thread类的实例，也就是创建了线程对象</li>
<li>启动线程，即调用线程的start方法</li>
</ol>
<h2 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h2><ol>
<li>定义Runnable接口的实现类，重写run方法，run方法同样是线程执行体</li>
<li>创建实现类的实例，并用这个实例作为Thread类的target来创建Thread对象，这个Thread对象便是线程对象</li>
<li>启动线程，调用start方法</li>
</ol>
<h2 id="使用Callable和future创建"><a href="#使用Callable和future创建" class="headerlink" title="使用Callable和future创建"></a>使用Callable和future创建</h2><p>future接口是jdk1.5引入的，可以用来接收callable接口里call方法的返回值</p>
<p>有一个实现类futureTask，实现了future和runnable接口，因此可以作为thread类的target</p>
<ol>
<li>创建callable接口的实现类，并实现call方法，然后创建该实现类的实例</li>
<li>使用futureTask类来包装callable对象</li>
<li>使用futureTask对象作为thread对象的target创建并启动线程</li>
<li>使用futureTask对象的get方法来获取子线程执行结束后的返回值</li>
</ol>
<p>call方法比run方法更加强大：可以有返回值，可以抛出异常</p>
<h2 id="使用executor框架"><a href="#使用executor框架" class="headerlink" title="使用executor框架"></a>使用executor框架</h2><p>JDK1.5引入的executor框架最大的优点就是把<strong>任务的提交和执行解耦</strong></p>
<p>开发者只需描述好要只需的任务，然后提交即可</p>
<ol>
<li>创建一个ExecutorService,<code>ExecutorService executorService = Executors.newFixedThreadPool(5);</code></li>
<li>若有返回值，将写好的runnable实例或者callable实例作为target submit即可，返回值是一个future对象，所以可以使用get方法获取返回值.</li>
<li>若无返回值，直接使用execute方法即可<code>ExecutorService.execute(Runnable command);</code></li>
</ol>
<p>executor框架的内部使用了线程池的机制，<strong>可以作为一个工厂类来创建线程池</strong></p>
<p><img src="/../img/executor.png" srcset="/img/loading.gif" lazyload alt="executor"></p>
<p><img src="/../img/executor1.png" srcset="/img/loading.gif" lazyload alt="executor1"></p>
<p>从上图可以看出，应用程序通过Executor框架控制上层的调度；而下层的调度由操作系统内核控制，下层的调度不受应用程序的控制。</p>
<h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>当使用new关键字创建了一个线程之后，该线程就处于一个新建状态，此时它和其他java对象一样，仅仅被分配了内存，并初始化了成员变量值。没有线程的动态特征，也不会执行线程的执行体</p>
<h2 id="就绪"><a href="#就绪" class="headerlink" title="就绪"></a>就绪</h2><p>当调用start方法后，该线程处于就绪状态。JVM会为其创建虚拟机栈和PC，处于这个状态表示线程可以运行了，等待被调度执行</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>在就绪状态下，若被OS调度，就会进入运行状态。当时间片用完或者调用线程让步时，回到就绪状态</p>
<h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><ol>
<li>等待阻塞：线程执行wait方法，JVM会将其放入等待池中，此时线程会释放持有的锁</li>
<li>同步阻塞：即被synchronized修饰的代码块被其他线程拿到，本线程获取同步锁失败，就会被JVM放入锁池中</li>
<li>其他阻塞：线程执行sleep或者join方法，或者发出了IO请求。当sleep超时，join等待线程终止或者等待超时，IO完毕，线程就会重新转入就绪状态</li>
</ol>
<table>
<thead>
<tr>
<th>调度方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>sleep</td>
<td>线程睡眠，使线程转入阻塞状态一定时间</td>
</tr>
<tr>
<td>wait</td>
<td>线程等待，使线程放入等待池，直到其他线程调用notify或者notifyall方法来唤醒，此时线程会尝试获取锁，若成功，转为就绪状态，若失败，则进入锁池等待锁的释放。</td>
</tr>
<tr>
<td>yield</td>
<td>线程让步，暂停当前正在执行的线程对象，回到就绪状态，把执行机会让给优先级相同或者更高的线程</td>
</tr>
<tr>
<td>join</td>
<td>线程加入，等待其他线程终止，在当前进程中调用另一个指定进程的join方法，则当前进程转入阻塞状态，直到另一个进程运行结束，当前进程再由阻塞转为就绪状态</td>
</tr>
<tr>
<td>notify</td>
<td>线程唤醒，唤醒被wait阻塞的进程</td>
</tr>
</tbody></table>
<h2 id="死亡"><a href="#死亡" class="headerlink" title="死亡"></a>死亡</h2><ol>
<li>run方法执行完成，线程正常结束</li>
<li>抛出异常</li>
<li>直接调用stop方法来结束（容易造成死锁）</li>
</ol>
<p><img src="/../img/thread.png" srcset="/img/loading.gif" lazyload alt="thread"></p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>一种多线程的处理形式，处理过程中可以将任务添加到队列中，然后在创建线程后自动启动这些任务。</p>
<h3 id="线程池的优势"><a href="#线程池的优势" class="headerlink" title="线程池的优势"></a><em><strong>线程池的优势</strong></em></h3><ol>
<li>线程和任务分离，线程可被重用，提升复用性</li>
<li>控制线程并发数量，统一管理，降低服务器压力</li>
<li>提升系统响应速度，因为线程池内的线程可以被复用，且线程池内有核心线程待命，所以就减少了创建线程和销毁线程的时间。</li>
</ol>
<h3 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a><em><strong>为什么要使用线程池</strong></em></h3><p>JAVA线程的创建十分昂贵，需要JVM和OS配合完成大量的工作</p>
<ol>
<li>必须为线程堆栈分配和初始化大量的内存块，其中至少包含1MB的栈内存</li>
<li>JVM的线程模型为1:1模型，即JVM的线程和OS的线程是1:1对应的，需要进行系统调用，以便在OS中创建和注册本地线程</li>
</ol>
<p>Java的高并发应用频繁创建和销毁线程的操作是十分低效的，且不符合编程规范的，所以需要使用线程池来独立负责线程的创建维护和分配，以提升性能，减少资源消耗。</p>
<p>应用场景：网购商品秒杀，云盘文件上传，旅行系统购票等等</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//构造方法:</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize, //核心线程数量</span><br><span class="hljs-params">                              <span class="hljs-type">int</span> maximumPoolSize,//     最大线程数</span><br><span class="hljs-params">                              <span class="hljs-type">long</span> keepAliveTime, //       最大空闲时间</span><br><span class="hljs-params">                              TimeUnit unit,         //        时间单位</span><br><span class="hljs-params">                              BlockingQueue&lt;Runnable&gt; workQueue,   //   任务队列</span><br><span class="hljs-params">                              ThreadFactory threadFactory,    // 线程工厂</span><br><span class="hljs-params">                              RejectedExecutionHandler handler  //  饱和处理机制</span><br><span class="hljs-params">	)</span> <br></code></pre></td></tr></table></figure>

<p>参数解释：</p>
<ol>
<li>corePoolSize : 指空闲也不允许被销毁的线程，随时待命存放于线程池中</li>
<li>maximumPoolSize：指最大线程数，当任务队列满时，需要创建临时进程处理无法进入任务队列的任务。当临时进程空闲时，会被销毁</li>
<li>keepAliveTime&amp;TimeUnit：最大空闲时间和时间单位，当临时进程空闲时间超过最大空闲时间后，便会被销毁</li>
<li>BlockingQueue：阻塞队列，当核心线程均不空闲时，任务进入队列等待。队列可以用多种数据结构实现，<strong>永远推荐使用有界队列</strong>，即由数组实现的队列，并设立合理的长度。避免造成等待任务过多消耗系统资源。</li>
<li>ThreadFactory ：线程工厂，手动命名创建线程的工厂，方便抛出错误后定位相应线程池</li>
<li>RejectedExecutionHandler：拒绝策略，当任务队列满且所有线程均不空闲时，启用饱和处理机制</li>
</ol>
<p><strong>线程池的阻塞队列</strong></p>
<ol>
<li><strong>ArrayBlockingQueue</strong>：底层采用数组实现的有界队列，初始化需要指定队列的容量。ArrayBlockingQueue 是如何保证线程安全的呢？它内部是使用了一个重入锁 ReentrantLock，并搭配 notEmpty、notFull 两个条件变量 Condition 来控制并发访问。从队列读取数据时，如果队列为空，那么会阻塞等待，直到队列有数据了才会被唤醒。如果队列已经满了，也同样会进入阻塞状态，直到队列有空闲才会被唤醒。</li>
<li><strong>LinkedBlockingQueue</strong>：底层采用的数据结构是链表，队列的长度可以是有界或者无界的，初始化不需要指定队列长度，默认是 Integer.MAX_VALUE。LinkedBlockingQueue 内部使用了 takeLock、putLock两个重入锁 ReentrantLock，以及 notEmpty、notFull 两个条件变量 Condition 来控制并发访问。采用**读锁和写锁(锁分离)**的好处是可以避免读写时相互竞争锁的现象，所以相比于 ArrayBlockingQueue，LinkedBlockingQueue 的性能要更好。</li>
<li><strong>SynchronousQueue</strong>：又称无缓冲队列。比较特别的是 SynchronizedQueue 内部不会存储元素。与 ArrayBlockingQueue、LinkedBlockingQueue 不同，SynchronizedQueue 直接使用 CAS 操作控制线程的安全访问。其中 put 和 take 操作都是阻塞的，每一个 put 操作都必须阻塞等待一个 take 操作，反之亦然。所以 SynchronizedQueue 可以理解为生产者和消费者配对的场景，双方必须互相等待，直至配对成功。在 JDK 的线程池 Executors.newCachedThreadPool 中就存在 SynchronousQueue 的运用，对于新提交的任务，如果有空闲线程，将重复利用空闲线程处理任务，否则将新建线程进行处理。</li>
<li><strong>PriorityBlockingQueue</strong>：底层最小堆实现的优先级队列，队列中的元素按照优先级进行排列，每次出队都是返回优先级最高的元素。PriorityBlockingQueue 内部是使用了一个 ReentrantLock 以及一个条件变量 Condition notEmpty 来控制并发访问，不需要 notFull 是因为 PriorityBlockingQueue 是无界队列，所以每次 put 都不会发生阻塞。PriorityBlockingQueue 底层的最小堆是采用数组实现的，当元素个数大于等于最大容量时会触发扩容，在扩容时会先释放锁，保证其他元素可以正常出队，然后使用 CAS 操作确保只有一个线程可以执行扩容逻辑。</li>
</ol>
<h2 id="如何确定核心线程数，最大线程数，任务队列长度"><a href="#如何确定核心线程数，最大线程数，任务队列长度" class="headerlink" title="如何确定核心线程数，最大线程数，任务队列长度"></a>如何确定核心线程数，最大线程数，任务队列长度</h2><p>核心线程数：IO密集型：CPU数*2；CPU密集型：CPU数+1</p>
<p>最大线程数：(每秒产生的最大任务数-任务队列长度)*单个任务执行时间</p>
<p>任务队列长度：核心线程数&#x2F;单个任务执行时间*2</p>
<h2 id="饱和处理机制有哪些"><a href="#饱和处理机制有哪些" class="headerlink" title="饱和处理机制有哪些"></a>饱和处理机制有哪些</h2><ol>
<li>AbortPolicy：丢弃任务并抛出异常</li>
<li>DiscardPolicy：丢弃任务不抛出异常</li>
<li>DiscardOldestPolicy：丢弃最前面的任务，然后重新提交被拒绝的任务</li>
<li>CallerRunsPolicy：直接调用线程处理该任务</li>
</ol>
<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>CAS全称为compare and swap，即比较和交换</p>
<p>这是JDK提供的原子性操作。语义上是两步操作，但是CPU一条指令即可以完成</p>
<p>汇编指令：lock cmpxchg  </p>
<p>原子性保证lock：当执行cmpxchg时，其他CPU不允许打断这个操作，lock是硬件级的实现：锁定北桥信号</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//unsafe包中的CAS操作，硬件级的原子操作</span><br><span class="hljs-comment">//更新变量值为x，如果当前值为expected</span><br><span class="hljs-comment">//o：对象 offset：偏移量 expected：期望值 x：新值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapObject</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, Object expected, Object x)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapInt</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> expected, <span class="hljs-type">int</span> x)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapLong</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, <span class="hljs-type">long</span> expected, <span class="hljs-type">long</span> x)</span>;<br></code></pre></td></tr></table></figure>

<p><strong>如果对象中的变量值为expect，则使用新的值update替换expect</strong></p>
<p><strong>替换成功，返回true；替换失败，即变量值不为expect，返回false；</strong></p>
<p>特点：非阻塞，即允许多个线程对共享资源进行修改，但是同一时刻只有一个线程可以进行写操作，其他线程并不是被阻塞，而是在不停重试拿到锁。</p>
<p>在JAVA中若一个线程没有拿到锁被阻塞，就会造成线程的上下文切换，大量线程的重新调度会造成性能的浪费。</p>
<p>volatile只能保证<strong>有序性和可见性</strong>，不能保证原子性。CAS就保证了<strong>原子性</strong>。</p>
<p>CAS和volatile两者可以实现无锁并发</p>
<p>所以自旋锁便是通过CAS来实现的，在获取锁的时候使用while循环不断进行CAS操作，类似于不断旋转，直到操作成功返回<code>true</code>，在释放锁的时候使用CAS将锁的状态从1变成0。</p>
<img src="../img/CAS.png" srcset="/img/loading.gif" lazyload alt="CAS" style="zoom: 80%;" />

<h4 id="ABA问题："><a href="#ABA问题：" class="headerlink" title="ABA问题："></a>ABA问题：</h4><p>假如线程1使用CAS修改初始值为A的变量X&#x3D;A，那么线程1首先会获取当前变量X的值（A），然后使用CAS操作尝试修改X的值为B，如果使用CAS修改成功了，那么程序运行一定是正常的吗？</p>
<p>有可能在线程1获取到变量X的值A后，在执行CAS之前，线程2使用了CAS修改了变量X值为B，然后又使用了CAS操作使得变量X值为A，虽然线程A执行了CAS操作时X&#x3D;A，但是这个A已经不是线程1获取到的A了。这就是ABA问题，ABA问题的产生是因为变量的状态值产生了<strong>环形转换</strong>，就是变量值可以从A到B，也可以B到A，如果变量的值只能朝着一个方向转换，例如A到B，B到C，不构成环路，就不会存在这个问题。</p>
<h4 id="如何解决ABA问题"><a href="#如何解决ABA问题" class="headerlink" title="如何解决ABA问题"></a><em><strong>如何解决ABA问题</strong></em></h4><p><strong>引入原子类：</strong></p>
<p><strong>AtomicStampedReference</strong> 是通过版本号<strong>（时间戳）</strong>来解决 ABA 问题的，也可以使用版本号（verison）来解决 ABA，即乐观锁每次在执行数据的修改操作时，都带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行 +1 操作，否则执行失败。</p>
<p><strong>AtomicMarkableReference</strong> 则是将一个 <strong>boolean 值</strong>作是否有更改的标记，本质就是它的版本号只有两个，true 和 false，修改的时候在两个版本号之间来回切换，虽然这样做并不能解决 ABA 的问题，但是会降低 ABA 问题发生的几率。</p>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>即线程本地变量，使公共变量可以在多个线程内进行隔离访问</p>
<p><code>static ThreadLocal&lt;Object&gt; TL = new ThreadLocal&lt;&gt;();</code></p>
<p>若线程1对TL设置内容Value1，此时线程2是无法通过get方法拿到Value1的</p>
<h3 id="常用方法及实现原理"><a href="#常用方法及实现原理" class="headerlink" title="常用方法及实现原理"></a>常用方法及实现原理</h3><p>set (T value)：设置线程本地变量的内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-comment">// 获取当前线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">// 获取当前线程的threadLocals字段</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-comment">// 判断线程的threadLocals是否初始化了</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//this就是公共变量TL</span><br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 没有则创建一个ThreadLocalMap对象进行初始化</span><br>        createMap(t, value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>每一个thread对象里都会自带一个threadLocals对象，而这个对象就是ThreadLocalMap的实例</p>
<p>ThreadLocalMap就是一个存储Entry即键值对的数组，初始化时threadLocals会设置为null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure>

<p><strong>所以set方法并不是往tl对象里面装内容，而是以tl的引用为K，value为V，生成Entry装入该线程的map中</strong></p>
<h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><p>ThreadLocalMap实现了map接口，但是和hashmap不同，它没有链表或者红黑树，<strong>它就是一个散列数组</strong></p>
<p>当发生哈希碰撞的时候，ThreadLocalMap会以<strong>线性探测</strong>的方式：即指针向后不断移动直到找到null或者相同的key为止，这种方式来存储元素。</p>
<p>ThreadLocalMap的hash值计算：使用<code>斐波那契数的倍数</code> 和<code>(len -1)</code> 按位与：<code>int i = key.threadLocalHashCode &amp; (len - 1);</code></p>
<p>ThreadLocalMap的扩容：当元素数大于len*2&#x2F;3时，便会启动扩容，同样是2倍扩容</p>
<p>过期数据的清理：</p>
<ol>
<li>探测式清理：从开始位置向后遍历，清除过期元素，将遍历到的过期数据的 <code>Entry</code> 设置为 <code>null</code> ，沿途碰到的未过期的数据则将其 <code>rehash</code> 后重新在 <code>table</code> 中定位，如果定位到的位置有数据则往后遍历找到第一个 <code>Entry=null</code> 的位置存入。接着继续往后检查过期数据，直到遇到空的桶才终止探测。</li>
<li>启发式清理：从参数i开始向后遍历lg2n个位置，遍历中遇到位置上 <code>key=null</code> 时，从此处同步调用探测时清理方法。</li>
</ol>
<p>get()：获取线程本地变量的内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 获取ThreadLocal对应保留在Map中的Entry对象</span><br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-comment">// 获取ThreadLocal对象对应的值</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// map还没有初始化时创建map对象，并设置null，同时返回null</span><br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/../img/ThreadLocal.png" srcset="/img/loading.gif" lazyload alt="ThreadLocal"></p>
<p>Entry继承了弱引用类，说明这里的每一个Entry都是一个弱引用，弱引用的使用可以避免内存泄漏</p>
<p><img src="/../img/threadLocal1.png" srcset="/img/loading.gif" lazyload alt="threadLocal1"></p>
<p><img src="/../img/ThreadLocal2.png" srcset="/img/loading.gif" lazyload alt="ThreadLocal2"></p>
<p>ThreadLocal对象的作用：</p>
<ol>
<li>引用作为key来进行查找entry的值</li>
<li>维护map，ThreadLocalMap的设置删除都是由ThreadLocal来进行的</li>
</ol>
<p>在ThreadLocalMap的set&#x2F;getEntry中，会对key进行判断，<strong>如果key为null，那么value也会被设置为null</strong>，这样即使在忘记调用了remove方法，当ThreadLocal被销毁时，对应value的内容也会被清空，避免了内存泄漏。</p>
<h3 id="为什么ThreadLocal包装的变量可以实现线程隔离？"><a href="#为什么ThreadLocal包装的变量可以实现线程隔离？" class="headerlink" title="为什么ThreadLocal包装的变量可以实现线程隔离？"></a><em>为什么ThreadLocal包装的变量可以实现线程隔离？</em></h3><p>thread对象内不方便手动添加成员变量，所以就使用ThreadLocal来实现成员变量的效果。ThreadLocal对象本身不存储值，而是作为一个key来查找不同线程中的map的value，不同线程<strong>以ThreadLocal的弱引用作为key的Entry里的Value肯定都是不同的</strong>，每一个线程内的map都保存了一份副本各玩儿各的，所以就实现了线程隔离。</p>
<h2 id="ThreadLocal的应用场景"><a href="#ThreadLocal的应用场景" class="headerlink" title="ThreadLocal的应用场景"></a><em>ThreadLocal的应用场景</em></h2><ol>
<li>Spring的@Transaction事务声明的注解中就使用ThreadLocal保存了当前的Connection对象，避免在本次调用的不同方法中使用不同的Connection对象。</li>
<li>依赖于ThreadLocal本身的特性，对于需要进行线程隔离的变量可以使用ThreadLocal进行封装</li>
</ol>
<h1 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h1><p>同步锁，保证在同一时刻，被修饰的代码块或方法只有一个线程执行，以达到并发安全的效果</p>
<p>同步锁是解决并发问题最简单的一种方法，直接给代码块加上此关键字即可</p>
<p>在JDK1.5之前，Synchronized是一个重量级锁，在以后的版本经过改进后成重量级减小</p>
<p>synchronized的作用主要有三个：</p>
<ol>
<li><strong>原子性</strong>：确保线程<strong>互斥</strong>地访问同步代码；</li>
<li><strong>可见性</strong>：保证共享变量的修改能够及时可见，其实是通过Java内存模型中的“<strong>对一个变量unlock操作之前，必须要同步到主内存中</strong>；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值” 来保证的；</li>
<li><strong>有序性</strong>：有效解决重排序问题，即 “一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”；</li>
</ol>
<h2 id="底层实现："><a href="#底层实现：" class="headerlink" title="底层实现："></a>底层实现：</h2><p>对象在JVM的内存布局为：对象头+实例数据+对齐填充</p>
<h3 id="对象头（12字节）"><a href="#对象头（12字节）" class="headerlink" title="对象头（12字节）"></a>对象头（12字节）</h3><p>其中有4字节的class pointer和8字节的MarkWord</p>
<p>后者是实现锁的关键，MarkWord被设计成一个非固定的数据，它会根据对象的状态复用自身的空间，即会随着程序的运行发生变化。MarkWord的最后三字节分别为：<strong>1bit记录是否为偏向锁</strong>；<strong>2bit记录锁标志位。</strong>当锁标志位变为00时为轻量级锁，01代表未锁定或者可加偏向锁，10时为重量级锁。</p>
<h3 id="Monitor对象"><a href="#Monitor对象" class="headerlink" title="Monitor对象"></a>Monitor对象</h3><p>如果使用Synchronize修饰了一个对象，则MarkWord就会指向一个唯一的Monitor对象，并将标志位改为10，由操作系统提供</p>
<p>Monitor中有三个变量，分别是Owner、EntryList和WaitSet</p>
<p>Owner：当线程抢占到锁后，Owner就会指向该线程</p>
<p>EntryList：当其他线程以自旋形式抢占Owner超过阈值后，便会进入阻塞状态，放入EntryList，等待被唤醒</p>
<h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><ol>
<li>thread0执行synchronize代码的时候，synchronized(obj)的obj对象的markword中ptr_to_heavyweight_monitor（指向monitor的指针）会指向一个monitor对象，执行cas操作将monitor的owner设置为thread0。<strong>在字节码中对应monitorenter操作指令</strong></li>
<li>thread1执行到synchronized代码时,发现obj的markword指向了一个monitor并且owner不为null 并且不为抢锁线程,这时会进入entrylist进行blocked，thread2也一样</li>
<li>thread0执行完同步代码退出synchronized，把obj markword里的数据还原比如hashcode，这些数据是存在monitor对象中的，然后根据不同的策略去唤醒entrylist的thread1和thread2的blocked线程，两个线程去抢owner。<strong>在字节码中对应monitorexit操作指令</strong></li>
</ol>
<h3 id="偏向锁："><a href="#偏向锁：" class="headerlink" title="偏向锁："></a>偏向锁：</h3><p>当一个线程访问加了同步锁的代码块时，<strong>会在对象头中存储当前线程的 ID</strong>，<strong>后续这个线程进入和退出这段加了同步锁的代码块时，不需要再次加锁和释放锁</strong>。而是直接比较对象头里面是否存储了指向当前线程的偏向锁。如果相等表示偏向锁是偏向于当前线程的，就不需要再尝试获得锁了。</p>
<p>说白了就是消除无竞争情况下的性能消耗，避免一个线程的情况下也去竞争锁，造成浪费资源。</p>
<p>底层实现原理：</p>
<ol>
<li>首先获取锁 对象的 MarkWord，判断是否处于可偏向状态。偏向锁状态位0，锁标志01</li>
<li>如果是可偏向状态，则通过 CAS 操作，把当前线程的 ID 写入到 MarkWord<br>a) 如果 CAS 成功，那么 MarkWord就会记录当前线程的ID。 表示已经获得了锁对象的偏向锁，接着执行同步代码块<br>b) 如果 CAS 失败，说明有其他线程已经获得了偏向锁，这种情况说明当前锁存在竞争，需要撤销已获得偏向锁的线程，并且把它持有的锁升级为轻量级锁（这个操作需要等到全局安全点，也就是没有线程在执行字节码）才能执行</li>
<li>如果是已偏向状态，需要检查 MarkWord 中存储的<br>线程ID 是否等于当前线程的 线程ID<br>a) 如果相等，不需要再次获得锁，可直接执行同步代码块<br>b) 如果不相等，说明当前锁偏向于其他线程，需要撤销偏向锁并升级到轻量级锁</li>
</ol>
<h3 id="轻量级锁："><a href="#轻量级锁：" class="headerlink" title="轻量级锁："></a>轻量级锁：</h3><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建 一个LockRecord</p>
<p>然后线程尝试使用CAS将对象头中的MarkWord替换为指向锁记录的指针(即00)，官方称为Displaced Mark Word，谁成功将LockRecord贴上去了，谁就拿到锁了。</p>
<p>如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p>
<p>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。</p>
<p>轻量级锁不进行阻塞，而是使用自旋的方式，自旋虽然提升了响应速度，但是会增大CPU的消耗</p>
<h3 id="重量级锁："><a href="#重量级锁：" class="headerlink" title="重量级锁："></a>重量级锁：</h3><p>当竞争加剧，比如自旋次数超过某一阈值，就会升级为重量级锁，JDK1.6之前，需要自己进行调优设置自旋阈值，需要参考CPU核数。而以后的版本加入了自适应自旋，由JVM自动控制。</p>
<p>此时需要向操作系统申请资源，申请mutex，将MarkWord替换为指向mutex的指针，拿到重量级锁</p>
<p>其他线程进入阻塞队列，等待OS的调度，wait状态的线程不消耗cpu</p>
<p>阻塞线程需要cpu从用户态转到内核态，代价比较大。而且可能会出现刚阻塞不久，锁就被释放的情况，所以阻塞的方式会降低响应速度</p>
<p>锁会随着线程的竞争情况逐渐升级，偏向锁 &#x3D;&gt; 轻量级锁 &#x3D;&gt; 重量级锁 。锁可以升级但是不能降级。升级的目的是为了提高获得锁和释放锁的效率。</p>
<h1 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h1><p>Volatile关键字的作用主要有如下两个：</p>
<ol>
<li>线程的可见性：当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。</li>
<li>顺序一致性：禁止指令重排序</li>
</ol>
<p>Volatile和synchronized的区别</p>
<ol>
<li>Volatile是轻量级的synchronized，因为它不会引起上下文的切换和调度，所以Volatile性能更好。</li>
<li>Volatile只能修饰变量，synchronized可以修饰方法，静态方法，代码块，类。</li>
<li>volatile仅能实现变量的修改可见性，并不能保证原子性，synchronized则可以保证原子性。</li>
<li>多线程访问volatile不会发生阻塞，而synchronized会发生阻塞。</li>
<li>volatile是变量在多线程之间的可见性，synchronize是多线程之间访问资源的同步性。</li>
</ol>
<h2 id="如何保证线程的可见性"><a href="#如何保证线程的可见性" class="headerlink" title="如何保证线程的可见性"></a>如何保证线程的可见性</h2><h4 id="JAVA的内存模型"><a href="#JAVA的内存模型" class="headerlink" title="JAVA的内存模型"></a>JAVA的内存模型</h4><p>线程之间的共享变量存储在主内存中，而每一个线程都有一个私有的本地内存，local memory存储了该线程读写的共享变量的副本。所以当一个线程在本地内存更新共享变量的副本后，需要重新写入主内存。</p>
<p>如何将新值刷新到主内存中：</p>
<p><strong>CPU寄存器-&gt;Cache-&gt;Main memory</strong>，写缓冲区可以避免处理器停顿下来等待写入数据而造成的延迟，并且写缓冲区可以合并多次写，减少对内存总线的占用。</p>
<p>但是在写入主内存之前，另外一个线程是看不到的，所以就需要volatile关键则来保证可见性</p>
<p>当线程对volatile修饰的变量进行写操作时，<strong>汇编指令会多出一个lock前缀，这就是内存屏障，而在多核心环境下，这个前缀会对应两个操作：</strong></p>
<ol>
<li>将当前<strong>缓存行的数据立即写回系统内存</strong></li>
<li>这个写回内存的操作会使其他cpu里缓存的副本无效化</li>
</ol>
<p><strong>这就是缓存一致性协议，每个处理器通过嗅探在总线传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，从而需要重新从系统内存中读取数据。</strong></p>
<p>所以多核心环境下，每一个线程读取被volatile修饰的变量时，都必须在主内存中读取最新的结果，而不是使用local memory内的数据，这样保证了一个线程修改变量的结果其他线程都是可知的，保证了线程的可见性。</p>
<h2 id="如何禁止指令重排"><a href="#如何禁止指令重排" class="headerlink" title="如何禁止指令重排"></a>如何禁止指令重排</h2><p>同样依赖于lock前缀，即内存屏障实现</p>
<p>编译器不会对volatile读与volatile读后面的任意内存操作重排序；</p>
<p>编译器不会对volatile写与volatile写前面的任意内存操作重排序。</p>
<p><img src="/../img/volatile1.png" srcset="/img/loading.gif" lazyload alt="volatile1"></p>
<p><img src="/../img/volatile2.png" srcset="/img/loading.gif" lazyload alt="volatile2"></p>
<p>Unsafe 方法</p>
<ol>
<li>**putOrderedXxx()**，使用 StoreStore 屏障，会把最新值更新到主内存，但不会立即失效其它缓存行中的数据，是一种延时更新机制；</li>
<li>**putXxxVolatile()**，使用 StoreLoad 屏障，会把最新值更新到主内存，同时会把其它缓存行的数据失效，或者说会刷新其它缓存行的数据；</li>
<li>**putXxx(obj, offset)**，不使用任何屏障，更新对象对应偏移量的值；</li>
<li>**getXxxVolatile()**，使用 LoadLoad 屏障，会从主内存获取最新值；</li>
<li>**getXxx(obj, offset)**，不使用任何屏障，读取对象对应偏移量的值；</li>
</ol>
<h1 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h1><p>synchronized存在一些问题：</p>
<ol>
<li><p>NonfairSync：加入持有锁的线程因为等待长时间IO或者其他原因，其他等待的线程无法响应中断，只能不断等待</p>
<p><code>公平锁即尽量以请求锁的顺序来获取锁。比如同时有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该锁。</code></p>
<p><code>非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。</code></p>
</li>
<li><p>synchronize是悲观锁，独占性很强，对读和写操作均是独占的</p>
</li>
<li><p>使用synchronized关键字无法确认线程是否成功获取到锁</p>
</li>
</ol>
<h2 id="异常是否释放"><a href="#异常是否释放" class="headerlink" title="异常是否释放"></a>异常是否释放</h2><p>synchronized关键字在发生异常时会自动释放占有的锁，因此不会出现死锁；而lock发生异常的时候，必须手动unlock来释放锁，可能会引起死锁。解决方式：try catch包裹代码块，finally中写入unlock</p>
<h2 id="是否响应中断"><a href="#是否响应中断" class="headerlink" title="是否响应中断"></a>是否响应中断</h2><p>lock可以用interrupt来中断等待，而synchronized只能不断等待锁的释放，不能响应中断</p>
<h2 id="是否知道获取锁"><a href="#是否知道获取锁" class="headerlink" title="是否知道获取锁"></a>是否知道获取锁</h2><p>lock可以通过trylock来知道有没有获取锁，而synchronized不能</p>
<h2 id="两者的异同"><a href="#两者的异同" class="headerlink" title="两者的异同"></a>两者的异同</h2><ol>
<li>在JDK1.5之前lock的性能优于synchronized，以后的版本，在不断优化降低锁的重量级后，两者的性能差距缩小。</li>
<li>lock是一个接口，而synchronized是一个关键字</li>
<li>lock可以有多个获取锁的方式，可以不用一直等待。而synchronized只能等待</li>
<li>Lock适合用于大量线程的同步，且大量线程竞争激烈时，lock的性能更优，lock锁还能使用readwritelock实现读写分离，提高多线程的读操作效率。</li>
<li>lock可以实现公平锁与非公平锁，synchronized只能实现非公平锁</li>
</ol>
<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p>即AbstractQueuedSynchronizer类，抽象队列同步器，AQS是JUC的基类</p>
<p>基于 volitile修饰的状态记录量<strong>state</strong>+Node对象构建的双向链表，先进先出，也就是队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//node类携带的信号量</span><br><span class="hljs-comment">//排他锁标识</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">node</span> <span class="hljs-variable">EXCLUSIVE</span> <span class="hljs-operator">=</span>  <span class="hljs-literal">null</span>;<br><span class="hljs-comment">//后继节点需要被唤醒</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><span class="hljs-comment">//该节点已失效</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">//只有上一个节点是的ws为SIGNAL，当前节点才有可能被上一个节点唤醒</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> waitStatus;<br><br></code></pre></td></tr></table></figure>

<h3 id="加锁（非公平为例）"><a href="#加锁（非公平为例）" class="headerlink" title="加锁（非公平为例）"></a>加锁（非公平为例）</h3><p>当调用lock()时，线程会尝试使用CAS的方式将state从0改变为1，返回true则证明成功拿到锁，将ExclusiveOwnerThread指向当前线程。若为重入，则会增加state的值。</p>
<p>拿锁失败则会被放入队列。若队列为空，则会建立一个空节点作为哨兵，然后将此节点放在哨兵后。队列中的线程会acquireQueued()，内部由一个死循环实现，自旋地，独占且不可中断的方式获取同步状态，位于第二个节点的线程才有资格抢占锁，抢占后将晋升为头节点，原先的头节点会等待被GC。</p>
<p>若获取锁失败或无资格获取锁，则会则根据前驱节点的waitStatus决定是否需要挂起线程，若为SIGNAL，则当前节点被安全阻塞。</p>
<p>若为CANCELLED，则会向前查找到为SIGNAL的节点，并重新设置前驱节点，相当于是剔除了失效节点。</p>
<p>若为0或者其他状态，通过CAS的方式设置为SIGNAL</p>
<h3 id="锁的释放"><a href="#锁的释放" class="headerlink" title="锁的释放"></a>锁的释放</h3><p>release(int arg)，先检测state，若state减一后仍不为0，则代表有重入，返回false，等待下一次的释放。</p>
<p>当state为0时，才会进行unpark()，即释放锁</p>
<p>unparkSuccessor()，传入head节点，检测到后继节点中第一个waitStatus为-1的节点，并解除挂起状态</p>
<h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span><br></code></pre></td></tr></table></figure>

<p>互斥锁，可重入锁，也是可以实现公平锁和非公平锁（默认）的一种锁。内部包含一个AQS对象，并基于AQS实现</p>
<p>NonfairSync：非公平锁无论是队列里，还是外来线程，都会通过CAS直接尝试获取锁，能抢到锁到直接占有锁，抢不到才会到等待队列的队尾等待。</p>
<p>fairSync：公平锁则是所有线程并发进入acquire方法，通过hasQueuedPredecessors方法来严格控制队列获取锁的顺序，外来线程无法参与竞争。</p>
<p><img src="/../img/reentrantLock.png" srcset="/img/loading.gif" lazyload alt="reentrantLock"></p>
<p>ReentrantLock内部有三个类</p>
<p><img src="/../img/reentrantLock1.png" srcset="/img/loading.gif" lazyload alt="reentrantLock1"></p>
<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p>CountDownLatch是一个倒数的计数器阀门，初始化时阀门关闭，指定计数的数量，当数量倒数减到0时阀门打开，被阻塞线程被唤醒</p>
<p>工作方式：初始值为线程数，当线程完成自己的任务后，计数器的值就减一，当计数器为0时，表示所有线程都已完成任务。然后等待的线程就可以恢复执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//构造函数，需要指定一个等于线程数的int数值</span><br>CountDownLatch(<span class="hljs-type">int</span> count);<br><span class="hljs-comment">//当前线程调用该方法会进入等待状态，直到同步器状态为0时被其他线程唤醒或者被其他线程中断。也即将计数器减为0返回true的线程负责唤醒阻塞的线程。当计数器为0时，调用await()方法将立即返回</span><br>await();<br><span class="hljs-comment">//该方法与await()作用一样，只是添加了等待的时间，如果超过等待时间还没有被唤醒或者被中断，那么阻塞线程将退出阻塞状态;</span><br>await(<span class="hljs-type">long</span> timeout, TimeUnit unit);<br><span class="hljs-comment">//该方法主要是将指定的计数器减1，当计数器已经是0了调用该方法将会被忽略，也就是说计数器的值最小只能是0</span><br>countDown();<br></code></pre></td></tr></table></figure>

<p>原理：维护一个AQS，将state设置为Count数量，当state为0时，才会唤醒队列中的线程</p>
<h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a><strong>CyclicBarrier</strong></h1><p>CyclicBarrier是一个可循环的屏障，它允许多个线程在执行完相应的操作后彼此等待共同到达一个point，等所有线程都到达后再继续执行。比如等所有运动员都跨过第一个栅栏后，才允许继续向前。</p>
<p>工作方式：初始值同样为线程数，当线程完成自己的任务后，计数器的值减一，若state不为0，则自身阻塞，直到state为0，即所有线程都完成任务后，才会从障碍点继续运行。</p>
<p>CyclicBarrier是可以循环的，每个线程可以调用两次的await()方法，重复利用栅栏的计数器。调用nextGeneration()方法，唤醒所有阻塞线程，并重置count。</p>
<p>原理：维护ReentryLock的Lock方法和Condition实现</p>
<p>而计数器阀门则不可以循环，count为0后就不能再使用。</p>
<h3 id="CyclicBarrier和CountDownLatch区别"><a href="#CyclicBarrier和CountDownLatch区别" class="headerlink" title="CyclicBarrier和CountDownLatch区别"></a>CyclicBarrier和CountDownLatch区别</h3><ol>
<li>CountDownLatch的await()线程会等待计数器减为0，而执行CyclicBarrier的await()方法会使线程进入阻塞等待其他线程到达障点</li>
<li>CountDownLatch计数器不能重置，CyclicBarrier可以重置循环利用，可以应对更多的情况，比如程序出错后重置</li>
<li>CountDownLatch是基于AQS的共享模式实现的，CyclicBarrier是基于ReentrantLock和Condition实现的</li>
<li>CountDownLatch会阻塞主线程，CyclicBarrier不会阻塞主线程，只会阻塞子线程</li>
</ol>
<h1 id="原子类Atomic"><a href="#原子类Atomic" class="headerlink" title="原子类Atomic"></a>原子类Atomic</h1><p><img src="/../img/Atomic%E8%AF%A6%E8%A7%A3.png" srcset="/img/loading.gif" lazyload alt="Atomic详解"></p>
<p>基本类型</p>
<ol>
<li>AtomicInteger：线程安全的整型</li>
<li>AtomicBoolean：线程安全的布尔类型</li>
<li>AtomicLong：线程安全的长整型</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//都是通过CAS操作（unsafe）来实现的</span><br>getAndIncrement() <span class="hljs-comment">// 原子化 i++</span><br>getAndDecrement() <span class="hljs-comment">// 原子化的 i--</span><br>incrementAndGet() <span class="hljs-comment">// 原子化的 ++i</span><br>decrementAndGet() <span class="hljs-comment">// 原子化的 --i</span><br>    <br>getAndAdd(delta) <span class="hljs-comment">// 当前值 +=delta，返回 += 前的值</span><br>addAndGet(delta)<span class="hljs-comment">// 当前值 +=delta，返回 += 后的值</span><br>compareAndSet(expect, update)<span class="hljs-comment">//CAS 操作，返回是否成功</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//this对应着当前对应</span><br>    <span class="hljs-comment">//valueOffset对应着当前属性在对象中的内存偏移地址</span><br>    <span class="hljs-comment">//1代表着增加的数量</span><br>    <span class="hljs-comment">//注意是unsafe方法</span><br>    <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-built_in">this</span>, valueOffset, <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAddInt</span><span class="hljs-params">(Object var1, <span class="hljs-type">long</span> var2, <span class="hljs-type">int</span> var4)</span> &#123;<br>    <span class="hljs-type">int</span> var5;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">//获取在内存中的值</span><br>        var5 = <span class="hljs-built_in">this</span>.getIntVolatile(var1, var2);<br>    &#125; <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));<br>    <span class="hljs-comment">//自旋CAS，var5是希望的旧值，var5+var4是新值，只有当内存中的值等于var5，也就是当前内存中的值等于希望的旧值的时候，才会更新成功，返回true</span><br>    <span class="hljs-keyword">return</span> var5;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>累加器</p>
<ol>
<li><strong>LongAdder</strong>(性能优)</li>
<li>LongAccumulator</li>
<li>DoubleAdder</li>
<li>DoubleAccumulator</li>
</ol>
<h2 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h2><p><img src="/../img/longadder.png" srcset="/img/loading.gif" lazyload alt="longadder"></p>
<p>在多线程累加的情况下LongAdder拥有比synchronized,AtomicInteger,AtomicLong,LongAccumulator更高的性能</p>
<p>synchronized肯定是最慢的</p>
<p><img src="/../img/LongAdder1.png" srcset="/img/loading.gif" lazyload alt="LongAdder1"></p>
<p> LongAdder在无竞争的情况，跟AtomicLong一样，对同一个base进行操作</p>
<p> 当出现竞争关系时则是采用一个数组cells，将一个value拆分进这个数组Cells</p>
<p>多个线程需要同时对value进行操作时，可以对线程id进行hash得到hash值，再根据hash值映射到这个数组cells的某个下标，再对该下标所对应的值进行自增操作。当所有线程操作完毕，将数组cells的所有值和无竞争值base都加起来作为最终结果。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><h4 id="为什么这么快"><a href="#为什么这么快" class="headerlink" title="为什么这么快"></a><em><strong>为什么这么快</strong></em></h4><p>LongAdder的基本思路就是<strong>分散热点</strong>，将value值分散到一个Cell数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。</p>
<p>无并发的时候，单线程下直接CAS操作更新base值。有并发的时候，多线程下分段CAS操作更新Cell数组值</p>
<p>如果要获取真正的long值，只要将各个槽中的变量值累加返回。sum()会将<strong>所有Cell数组中的value和base累加</strong>作为返回值</p>
<p>核心的思想就是将之前AtomicLong一个value的更新压力分散到多个value中去，从而降级更新热点。</p>
<h4 id="与AtomicLong的区别"><a href="#与AtomicLong的区别" class="headerlink" title="与AtomicLong的区别"></a><em><strong>与AtomicLong的区别</strong></em></h4><p><strong>原理不同：</strong></p>
<p>AtomicLong是以CAS的自旋方式来进行加减</p>
<p>LongAdder则是以CAS+Base+Cell数组分散热点，通过空间换时间分散了热点数据</p>
<p><strong>场景不同：</strong></p>
<p>AtomicLong适用于低并发下的全局计算，能保证并发情况下计数的准确性，可允许一些性能损耗，要求高精度时可使用</p>
<p>LongAdder适用于高并发下的全局计算，当需要在高并发下有较好的性能表现，且对值的精确度要求不高时，可以使用</p>
<p><strong>各有缺点：</strong></p>
<p>AtomicLong 高并发后性能急剧下降</p>
<p>LongAdder 求和后还有计算线程修改结果的话，最后结果不够准确</p>
<h1 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h1><h2 id="按抽象概念分"><a href="#按抽象概念分" class="headerlink" title="按抽象概念分"></a>按抽象概念分</h2><ol>
<li>悲观锁：悲观地认为数据大概率会被其他线程操作，所以具有强烈的独占性和排它性，比如synchronized，先加锁再执行代码块</li>
<li>乐观锁：相反，乐观地认为数据不大会被其他线程操作，所以先执行代码块，遇见线程冲突的情况，再补偿</li>
<li>自旋锁：自旋锁是乐观锁的一种实现形式，首先需要了解一些概念</li>
</ol>
<h2 id="按读写属性分"><a href="#按读写属性分" class="headerlink" title="按读写属性分"></a>按读写属性分</h2><ol>
<li>排他锁：又称写锁，X锁，只有一个线程能访问代码块，synchronized关键字即是排他锁。写的时候，不允许其他线程读，也不允许其他线程写</li>
<li>共享锁：又称读锁，S锁，可以有多个线程访问代码块，允许同时读，不允许写，必须等所有锁释放后才可以写</li>
<li>读写锁：概念同上</li>
</ol>
<h2 id="按粒度分"><a href="#按粒度分" class="headerlink" title="按粒度分"></a>按粒度分</h2><ol>
<li>统一锁：大粒度的锁，防止出现死锁。锁定A线程，等待B线程；锁定B，等待A；若没有很好地同步，就会出现死锁统一锁便是将A和B统一为一个大锁</li>
<li>分段锁：JDK1.7 ConcurrentHashMap，如果像HashTable那样锁住整张表，性能会很差，使用分段思想，只对某个segment进行锁定，当锁定一段时，不影响其他段的数据插入，提高了效率，缺点，代码实现复杂。</li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">#Java基础知识</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>JUC</div>
      <div>http://example.com/post/JUC.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>SamuelZhou</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年10月20日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/post/%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%8D%8F%E7%A8%8B.html" title="进程，线程和协程详解">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">进程，线程和协程详解</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/post/%E5%AD%97%E5%85%B8%E5%BA%8F%E9%97%AE%E9%A2%98.html" title="字典序问题">
                        <span class="hidden-mobile">字典序问题</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
