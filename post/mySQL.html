

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="SamuelZhou">
  <meta name="keywords" content="">
  
    <meta name="description" content="MySQL关系型数据库，插件式的存储引擎，这种架构可以根据业务的需求和实际需要选择合适的存储引擎。 MySQL的架构分为两层  Server: Server层负责建立连接，分析，执行SQL。大多数核心部件在此实现，包括连接器，缓存查询，解析器，预处理器，执行器等。还有所有的内置函数和所有的跨引擎的功能如视图，都在Server层实现 Engine: 引擎层负责数据的存储和提取，索引也是有引擎层实现的">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL">
<meta property="og:url" content="http://example.com/post/mySQL.html">
<meta property="og:site_name" content="welcome">
<meta property="og:description" content="MySQL关系型数据库，插件式的存储引擎，这种架构可以根据业务的需求和实际需要选择合适的存储引擎。 MySQL的架构分为两层  Server: Server层负责建立连接，分析，执行SQL。大多数核心部件在此实现，包括连接器，缓存查询，解析器，预处理器，执行器等。还有所有的内置函数和所有的跨引擎的功能如视图，都在Server层实现 Engine: 引擎层负责数据的存储和提取，索引也是有引擎层实现的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/13526879-3037b144ed09eb88.png">
<meta property="og:image" content="http://example.com/img/B+tree.png">
<meta property="og:image" content="http://example.com/img/next-key.png">
<meta property="og:image" content="http://example.com/img/undolog.png">
<meta property="og:image" content="http://example.com/img/phantom.png">
<meta property="article:published_time" content="2022-10-25T14:02:31.000Z">
<meta property="article:modified_time" content="2022-12-08T08:46:03.039Z">
<meta property="article:author" content="SamuelZhou">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/13526879-3037b144ed09eb88.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>MySQL - welcome</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>samuel`s world</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="MySQL"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        SamuelZhou
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-10-25 22:02" pubdate>
          2022年10月25日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          13k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          107 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">MySQL</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>关系型数据库，插件式的存储引擎，这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p>
<p>MySQL的架构分为两层</p>
<ol>
<li>Server: Server层负责建立连接，分析，执行SQL。大多数核心部件在此实现，包括连接器，缓存查询，解析器，预处理器，执行器等。还有所有的内置函数和所有的跨引擎的功能如视图，都在Server层实现</li>
<li>Engine: 引擎层负责数据的存储和提取，索引也是有引擎层实现的</li>
</ol>
<h2 id="执行一条查询语句的流程"><a href="#执行一条查询语句的流程" class="headerlink" title="执行一条查询语句的流程"></a>执行一条查询语句的流程</h2><ol>
<li>连接器建立连接：与客户端进行 TCP 三次握手，校验客户端提供的用户名和密码，读取该客户端的权限</li>
<li>查询缓存：如果要查询一个字段，引擎会先去查询缓存，如果命中，则会直接返回给客户端。但是在MySQL8.0缓存直接被取消了，因为对于更新频繁的表来说，缓存命中率很低。<strong>这个缓存不是buffer pool</strong></li>
<li>解析：词法分析：解析器会根据输入字符串构建SQL语法树，提取出表明，字段名，SQL类型等。语法分析：根据词法分析的结果，根据语法规则判断是否满足SQL语法</li>
<li>预处理：检查 SQL 查询语句中的表或者字段是否存在，将 <code>select *</code> 中的 <code>*</code> 符号，扩展为表上的所有列；</li>
<li>优化：确定SQL语句的执行方案，比如使用哪个索引更快</li>
<li>执行：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端</li>
</ol>
<h3 id="事务的ACID"><a href="#事务的ACID" class="headerlink" title="事务的ACID"></a>事务的ACID</h3><ol>
<li>原子性：要么全部成功，要么全部失败。由undo_log来保证</li>
<li>一致性：数据库总是从一个状态转移到另一个状态</li>
<li>隔离性：最终提交前，其他事务不可见，MVCC</li>
<li>持久性：事务一旦提交，修改将会永久保存到数据库中，redo_log实现</li>
</ol>
<h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><h3 id="1NF-第一范式"><a href="#1NF-第一范式" class="headerlink" title="1NF(第一范式)"></a>1NF(第一范式)</h3><p>属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。<strong>1NF 是所有关系型数据库的最基本要求</strong> ，也就是说关系型数据库中创建的表一定满足第一范式</p>
<blockquote>
<p><strong>如果关系表中的属性不可再细分且属性列不可重复，该关系满足第1范式</strong></p>
</blockquote>
<h3 id="2NF-第二范式"><a href="#2NF-第二范式" class="headerlink" title="2NF(第二范式)"></a>2NF(第二范式)</h3><p>2NF 在 1NF 的基础之上，消除了非主属性对于码的部分函数依赖。如下图所示，展示了第一范式到第二范式的过渡。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键</p>
<blockquote>
<p><strong>第二范式要求关系表中所有数据都要和关系表的主键有完全函数依赖（即属性不能只和主键有部分依赖关系）</strong></p>
</blockquote>
<h3 id="3NF-第三范式"><a href="#3NF-第三范式" class="headerlink" title="3NF(第三范式)"></a>3NF(第三范式)</h3><p>3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。符合 3NF 要求的数据库设计，<strong>基本</strong>上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求</p>
<blockquote>
<p><strong>每一个非主属性既不部分依赖于码也不传递依赖于码</strong></p>
</blockquote>
<ul>
<li>1NF：属性不可再分。</li>
<li>2NF：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。</li>
<li>3NF：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖</li>
</ul>
<h2 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h2><ol>
<li>read uncommitted：所有事务都可以看见未提交的结果，产生脏读</li>
<li>read committed：一个事务从开始到提交前，任何数据改变都是不可见的，产生不可重复读问题</li>
<li>repeatable read：<code>MySQL</code>默认的隔离级别，解决不可重复读问题，保证同一事物的多个实例在并发读取事务时，会读取到同样的数据行，产生幻读问题（<code>InnoDB</code>的MVCC解决了幻读问题）</li>
<li>serializable：最高级别的隔离，强制事务排序，不可能相互冲突，其实就是加锁，效率低</li>
</ol>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p><code>MyISAM</code>和<code>InnoDB</code>的区别是什么</p>
<ol>
<li><code>InnoDB</code>：支持事务，支持外键，聚集索引：文件存储于主键索引的叶子节点上，所以主键索引效率很高，但是辅助索引需要进行回表，并且主键不能过大，因为辅助索引也会存储主键，所以过大的主键会影响索引的大小。最小粒度锁为行锁</li>
<li><code>MyISAM</code>：不支持事务，不支持外键，非聚集索引，索引保存的是数据文件的指针，主键索引和辅助索引独立。会创建一个单独的变量保存整个表的行数，读取表行数的速度更快。最小粒度锁为表锁，并发性能不好。</li>
</ol>
<h2 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h2><p><img src="/../img/13526879-3037b144ed09eb88.png" srcset="/img/loading.gif" lazyload alt="13526879-3037b144ed09eb88"></p>
<ul>
<li><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)</li>
<li><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除）</li>
</ul>
<blockquote>
<p>连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 SQL 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件</p>
<p><strong>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</strong></p>
</blockquote>
<ul>
<li><p><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</p>
</li>
<li><p><strong>优化器：</strong> 选择MySQL 认为最优的执行方案。</p>
</li>
<li><p><strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。</p>
</li>
<li><p><strong>日志模块：</strong>在server层是binlog归档日志模块</p>
</li>
<li><p><strong>插件式存储引擎</strong> ： 主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎</p>
</li>
<li><p><strong>查询语句的执行流程如下：权限校验（如果命中缓存）—&gt;查询缓存—&gt;分析器—&gt;优化器—&gt;权限校验—&gt;执行器—&gt;引擎</strong></p>
</li>
<li><p><strong>更新语句执行流程如下：分析器—-&gt;权限校验—-&gt;执行器—&gt;引擎—redo log(prepare 状态)—&gt;binlog—&gt;redo log(commit状态)</strong></p>
</li>
</ul>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p><em><strong>为什么要有索引</strong></em></p>
<p>一般的应用系统读写比例大约在10：1左右，而且数据的插入和更新出现性能问题的几率小于查询。在生产环境中，最容易出现问题的就是查询操作，因此对查询性能的优化就显得十分重要。</p>
<p>索引的本质就是一个满足某种查找算法的数据结构，常见的有BST，AVL，红黑树，Btree，B+树等等，这些结构以某种方式指向数据（索引结点指向数据记录物理地址的指针）</p>
<ol>
<li>索引大大减少了服务器需要扫描的数据量，提高了检索效率</li>
<li>避免排序，减少CPU消耗</li>
<li>将随机IO转换为顺序IO</li>
</ol>
<p>索引存储于外存，所以索引的查询也需要磁盘IO开销，访问外存的时间成本大约是内存的十万倍</p>
<p>虽然提高了查询速度，但是在对实体表进行更新时，索引也需要进行相应的维护更新</p>
<h3 id="HASH索引"><a href="#HASH索引" class="headerlink" title="HASH索引"></a>HASH索引</h3><p>Memory引擎默认Hash索引</p>
<p>等值查询很快，计算的hash值与对应的行指针一并存入表中，哈希碰撞的元素以链表的形式相连。也不支持排序，以及模糊查询，并且由于散列算法，键值对的存储是无序的，所以不支持范围查询。</p>
<h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h3><p><code>InnoDB</code>，<code>MyISAM</code>默认是B+树</p>
<p>考虑到IO时十分高昂的操作，且数据库动辄百万级数据量，所以当一次IO时，常常以页作为单位来读取数据，当读取一页的数据至内存缓冲区时，实际上才发生了一次IO，所以控制IO的次数对于索引效率的提升，至关重要。</p>
<p>B+树的特点：</p>
<ol>
<li>除叶子结点外的子节点：只起到索引的作用，仅存储指针，不存储信息</li>
<li>所有信息存储于叶子结点，所有叶子结点在底部链接形成一个双向链表（范围查询）</li>
</ol>
<p><strong>在<code>InnoDB</code>中，叶子节点的容量默认为一页16KB</strong>，磁盘预读，预读其实就是利用了局部性原理，具体过程是：对于每个文件的第一个读请求，系统读入所请求的页面并读入紧随其后的少数几个页面（通常是三个页面），这时的预读称为同步预读。<strong>4kb(磁盘一页的大小) + 12kb(预读三个页面) &#x3D; 16kb</strong></p>
<p><strong>叶子节点结构(聚簇索引为例)：页目录（主键）+用户数据区域（单向链表，通过主键排序，在插入数据的时候便会排序）</strong></p>
<p><strong>非叶子节点结构：页指针+指向的该页的最小主键值</strong></p>
<h1 id="MYSQL索引分类"><a href="#MYSQL索引分类" class="headerlink" title="MYSQL索引分类"></a><strong>MYSQL索引分类</strong></h1><ol>
<li><strong>主键索引</strong>：一张表一个主键索引，通常与表一起创建。</li>
<li><strong>唯一索引</strong>：如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。这么做的好处：一是简化了MySQL对这个索引的管理工作，这个索引也因此而变得更有效率；二是MySQL会在有新记录插入数据表时，如果字段的值已经出现过了，MySQL将拒绝插入那条新记录。也就是说，唯一索引可以保证数据记录的唯一性。事实上，在许多场合，人们创建唯一索引的目的往往不是为了提高访问速度，而只是为了避免数据出现重复。</li>
<li><strong>普通索引</strong>：建立在普通字段上的索引，唯一任务是加快对数据的访问速度。因此，应该只为那些最经常出现在查询条件（WHEREc）或排序条件（ORDERBY）中的数据列创建索引。只要有可能，就应该选择一个数据最整齐、最紧凑的数据列（如一个整数类型的数据列）来创建索引。</li>
<li><strong>前缀索引</strong>：字符类型字段的前几个字符建立，可以覆盖多个数据列，遵循最左匹配原则，可能会因为order by失效。</li>
</ol>
<h3 id="普通索引和唯一索引有什么区别？"><a href="#普通索引和唯一索引有什么区别？" class="headerlink" title="普通索引和唯一索引有什么区别？"></a><em><strong>普通索引和唯一索引有什么区别？</strong></em></h3><p><strong>概念上的不同</strong>：普通索引可以重复。而唯一索引和主键一样，不可以重复，但在一张表里面只能有一个主键，不能为空，唯一索引可有多个。唯一索引可有一条记录为null。在学校，一般用学号做主键，身份证号作为唯一索引</p>
<p><strong>查询实现的不同</strong>：若查询语句为</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> T <span class="hljs-keyword">where</span> k<span class="hljs-operator">=</span><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>

<p>普通索引：查找到满足条件的第一个记录后，继续查找下个记录，直到碰到第一个不满足k&#x3D;4的记录。</p>
<p>唯一索引：查到第一个满足条件的，就停止搜索。</p>
<p>若重复数据很多，普通索引多了一次“查找和判断下一条记录”的操作，可能会多次IO，但是总体性能其实差别不大</p>
<p><strong>更新性能不同</strong>：往表中插入一个新记录，<code>InnoDB</code>会有什么反应？</p>
<p>若在内存中，普通索引直接插入，而唯一索引会判断一次是否有冲突，再插入。判断的性能消耗可以不计</p>
<p>若不在内存中，普通索引会将数据记录在change buffer；唯一索引会将数据页读入内存再插入。众所周知数据库的IO成本很高，所以普通索引更新数据的性能是要更优的。</p>
<p><strong>总结：若更新性能优先级更高，选择普通索引。</strong></p>
<h2 id="主键索引-聚簇索引"><a href="#主键索引-聚簇索引" class="headerlink" title="主键索引(聚簇索引)"></a>主键索引(聚簇索引)</h2><p><img src="/../img/B+tree.png" srcset="/img/loading.gif" lazyload alt="B+tree"></p>
<h2 id="辅助索引-非聚簇索引"><a href="#辅助索引-非聚簇索引" class="headerlink" title="辅助索引(非聚簇索引)"></a><strong>辅助索引(非聚簇索引)</strong></h2><p>同样是B+树，以非主键而是以自定义规则的索引，以满足不同的查询需求，属于非聚集索引。</p>
<p>叶子节点的用户数据区不再存储完整记录，而是存储<strong>主键+部分记录</strong>。</p>
<p>所以使用辅助索引有时候需要进行回表，即部分记录无法满足查询需求，需要使用主键来重新到主键索引查找。</p>
<h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>使用表中的多个字段创建索引，就是 <strong>联合索引</strong>，也叫 <strong>组合索引</strong> 或 <strong>复合索引</strong></p>
<p>相反，如果只使用一个字段创建索引，就叫<strong>单列索引</strong></p>
<h2 id="索引失效会出现在什么情况"><a href="#索引失效会出现在什么情况" class="headerlink" title="索引失效会出现在什么情况"></a><em><strong>索引失效会出现在什么情况</strong></em></h2><ol>
<li>对索引使用左或者左右模糊匹配，例如%like，会进行全盘扫描。如果使用like%则会正常使用索引，因为B+树会根据最左的字段开始构建B+树索引，所以若使用%like，引擎会无法知道该从哪个索引值开始比较，所以就只能通过全盘扫描的方式查询。但是也有特殊情况，如果<strong>数据库表中的字段只有主键+二级索引</strong>，那么即使使用了左模糊匹配，也不会走全表扫描（type&#x3D;all），而是走全扫描二级索引树</li>
<li>对索引字段使用函数，索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。当然在8.0之后，增加了函数索引，此时就可以使用索引了</li>
<li>对索引字段进行表达式计算，原因同函数一样</li>
<li>对索引进行隐式类型转换： <strong>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，而这里相当于情况二，会使用一个函数将字符串进行转换，然后再进行比较</strong>。</li>
<li>未遵循最左匹配原则</li>
<li>在where中使用OR：如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li>
<li>引擎估算走辅助索引的时间反而比全表扫描的时间更长</li>
</ol>
<h3 id="什么是最左匹配原则？"><a href="#什么是最左匹配原则？" class="headerlink" title="什么是最左匹配原则？"></a><em><strong>什么是最左匹配原则？</strong></em></h3><p>对于复合索引，若有字段123，若查询时省略字段1，则无法使用索引。</p>
<p>因为数据库依据联合索引最左的字段来构建 B+ 树，叶子节点的排序是以字段123的顺序进行的，只有先确定了前一个（左侧的值）后，才能确定下一个值。a有序，b才能有序，若a省略，则无法有序查找bc。</p>
<p>所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据</p>
<h3 id="非聚簇索引的优缺点？"><a href="#非聚簇索引的优缺点？" class="headerlink" title="非聚簇索引的优缺点？"></a><em><strong>非聚簇索引的优缺点？</strong></em></h3><p>优点：<strong>更新代价比聚集索引要小</strong> 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的</p>
<p>缺点：</p>
<ol>
<li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li>
<li><strong>可能会二次查询(回表)</strong> :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询</li>
</ol>
<h3 id="聚簇索引的优缺点？"><a href="#聚簇索引的优缺点？" class="headerlink" title="聚簇索引的优缺点？"></a><em><strong>聚簇索引的优缺点？</strong></em></h3><p>优点：聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据</p>
<p>缺点：</p>
<ol>
<li><strong>依赖于有序的数据</strong> ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li>
<li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚集索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的</li>
</ol>
<h3 id="MYSQL默认使用B-树，为啥要用B-树，不用B树？"><a href="#MYSQL默认使用B-树，为啥要用B-树，不用B树？" class="headerlink" title="MYSQL默认使用B+树，为啥要用B+树，不用B树？"></a><em><strong>MYSQL默认使用B+树，为啥要用B+树，不用B树？</strong></em></h3><p>因为两者都是存储于磁盘，而IO是花销很大的操作，InnoDB每次申请磁盘空间时都会申请若干条连续的磁盘块来组成一页，并放入内存，读取索引，放回磁盘，不断重复，直到找到数据。</p>
<p>所以如果每次申请到的数据都能有助于定位到所需数据，这将会减少IO次数，提高查询效率。</p>
<p>对于B树，因为B树的每一个结点都会存储键，指针和数据，每个磁盘块的信息存储能力有限，树的高度也会更高，增加了IO次数，所以B树的查询效率波动很大。</p>
<p>而B+树的非叶子结点只存储键，所以B+树的非叶子结点可以存储更多的信息，降低了树高度，平均一次IO可以获取更多索引，所以B+树更适合外存索引，且查询效率更稳定</p>
<p>其中在 MySQL 底层对 B+ 树进行进一步优化：</p>
<p><strong>叶子节之间是双向链表，节点内部是单向链表，且在链表的头结点和尾节点也是循环指向的</strong>。（范围查询的关键）</p>
<h3 id="为什么不用红黑树？"><a href="#为什么不用红黑树？" class="headerlink" title="为什么不用红黑树？"></a><em><strong>为什么不用红黑树？</strong></em></h3><p>无论是二叉树还是红黑树，都会因为树的深度过深而导致IO次数变多，效率不高</p>
<h3 id="InnoDB一颗高度为3的B-树可以存放多少行数据？"><a href="#InnoDB一颗高度为3的B-树可以存放多少行数据？" class="headerlink" title="InnoDB一颗高度为3的B+树可以存放多少行数据？"></a><em><strong><code>InnoDB</code>一颗高度为3的B+树可以存放多少行数据？</strong></em></h3><p><code>InnoDB</code>的一页大小为16k，若一行数据的大小为1k，那么可以存储16行数据</p>
<p>若主键ID为<code>bigint</code>型，8字节，指针为6字节，总大小为14字节，那么一页可以存储1170个指针</p>
<p>所以数据量大约为1170  * 1170 *  16&#x3D; 大约两千万</p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="按锁的属性分"><a href="#按锁的属性分" class="headerlink" title="按锁的属性分"></a>按锁的属性分</h2><p>共享锁：即读锁</p>
<p>排他锁：即写锁</p>
<h3 id="按锁的粒度分"><a href="#按锁的粒度分" class="headerlink" title="按锁的粒度分"></a>按锁的粒度分</h3><p>行级锁：锁住一行或者多行记录</p>
<p>表级锁：给整个表加锁</p>
<p>页级锁：介于行级锁和表锁的一种锁，一次锁定相邻的一组记录</p>
<p>记录锁：行级锁的一种，锁住一条记录，避免数据在查询时被修改的不可重复读问题</p>
<p>间隙锁：行级锁的一种，只出现在Repeatable read的事务中，解决了幻读的问题</p>
<p>临键锁：<code>InnoDB</code>的行锁默认算法，就是记录锁和间隙锁的结合版，会锁住查询的记录，同时也会锁住范围内的所有间隙空间</p>
<h3 id="按锁的状态分"><a href="#按锁的状态分" class="headerlink" title="按锁的状态分"></a>按锁的状态分</h3><p>意向共享锁</p>
<p>意向排他锁</p>
<h1 id="MySQL的主从同步"><a href="#MySQL的主从同步" class="headerlink" title="MySQL的主从同步"></a>MySQL的主从同步</h1><p>MySQL内建的复制功能是构建大型，高性能应用程序的基础。</p>
<p>将MySQL的数据分布到多个系统上去，这种分布的机制，是通过将MySQL的某一台主机的数据复制到其它主机（slave）上，并重新执行一遍来实现。</p>
<p>复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。</p>
<p>主服务器将更新写入二进制日志文件，并维护文件的一个索引以跟踪日志循坏，这些日志可以记录发送到从服务器的更新。</p>
<p>当一个从服务器连接主服务器时，它通知主服务器从服务器在日志中读取的最后一次成功更新的位置。从服务器接收从那时起发生的任何更新，然后封锁并等待主服务器通知的更新。</p>
<h2 id="MySQL支持哪些复制"><a href="#MySQL支持哪些复制" class="headerlink" title="MySQL支持哪些复制"></a>MySQL支持哪些复制</h2><ol>
<li>基于语句的复制：在主服务器上执行的sql语句，在从服务器上执行同样的语句。MySQL默认采用基于语句的复制，效率比较高。一旦发现没法精确复制时，会自动选着基于行的复制。</li>
<li>基于行的复制：把改变的内容复制过去，而不是把命令在从服务器上执行一遍。从MySQL 5.0开始支持</li>
<li>混合类型的复制：默认采用基于语句的复制，一旦发现基于语句的无法精确复制时，就会采用基于行的复制</li>
</ol>
<h2 id="为什么需要主从同步"><a href="#为什么需要主从同步" class="headerlink" title="为什么需要主从同步"></a>为什么需要主从同步</h2><ol>
<li>若出现锁表不能读的情况，此时可以使用主从复制，让主库负责写，从库负责读，这样就不影响业务的正常运行</li>
<li>当IO频率越来越大时，业务量越来越大时，单机已无法满足，此时多库的处理可以提高IO的性能</li>
</ol>
<h1 id="MySQL的乐观锁"><a href="#MySQL的乐观锁" class="headerlink" title="MySQL的乐观锁"></a>MySQL的乐观锁</h1><p>乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果冲突，则返回给用户异常信息，让用户决定如何去做。乐观锁适用于读多写少的场景，这样可以提高程序的吞吐量。</p>
<p>乐观锁采取了更加宽松的加锁机制。也是为了避免数据库幻读、业务处理时间过长等原因引起数据处理错误的一种机制</p>
<p>乐观锁不会刻意使用数据库本身的锁机制，而是依据数据本身来保证数据的正确性。乐观锁的实现：</p>
<p><strong>CAS+版本号控制：</strong>一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会 +1。当线程 A 要更新数据时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值与当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。</p>
<h1 id="MySQL的行级锁"><a href="#MySQL的行级锁" class="headerlink" title="MySQL的行级锁"></a>MySQL的行级锁</h1><h2 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h2><p>记录锁是封锁这一条记录，阻止其他事务插入，更新，删除这一条记录</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> `test` <span class="hljs-keyword">WHERE</span> `id`<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br></code></pre></td></tr></table></figure>

<h2 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h2><p>间隙锁是封锁索引记录中的间隙，或者第一条索引记录之前或者之后的范围的数据，间隙锁面向的是范围，所以是<strong>左开右开区间</strong></p>
<p>产生条件：<strong>RR隔离级别</strong></p>
<p>对唯一索引进行操作：</p>
<ol>
<li>对于指定查询某一条记录的加锁语句，<strong>如果该记录不存在，会产生记录锁和间隙锁，如果记录存在，则只会产生记录锁</strong>，如：<code>WHERE id = 5 FOR UPDATE;</code></li>
<li>对于查找某一范围内的查询语句，会产生间隙锁，如：<code>WHERE id BETWEEN 5 AND 7 FOR UPDATE;</code></li>
</ol>
<p>对普通索引进行操作：</p>
<ol>
<li>在普通索引列上，<strong>不管是何种查询，只要加锁，都会产生间隙锁，这跟唯一索引不一样；</strong></li>
<li>在普通索引跟唯一索引中，数据间隙的分析，数据行是优先根据普通索引排序，再根据唯一索引排序。</li>
</ol>
<p>例如表中有6条记录，其中索引d分别为0，5，10，15，20，25</p>
<p>执行 <code>select * from t where d=5 for update</code>，就不止是给数据库中已 有的6个记录加上了行锁，还同时加了 7 个间隙锁。、</p>
<p>比如（0，5）区间内被加上间隙锁，这个区间内无法插入新记录，一定程度上避免了幻读，<strong>但是并没有完全解决幻读</strong>。</p>
<p><strong>在RC级别下，间隙锁会失效</strong></p>
<h2 id="临键锁"><a href="#临键锁" class="headerlink" title="临键锁"></a>临键锁</h2><p><strong>间隙锁和行锁合称临键锁（ next-key lock）</strong>，每个 next-key lock 是<strong>前开后闭区间</strong>，同样只在RR级别下有效</p>
<ol>
<li>若对存在的记录加锁，则会锁住前后两个区间的内容</li>
<li>若对不存在的记录加锁，则会锁住该记录所在区间的内容</li>
</ol>
<p><img src="/../img/next-key.png" srcset="/img/loading.gif" lazyload alt="next-key"></p>
<h2 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h2><p>一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁。</p>
<p>如果有的话，插入操作就会发生<strong>阻塞</strong>，直到拥有间隙锁的那个事务提交为止（释放间隙锁），在此期间会生成一个<strong>插入意向锁</strong>，表明有事务想在某个区间插入新记录，但是现在处于等待排队阶段。</p>
<p><em><strong>MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁</strong></em></p>
<p>插入意向锁是一种特殊的间隙锁，它锁住了一个点，这个点也相当于一个区间</p>
<h1 id="MySQL的行级加锁机制"><a href="#MySQL的行级加锁机制" class="headerlink" title="MySQL的行级加锁机制"></a>MySQL的行级加锁机制</h1><p>InnoDB 引擎支持行级锁，而 MyISAM 引擎并不支持行级锁</p>
<h2 id="唯一索引等值查询"><a href="#唯一索引等值查询" class="headerlink" title="唯一索引等值查询"></a>唯一索引等值查询</h2><p><strong>走主键索引查询单条记录，比如 where id &#x3D; 1</strong></p>
<p>若记录存在：由于主键具有唯一性，所以<strong>其他事务插入 id &#x3D; 1 的时候，会因为主键冲突，导致无法插入 id &#x3D; 1 的新记录，也无法删除该记录</strong>。这样事务 A 在多次查询 id &#x3D; 1 的记录的时候，不会出现前后两次查询的结果集不同，也就避免了幻读的问题。所以此时临键锁会退化成记录锁。</p>
<p>若记录不存在：若id&#x3D;1的记录不存在，我们只需保证多次查询id&#x3D;1的记录都不会存在，所以临键锁就会退化为间隙锁。<strong>锁是加在索引上的，而这个场景下查询的记录是不存在的，自然就没办法锁住这条不存在的记录，只能锁住区间。</strong></p>
<h2 id="唯一索引范围查询"><a href="#唯一索引范围查询" class="headerlink" title="唯一索引范围查询"></a>唯一索引范围查询</h2><p>若为大于查询：例如where id &gt; 15，此时查询的第一条数据是id&#x3D;20，从该条记录开始往后查询，直到最后一条记录。此时数据库为了避免幻读会加两个临键锁： (15, 20] 的 next-key 锁和(20, +∞] 的 next-key 锁。保证了不会出现<strong>小于20大于15的新纪录</strong>和<strong>大于符合条件的最大记录（这里是20）的新记录</strong></p>
<p>若为大于等于查询：若这里有id&#x3D;15的记录，那么就相当于等值查询，会加一个15的记录锁。临键锁的加锁方式和大于的情况一样</p>
<h2 id="非唯一索引等值查询"><a href="#非唯一索引等值查询" class="headerlink" title="非唯一索引等值查询"></a>非唯一索引等值查询</h2><p>当我们用非唯一索引进行等值查询的时候，<strong>因为存在两个索引，一个是主键索引，一个是非唯一索引（二级索引），所以在加锁时，这两个索引都会被同时加锁，但是对主键索引加锁的时候，只有满足查询条件的记录才会对它们的主键索引加锁</strong>。</p>
<p>记录不存在的情况：二级索引会被加上间隙锁，避免幻读。但是即使加上了间隙锁，由于是位于二级索引，还是会出现记录插入成功的特例，<strong>因为二级索引树是按照二级索引值按顺序存放的，在相同的二级索引值情况下， 再按主键 id 的顺序存放。</strong>即使二级索引值位于间隙锁区间内，但主键值没有，还是可以插入成功的</p>
<p>记录存在的情况：<strong>由于不是唯一索引，所以肯定存在值相同的记录</strong>，此时数据库会对主键索引和二级索引都加锁，对于主键索引，由于主键的唯一性，事务会对其加上记录锁。对于二级索引，会被加上临键锁和间隙锁，以保证该条记录无法被更改，以及附近范围内无法插入新值。</p>
<h2 id="非唯一索引范围查询"><a href="#非唯一索引范围查询" class="headerlink" title="非唯一索引范围查询"></a>非唯一索引范围查询</h2><p>非唯一索引和主键索引的范围查询的加锁也有所不同，<strong>非唯一索引范围查询，索引的 next-key lock 不会有退化为间隙锁和记录锁的情况</strong>，二级索引记录加锁都是加 next-key 锁</p>
<p>所以当对于二级索引的范围查询，事务会对主键索引加记录锁，对二级索引的附近区间全部加上临键锁</p>
<h2 id="没有加索引的查询"><a href="#没有加索引的查询" class="headerlink" title="没有加索引的查询"></a>没有加索引的查询</h2><p>如果锁定读查询语句，没<strong>有使用索引列作为查询条件</strong>，或者查询语句没有走索引查询，<strong>导致扫描是全表扫描</strong>。那么，每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表，这时如果其他事务对该表进行增、删、改操作的时候，都会被阻塞。</p>
<p>或者update 和 delete 语句如果查询条件<strong>不加索引</strong>，那么由于扫描的方式也是全表扫描，也会锁住整张表。</p>
<p>因此，<strong>在执行 update、delete、select … for update 等具有加锁性质的语句，一定要检查语句是否走了索引</strong>，否则若锁住整张表，会造成很严重的性能问题</p>
<h1 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h1><p>Multi-Version Concurrency Control多版本并发控制，实现对数据库的并发访问，实现读写冲突不加锁，非阻塞并发读。</p>
<p>数据库的并发有三种场景</p>
<ol>
<li>读读：不存在任何问题，不需要并发控制</li>
<li>读写：有线程安全问题，可能会造成脏读，幻读，不可重复读等问题</li>
<li>写写：有线程安全问题，可能存在更新丢失的问题</li>
</ol>
<p>MVCC的实现原理就是为事务分配单项增长的时间戳，为每个修改保存一个版本，版本与时间戳相关联，解决了脏读，幻读，不可重复读的问题，但是不能解决更新丢失的问题，可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低</p>
<h3 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h3><p>也叫锁定读Locking Read，读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁，比如update 、delete 、insert</p>
<h3 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h3><p>也叫普通读Consistent Read，就是单纯的select语句，但不包括for update，就是不加锁的非阻塞读，前提是不使用serializable的隔离级别，实现原理即MVCC</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h3><p>每行记录除了自定义的字段外，还有数据库隐式定义的字段</p>
<p>DB_TRX_ID<br>6字节，最近修改事务的ID，即创建这条记录或者最后一次修改这条记录的事务ID</p>
<p>DB_ROLL_PTR</p>
<p>7字节，回滚指针，指向这条记录的上一个版本，用于配合undolog</p>
<p>DB_ROW_ID</p>
<p>6字节，隐藏的主键，如果数据表没有主键，innoDB就会自动生成一个row_id</p>
<h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>即回滚日志，即进行插入，更新，删除操作后生成的记录链</p>
<p>当进行insert时，产生的undo log只在事务回滚的时候需要，可以在事务提交后被丢弃</p>
<p>当进行update和delete操作时，undo log不仅在事务回滚时需要，在快照读时也需要，所以必须保留，只有在回滚或者快照读不涉及该日志时，undo log才会被purge线程清除（若delete_bit为true，且DB_TRX_ID相对于purge线程的read view可见，那么这条记录就一定可以被清除）</p>
<p><img src="/../img/undolog.png" srcset="/img/loading.gif" lazyload alt="undolog"></p>
<p>由上图可知，不同事物或者相同事物对同一条记录的修改，就会导致该记录的undolog生成一条记录版本的线性链，链首就是最新的旧记录，链尾就是最早的旧记录</p>
<h3 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h3><p>Read View是实现repeatable read的基础，当事务进行快照读的时候会产生一个读视图，用来对当前事务的可见性进行判断，也就是说，事务会将生成的Read View作为条件来判断当前事务能够看见哪个版本的数据，有可能读到最新的数据，也有可能读到undolog里面的某个版本的数据。</p>
<h4 id="Read-View的可见性算法"><a href="#Read-View的可见性算法" class="headerlink" title="Read View的可见性算法"></a>Read View的可见性算法</h4><p>Read View的三个全局属性：</p>
<ol>
<li>trx_list：事务列表，即视图生成时刻系统正活跃未提交的事务ID</li>
<li>up_limit_id：记录事务列表中ID最小的ID</li>
<li>low_limit_id：视图生成时刻系统尚未分配的下一个事务（例如事务123正在活跃，事务4已提交，此时下一个事务ID就是5）</li>
</ol>
<p>具体的算法如下</p>
<ol>
<li>取出当前最新记录的DB_TRX_ID，即当前事务ID</li>
<li>比较DB_TRX_ID&lt;up_limit_id，如果小于则说明当前事务能看见DB_TRX_ID所在的记录，如果大于等于就进入下一个判断</li>
<li>判断DB_TRX_ID&gt;&#x3D;low_limit_id，如果大于等于，代表DB_TRX_ID所在的记录在readView<strong>生成后才出现</strong>，对于当前事务肯定不可见，如果小于，进入下一个判断</li>
<li>判断DB_TRX_ID是否在活跃事务列表中，如果在，说明在视图生成时刻，该事务还没有提交，当前事务无法看见。若不在，说明以及提交，修改的结果可以看见（除自己以外的活跃trx_id都不可见）</li>
</ol>
<h4 id="RC，RR级别下的视图"><a href="#RC，RR级别下的视图" class="headerlink" title="RC，RR级别下的视图"></a>RC，RR级别下的视图</h4><p>在RR级别下某个事务对记录的第一次快照读会创建一个视图，此后在进行快照读时都会使用同一个视图，所以无论是否有其他事务对记录进行了修改，使用的都是这个视图，修改是不可见的，所以实现了可重复读的级别</p>
<p>在RC级别下，每次快照读都会生成一个新的视图，所以在RC级别下总是可以看见其他事务的提交</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>MVCC其实就是在事务进行并发读写时提供一个快照，事务只能看见符合可见性的版本链内的记录，从而实现了并发读写的隔离性。</p>
<h1 id="MVCC解决幻读了嘛"><a href="#MVCC解决幻读了嘛" class="headerlink" title="MVCC解决幻读了嘛"></a><em><strong>MVCC解决幻读了嘛</strong></em></h1><blockquote>
<p>幻读【前后多次读取，数据总量不一致】</p>
</blockquote>
<ol>
<li>快照读：快照读就是普通的select语句，通过MVCC的方式解决了幻读，MVCC为保证了事务执行过程中看到的数据是一致的，使用ReadView和可见性算法可以实现即使有新记录插入，当前事务也是看不到的。</li>
<li>当前读：除了select语句外的所有操作都是当前读，当前读使用<strong>临键锁来避免幻读</strong>，当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞。</li>
</ol>
<p>但是在RR级别下，仍然有一些情况会出现幻读</p>
<h3 id="第一种情况：同一事务，使用update导致快照读生成的ReadView被更改"><a href="#第一种情况：同一事务，使用update导致快照读生成的ReadView被更改" class="headerlink" title="第一种情况：同一事务，使用update导致快照读生成的ReadView被更改"></a>第一种情况：同一事务，使用update导致快照读生成的ReadView被更改</h3><ol>
<li>若在事务开始执行之前，表中是没有id&#x3D;5的这条记录的，所以查询不到</li>
<li>然后事务 B 插入一条 id &#x3D; 5 的记录，并且提交了事务</li>
<li>此时，<strong>事务 A 更新 id &#x3D; 5 这条记录</strong>，<strong>事务 A 看不到 id &#x3D; 5 这条记录，但是他去更新了这条记录</strong>，<strong>然后再次查询 id &#x3D; 5 的记录，事务 A 就能看到事务 B 插入的纪录了，幻读就是发生在这种违和的场景</strong>。</li>
</ol>
<p><img src="/../img/phantom.png" srcset="/img/loading.gif" lazyload alt="phantom"></p>
<p>总结：</p>
<ol>
<li>在可重复读隔离级别下，事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，之后事务 B 向表中新插入了一条 id &#x3D; 5 的记录并提交。</li>
<li>接着，事务 A 对 id &#x3D; 5 这条记录进行了更新操作，在这个时刻，这条新记录的DB_TRX_ID的值就变成了事务 A 的事务 id。</li>
<li>之后事务 A  再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。</li>
</ol>
<p>因为这种特殊现象的存在，所以我们认为 <strong>MySQL Innodb 中的 MVCC 并不能完全避免幻读现象</strong>。</p>
<h3 id="第二种情况：同一事务，先快照读，再当前读导致幻读"><a href="#第二种情况：同一事务，先快照读，再当前读导致幻读" class="headerlink" title="第二种情况：同一事务，先快照读，再当前读导致幻读"></a>第二种情况：同一事务，先快照读，再当前读导致幻读</h3><ol>
<li>T1 时刻：事务 A 先执行快照读语句：<code>select * from t_test where id &gt; 100</code> 得到了 3 条记录。</li>
<li>T2 时刻：事务 B 往插入一个 id&#x3D; 200 的记录并提交；</li>
<li>T3 时刻：事务 A 再执行当前读语句<code>select * from t_test where id &gt; 100 for update</code> 就会得到 4 条记录，此时也发生了幻读现象。</li>
</ol>
<p><strong>要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句</strong>，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。</p>
<p><em><strong>总结：MVCC只能很大程度上避免幻读，但是个别情况下，仍然会发生幻读</strong></em></p>
<h1 id="MySQL调优"><a href="#MySQL调优" class="headerlink" title="MySQL调优"></a>MySQL调优</h1><p>代码优化：</p>
<ol>
<li>少使用select*，指定具体字段</li>
<li>尽量少使用order by排序，而使用联合索引</li>
<li>减少使用Null，有多个null的可以加默认值</li>
<li>where后少使用函数运算</li>
<li>避免超过五个以上的表连接</li>
</ol>
<p>SQL：</p>
<ol>
<li>对于高频筛选字段可以适当建立索引</li>
<li>一个表的索引不超过五个</li>
<li>联合索引，遵守最左匹配原则</li>
</ol>
<h3 id="字段选择优先级（由优至劣）"><a href="#字段选择优先级（由优至劣）" class="headerlink" title="字段选择优先级（由优至劣）"></a>字段选择优先级（由优至劣）</h3><ol>
<li>整型</li>
<li>time：定长运算快</li>
<li>enum：枚举，能约束值，内部由整型存储</li>
<li>char：定长，需要考虑字符集</li>
<li>varchar：不定长，考虑字符集的转换与排序的校对集，速度慢</li>
<li>text：无法使用内存临时表</li>
</ol>
<p><em><strong>定长优先。能选整型就不要选字符串，够用就行，不要富余分配空间，尽量避免使用Null</strong></em></p>
<p>varchar最多可以定义65535个字节</p>
<p><em><strong>如果MySQL出现慢查询，问题在哪？</strong></em></p>
<ol>
<li>索引失效或者无索引</li>
<li>强制查询不存在的字段，此时MySQL会查询整张表</li>
<li>两张表字符集不一样或者编码不一样，但是需要联表查询</li>
<li>多线程查询操作，若线程A查询了很大的一块数据，此时server正在返回A的查询结果并占用了所有的IO，线程B的查询性能就会受限</li>
</ol>
<p><em><strong>如何解决呢？</strong></em></p>
<ol>
<li>一次查询数量过于庞大，拆成多次查询、拼装</li>
<li>分离冷热数据，将大字段或者是查询频率少的数据分出一张新表</li>
<li><code>IN</code>子查询影响查询性能，用<code>JOIN</code>方式代替</li>
<li>用了反向查询（比如<code>NOT IN</code>）或者<code>IN</code>语句参数集太多，可能会导致全表扫描，这种情况尽量拆分语句</li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/MySQL/">#MySQL</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>MySQL</div>
      <div>http://example.com/post/mySQL.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>SamuelZhou</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年10月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/post/Spring.html" title="Spring">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Spring</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/post/netty%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94react%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%AE%80%E8%BF%B0.html" title="netty项目记录">
                        <span class="hidden-mobile">netty项目记录</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
