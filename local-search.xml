<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL的日志和持久性</title>
    <link href="/post/MySQL%E7%9A%84%E6%97%A5%E5%BF%97%E5%92%8C%E6%8C%81%E4%B9%85%E6%80%A7.html"/>
    <url>/post/MySQL%E7%9A%84%E6%97%A5%E5%BF%97%E5%92%8C%E6%8C%81%E4%B9%85%E6%80%A7.html</url>
    
    <content type="html"><![CDATA[<h1 id="日志系统和数据持久性详解"><a href="#日志系统和数据持久性详解" class="headerlink" title="日志系统和数据持久性详解"></a>日志系统和数据持久性详解</h1><p><code>MySQL</code>最常见的日志主要是 <code>binlog</code>（归档日志）和事务日志 <code>redo log</code>（重做日志）和 <code>undo log</code>（回滚日志）</p><p><img src="/../img/MySQLlog.jpg" alt="MySQLlog"></p><h2 id="缓冲池buffer-pool"><a href="#缓冲池buffer-pool" class="headerlink" title="缓冲池buffer pool"></a>缓冲池buffer pool</h2><p>关系型数据库的特点就是需要频繁对磁盘页进行IO，所以有时候也被叫做基于磁盘的数据库，为了改善因为直接读写磁盘导致的 IO 性能问题，引入了缓冲池</p><p>缓冲池是一片内存区域，存储引擎在读取数据时，会先将页读取到缓冲池中。下次读取时，缓冲池是否命中，如果命中，则直接读取，否则从磁盘中读取。</p><p>在修改数据时，如果缓冲池中不存在所需的数据页，则从磁盘读入缓冲池，否则直接对缓冲池中的数据页进行修改。</p><p>这样的好处是，如果我们频繁修改某个数据页，我们可以不用每次都去磁盘读写（注意是读和写）该页，而是直接对缓冲池中的内容修改，在某个时机再把数据刷新到磁盘。这样就会使得对磁盘的多次操作变为一次。即便修改的内容在磁盘中相距较远的不同数据页上，我们也可以将对多次对磁盘的 IO 合并为一次随机 IO。</p><p>但是由于数据页不是立刻写入磁盘，而是在缓冲池停留，所以被修改的数据页会与磁盘上的数据产生短暂的不一致，我们称此时缓冲池中的数据页为脏页 ，将该页刷到磁盘的操作称为刷脏页 。这个刷脏页的过程是异步的，这样就不需要等待磁盘的 IO 操作了。</p><p>因此这些特点极大地提升了 InnoDB的性能，但是也引入了脏页的问题，而日志系统就是为了解决这个问题</p><h1 id="redo-log（重做日志）"><a href="#redo-log（重做日志）" class="headerlink" title="redo log（重做日志）"></a>redo log（重做日志）</h1><p><code>redo log</code>（重做日志）是<code>InnoDB</code>存储引擎独有的，它让<code>MySQL</code>拥有了崩溃恢复能力</p><p>在redo log降临之前，我们面临两难：</p><ol><li>如果我们修改了缓冲池中的数据页就立刻刷脏页，会<strong>产生大量随机 IO</strong>，导致磁盘性能变差（写放大问题）</li><li>但如果我们先写缓冲，一段时间后再刷脏页，如果这时宕机，<strong>脏页就会失效</strong>，就有可能造成数据丢失，无法保证事务的持久性。</li></ol><blockquote><p><em><strong>什么是写放大问题？</strong></em></p><p>对于一次事务来说，写一行数据，对应页中一个记录。但是要实现事务的持久化，不光是要往磁盘中写数据页，还要写 Undo log页。这就是出现了修改一行，需要持久化多个页到磁盘中，因此性能的损失会比较大，这就是写放大问题。</p></blockquote><p>于是救世主降临，即 WAL（Write-Ahead Logging，日志先行） ，让写日志在事务提交前进行写，这里所谓的日志，就是 redo log，保证数据不丢，就是 redo log 的一个重要功能。在事务提交时，不需要绝对保证修改的页持久化到磁盘中，<strong>只需保证日志已经持久化存储到磁盘中即可</strong>。如果出现掉电或者宕机的场景，内存的页虽然丢失，<strong>但是可以通过磁盘的页进行 Redo 重做，恢复更改的内存页。</strong></p><p>在绝大部分情况下，Redo Log 数据比数据页和 Undo log页要小，而且按顺序写入，性能也比写放大后的好。</p><p>redo log 不会记录对整个页的修改，而是大概像这种：</p><p><img src="/../img/redolog.png" alt="redolog"></p><p>记录下对磁盘中某某页某某位置数据的修改结果（这种日志被称为物理日志）</p><p>由此可以看出，<strong>数据库使用 Redo log对数据的操作，速度上接近内存，持久性接近磁盘。</strong></p><p>redo log包含两部分，一个是日志缓冲<code>redo log buffer</code>，另外一个是磁盘日志文件<code>redo log file</code>，大致的运行机制如下图</p><p><img src="/../img/03.png" alt="03"></p><p>缓冲池的好处前面已经写过，所以 redo log 弄了个类似作用的 redo log buffer，在写 redo log 时会先写 redo log buffer，然后会在特定时机刷到磁盘</p><h4 id="刷盘时机"><a href="#刷盘时机" class="headerlink" title="刷盘时机"></a>刷盘时机</h4><p><code>InnoDB</code> 存储引擎为 <code>redo log</code> 的刷盘策略提供了 <code>innodb_flush_log_at_trx_commit</code> 参数，它支持三种策略：</p><ul><li>设置为 0 的时候，表示每次事务提交时不进行刷盘操作，<strong>依靠刷盘线程进行</strong></li><li>设置为 1 的时候，表示<strong>每次事务提交</strong>时都将进行刷盘操作（默认值）</li><li>设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 OS page cache，<strong>依靠刷盘线程进行</strong></li></ul><p><code>innodb_flush_log_at_trx_commit</code> 参数默认为 1 ，也就是说当事务提交时会调用 <code>fsync</code> 对 redo log 进行刷盘</p><p>另外，<code>InnoDB</code> 存储引擎有一个后台线程，<strong>每隔<code>1</code> 秒</strong>，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存（<code>page cache</code>），然后调用 <code>fsync</code> 刷盘，<strong>也就是说，一个没有提交事务的 <code>redo log</code> 记录，也可能会刷盘</strong></p><p><strong>除了后台线程每秒<code>1</code>次的轮询操作，还有一种情况，当 <code>redo log buffer</code> 占用的空间即将达到 <code>innodb_log_buffer_size</code> 一半的时候，后台线程会主动刷盘</strong></p><p><img src="/../img/06.png" alt="06"></p><ul><li><p>为<code>0</code>时，如果<code>MySQL</code>挂了或宕机可能会有<code>1</code>秒数据的丢失</p></li><li><p>为<code>1</code>时， 只要事务提交成功，<code>redo log</code>记录就一定在硬盘里，不会有任何数据丢失。</p><p>如果事务执行期间<code>MySQL</code>挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失</p></li><li><p>为<code>2</code>时， 只要事务提交成功，<code>redo log buffer</code>中的内容只写入文件系统缓存（<code>page cache</code>）。</p><p>如果仅仅只是<code>MySQL</code>挂了不会有任何数据丢失，因为已经写入主机的内存里了，但是宕机可能会有<code>1</code>秒数据的丢失</p></li></ul><h2 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h2><p>redo log也需要持久化，日志的持久化成本更低。redo log持久化到磁盘的redo logfile，日志文件也承担了innoDB数据恢复的职责</p><p>硬盘上存储的 <code>redo log</code> 日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个的<code>redo</code>日志文件大小都是一样的。比如可以配置为一组<code>4</code>个文件，每个文件的大小是 <code>1GB</code>，整个 <code>redo log</code> 日志文件组可以记录<code>4G</code>的内容。</p><p>这个文件组将以<strong>环形数组的形式的聚簇</strong>，从头开始写，写到末尾又回到头循环写，如下图所示</p><p><img src="/../img/10.png" alt="10"></p><p><img src="/../img/redologfile.jpg" alt="redologfile"></p><p>从上图可知，redo logfile是顺序写，对于已经持久化的数据将进行覆盖，redo logfile只会记录未被持久化的数据，这对于数据恢复十分重要。</p><p>两个redo logfile的逻辑指针：</p><ol><li><strong>checkpoint</strong>：指示未刷盘的数据，从这里开始，编号小于checkpoint的空间表示已经被持久化，可以被覆盖</li><li><strong>write position</strong>：表示当前数据写入的位置</li></ol><p>redo logfile是环形结构，如果checkpoint原地不动的话，随着redo log record的不断插入，write position总会追上checkpoint，如果追上了那就没办法再写redo log了，因为checkpoint之后的redo log表示的数据脏页还没有刷盘，是肯定不可以覆盖的。</p><p>解决办法也很简单，催着checkpoint也往前走，去“<strong>吃掉还未刷盘的数据</strong>”，形成一种write position催着checkpoint前进的局面，checkpoint与write position之间的间隔越小，<strong>证明还未刷入磁盘的脏页越少</strong>，服务重启之后recovery所需的时间就越少，反之则越大。</p><p><em><strong>为什么不直接把修改后的数据页直接刷盘？而是要记录redo log?</strong></em></p><p>实际上，数据页大小是<code>16KB</code>，刷盘比较耗时，可能就修改了数据页里的几 <code>Byte</code> 数据，没有必要将整个数据页落盘。</p><p>而且数据页刷盘是随机写，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能很差。</p><p>如果是写 <code>redo log</code>，一行记录可能就占几十 <code>Byte</code>，只包含表空间号、数据页号、磁盘文件偏移量、更新值，再加上是顺序写，所以刷盘速度很快。所以用 <code>redo log</code> 形式记录修改内容，性能会远远超过刷数据页的方式，这也让数据库的并发能力更强</p><h1 id="bin-log（归档日志）"><a href="#bin-log（归档日志）" class="headerlink" title="bin log（归档日志）"></a>bin log（归档日志）</h1><p><code>redo log</code> 它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 <code>InnoDB</code> 存储引擎。</p><p>而 <code>binlog</code> 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于<strong>Server</strong>层。不管用什么存储引擎，只要发生了表数据更新，都会产生 <code>binlog</code> 日志</p><p>bin log的作用：<strong>主从同步</strong>。可以说<code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性</p><p><img src="/../img/01-20220305234724956.png" alt="01-20220305234724956"></p><p><code>binlog</code>会记录所有涉及更新数据的逻辑操作，并且是顺序写</p><h4 id="记录格式"><a href="#记录格式" class="headerlink" title="记录格式"></a>记录格式</h4><p><code>binlog</code> 日志有三种格式，可以通过<code>binlog_format</code>参数指定。</p><ul><li><strong>statement</strong></li><li><strong>row</strong></li><li><strong>mixed</strong></li></ul><p>指定<code>statement</code>，记录的内容是<code>SQL</code>语句原文，比如执行一条<code>update T set update_time=now() where id=1</code>，记录的内容如下</p><p><img src="/../img/02-20220305234738688.png" alt="02-20220305234738688"></p><p>同步数据时，会执行记录的<code>SQL</code>语句，但是有个问题，<code>update_time=now()</code>这里会获取当前系统时间，直接执行会导致与原库的数据不一致。</p><p>为了解决这种问题，我们需要指定为<code>row</code>，记录的内容不再是简单的<code>SQL</code>语句了，还包含操作的具体数据，记录内容如下</p><p><img src="/../img/03-20220305234742460.png" alt="03-20220305234742460"></p><p><code>row</code>格式记录的内容看不到详细信息，要通过<code>mysqlbinlog</code>工具解析出来。</p><p><code>update_time=now()</code>变成了具体的时间<code>update_time=1627112756247</code>，条件后面的@1、@2、@3 都是该行数据第 1 个~3 个字段的原始值（<strong>假设这张表只有 3 个字段</strong>）。</p><p>这样就能保证同步数据的一致性，通常情况下都是指定为<code>row</code>，这样可以为数据库的恢复与同步带来更好的可靠性。</p><p>但是这种格式，需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗<code>IO</code>资源，影响执行速度。</p><p>所以就有了一种折中的方案，指定为<code>mixed</code>，记录的内容是前两者的混合。</p><p><code>MySQL</code>会判断这条<code>SQL</code>语句是否可能引起数据不一致，如果是，就用<code>row</code>格式，否则就用<code>statement</code>格式</p><h2 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h2><p><code>binlog</code>的写入时机也非常简单，事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把<code>binlog cache</code>写到<code>binlog</code>文件中。</p><p>因为一个事务的<code>binlog</code>不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code></p><p>我们可以通过<code>binlog_cache_size</code>参数控制单个线程 bin log cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（<code>Swap</code>）</p><p><img src="/../img/04-20220305234747840.png" alt="04-20220305234747840"></p><ul><li><strong>上图的 write，是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快</strong></li><li><strong>上图的 fsync，才是将数据持久化到磁盘的操作</strong></li></ul><p><code>write</code>和<code>fsync</code>的时机，可以由参数<code>sync_binlog</code>控制，默认是<code>0</code>。</p><ul><li><p>为<code>0</code>的时候，表示每次提交事务都只<code>write</code>，由系统自行判断什么时候执行<code>fsync</code></p></li><li><p>虽然性能得到提升，但是机器宕机，<code>page cache</code>里面的 binlog 会丢失。</p><p>为了安全起见，可以设置为<code>1</code>，表示每次提交事务都会执行<code>fsync</code>，就如同 <strong>redo log 日志刷盘流程</strong> 一样</p></li><li><p>最后还有一种折中方式，可以设置为<code>N(N&gt;1)</code>，表示每次提交事务都<code>write</code>，但累积<code>N</code>个事务后才<code>fsync</code></p></li></ul><h1 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h1><blockquote><p><strong><code>redo log</code>（重做日志）让<code>InnoDB</code>存储引擎拥有了崩溃恢复能力。</strong></p><p><strong><code>binlog</code>（归档日志）保证了<code>MySQL</code>集群架构的数据一致性</strong></p><p>虽然它们都属于持久化的保证，但是侧重点不同。</p></blockquote><p>我们如何保证两个日志的一致性？</p><h4 id="如果先写-binlog-再写-redolog"><a href="#如果先写-binlog-再写-redolog" class="headerlink" title="如果先写 binlog 再写 redolog"></a><strong>如果先写 binlog 再写 redolog</strong></h4><p>假设我们要向表中插入一条记录 R，如果是先写 binlog 再写 redolog，那么假设 binlog 写完后崩溃了，此时 redolog 还没写。</p><p>那么数据恢复的时候就会出问题：binlog中已经有 R 的记录了，当slave从master同步数据的时候或者我们使用 binlog恢复数据的时候，就会同步到 R 这条记录；但是redolog中没有关于 R 的记录，主机会认为该记录已经被持久化到磁盘，所以崩溃恢复之后，插入 R 记录的这个事务是无效的，但是实际上数据库中没有该行记录，这就造成了数据不一致。</p><h4 id="如果先写-redolog-再写-binlog"><a href="#如果先写-redolog-再写-binlog" class="headerlink" title="如果先写 redolog 再写 binlog"></a><strong>如果先写 redolog 再写 binlog</strong></h4><p>假设我们要向表中插入一条记录 R，如果是先写 redolog 再写 binlog，那么假设 redolog 写完后崩溃了，此时 binlog 还没写。</p><p>那么重启恢复的时候也会出问题：redolog 中已经有 R 的记录了，所以崩溃恢复之后，插入 R 记录的这个事务是有效的，通过该记录将数据恢复到数据库中，master数据库是没有问题的。但是 binlog 中还没有关于R的记录，所以当slave从master同步数据的时候或者我们使用 binlog 恢复数据的时候，就不会同步到 R 这条记录，这就造成了数据不一致。</p><p>为了解决两份日志之间的一致性问题，<code>InnoDB</code>存储引擎使用<strong>两阶段提交</strong>方案</p><p>原理很简单，将<code>redo log</code>的写入拆成了两个步骤**<code>prepare</code>和<code>commit</code>**</p><p>事务提交时就会被拆分成三个步骤：</p><ol><li>写入redo log，进入prepare状态（一阶段提交）</li><li>写binlog</li><li>修改redo log，状态变为 commit（二阶段提交）</li></ol><p><img src="/../img/06-20220305234907651.png" alt="06-20220305234907651"></p><h4 id="一阶段提交崩溃"><a href="#一阶段提交崩溃" class="headerlink" title="一阶段提交崩溃"></a>一阶段提交崩溃</h4><p>即redo log prepare状态的时候崩溃了，此时由于 bin log还没写，所以崩溃恢复的时候，这个事务会回滚，也不会传到slave</p><h4 id="写完-bin-log崩溃"><a href="#写完-bin-log崩溃" class="headerlink" title="写完 bin log崩溃"></a>写完 bin log崩溃</h4><p>redo log中的日志是不完整的，处于prepare状态，还没有提交，那么恢复的时候，首先检查bin log中的事务是否存在并且完整，如果存在且完整，则直接提交事务，如果不存在或者不完整，则回滚事务。</p><h4 id="redo-log-commit崩溃"><a href="#redo-log-commit崩溃" class="headerlink" title="redo log commit崩溃"></a>redo log commit崩溃</h4><p>此时bin log已经写入完成，能通过事务<code>id</code>找到对应的<code>binlog</code>日志，所以<code>MySQL</code>认为是完整的，就会提交事务恢复数据，所以直接提交事务即可</p><h3 id="redo-log和bin-log有什么区别？"><a href="#redo-log和bin-log有什么区别？" class="headerlink" title="redo log和bin log有什么区别？"></a><em><strong>redo log和bin log有什么区别？</strong></em></h3><ol><li>层次不同：bin log是在存储引擎的上层产生的，无论是怎么样的存储引擎，对数据库的修改都会产生二进制日志。而redo log是在存储引擎层产生的，innoDB独占，只记录该存储引擎对表的修改，产生时间晚于bin log</li><li>记录内容的不同：MySQL的bin log是逻辑日志，其记录是对应的SQL语句，记录顺序与提交顺序有关。而innoDB存储引擎层面的redo log日志是物理日志，redo log记录的是物理页的修改情况，如空间号、数据页号、磁盘文件偏移量。</li><li>记录时机不同：bin log只在每次事务提交的时候一次性写入缓存中的日志文件。而redo log保证在发出事务提交指令时，先向缓存中的redo log写入日志，写入完成后才执行提交动作，两者通过二阶段提交来保证一致性。</li><li>binlog 文件写满后，会自动切换到下一个日志文件继续写，而不会覆盖以前的日志，这个也区别于 redo log，redo log 是循环写入的，即后面写入的可能会覆盖前面写入的。</li></ol><h3 id="有-bin-log为什么还要redo-log？"><a href="#有-bin-log为什么还要redo-log？" class="headerlink" title="有 bin log为什么还要redo log？"></a><em>有 bin log为什么还要redo log？</em></h3><ol><li>bin log 不知道数据库究竟是<strong>在哪一时刻丢失了哪部分数据</strong>，只能从备份点开始重放bin log 记录来恢复数据，非常耗时</li><li>bin log 恢复是需要我们手动执行的，而 redo log 可以在服务器重启后自动恢复数据。</li><li>WAL + 异步刷脏页有效提升了磁盘的 IO 效率。</li></ol><h3 id="有-redo-log为什么还要bin-log？"><a href="#有-redo-log为什么还要bin-log？" class="headerlink" title="有 redo log为什么还要bin log？"></a><em>有 redo log为什么还要bin log？</em></h3><ol><li>bin log 是Server层的功能，redo log 是innoDB的功能。redo log 帮助 InnoDB 实现了性能提升、自动恢复。但其他存储引擎是无法使用 redo log 的。</li><li>我们也可以关闭 bin log，但大多数情况下我们都会开启，因为开启的好处更多。比如，使用bin log 进行主从复制，以及可以通过 bin log 进行数据库的增量备份和恢复。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>MySQL InnoDB 引擎使用redo log和bin log保证事务的<strong>持久性</strong>，使用 undo log 来保证事务的<strong>原子性</strong>。</p><p>MySQL数据库的<strong>数据备份、主备、主主、主从</strong>都离不开bin log，需要依靠bin log来同步数据，保证数据一致性</p><h1 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h1><p>我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，在 MySQL 中，恢复机制是通过 <strong>回滚日志（undo log）</strong> 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。</p><p>如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p><p>undo log就是一个记录该条记录的旧版本内容的一条记录链，链表头就是最新的旧记录，链表尾部就是最旧的旧纪录</p><p>另外，<code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，<code>InnoDB</code> 通过数据行的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 根据可见性算法来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改</p><h1 id="MySQL的数据恢复"><a href="#MySQL的数据恢复" class="headerlink" title="MySQL的数据恢复"></a>MySQL的数据恢复</h1><p>MySQL 崩溃也是一次关闭，只是比正常关闭急了一些</p><p>正常关闭时，MySQL 会做一系列收尾工作，例如：清理日志、合并 change buffer缓冲区等操作。</p><blockquote><p>具体会进行哪些收尾工作，取决于系统变量 innodb_fast_shutdown 的配置。</p></blockquote><p>崩溃直接就是戛然而止，直接不干了，还没来得及进行的那些收尾工作就只能等待下次启动的时候再干了，这就是数据恢复</p><h3 id="两次写"><a href="#两次写" class="headerlink" title="两次写"></a>两次写</h3><p>MySQL 一旦崩溃，Redo log就要出马了，使用Redo log把还没来得及刷盘的脏页恢复到崩溃之前那一刻的状态。</p><p>虽然 Redo 日志能够用来恢复数据页，但这是有前提条件的：<strong>数据页必须完好无损的状态。</strong>如果数据页刚写了一半，MySQL 就戛然而止，这个数据页就损坏了，面对这种情况，Redo log也没办法了</p><p>Redo log要输了吗？那显然是不会的，这就该轮到两次写上场了。</p><p>两次写的官方名字是 double write，它包含<strong>内存缓冲区和dblwr文件两个部分</strong>，InnoDB脏页刷盘前，都会先把脏页写入内存缓冲区，再写入dblwr文件，成功之后才会刷盘，两次写会降低性能，所以选择性地打开</p><p>我们会遇到两种情况：</p><ol><li>如果脏页写入内存缓冲区和 dblwr文件的程中，MySQL 崩溃了，表空间中对应的数据页还是完整的，下次启动时，不需要用两次写页面修复这个数据页。</li><li><strong>如果脏页刷盘时，MySQL 崩溃了，表空间对应的数据页损坏了，下次启动时，使用Redo log恢复数据时，需要用两次写页面修复这个数据页。</strong></li></ol><p><strong>总之，double write可以保证dblwr文件和本地数据文件中总有一份干净的内容。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ants——Goroutine Pool阅读笔记</title>
    <link href="/post/ants%E2%80%94%E2%80%94Goroutine-Pool%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.html"/>
    <url>/post/ants%E2%80%94%E2%80%94Goroutine-Pool%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.html</url>
    
    <content type="html"><![CDATA[<p>go语言是一门潜力无限的语言，自带Goroutine这一“大杀器”，从出生开始就拥有了其他语言无法比拟的高并发性能</p><p>Scheduler十分厉害，Goroutine也很轻量级，但是如果是某些极高并发请求的情况，比如百万级请求，调度和GC就会出现问题</p><p>如果实现一个类似线程池的协程池来实现资源复用，也许就能更高效地执行任务</p><p>ants就是基于go语言实现的协程池工具包，本文将以一个JAVA开发者的角度，阅读源码并写下我的思考</p><p>我将一边完善本文，一边深入探索go语言</p><h1 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h1><p>ants中使用的锁，是基于CAS机制和指数回避算法实现的一种锁。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> spinLock <span class="hljs-type">uint32</span><br><span class="hljs-keyword">const</span> maxBackoff = <span class="hljs-number">16</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sl *spinLock)</span></span> Lock() &#123;<br>backoff := <span class="hljs-number">1</span><br><span class="hljs-comment">//尝试抢锁，如果本次没有抢到锁，使用指数回避算法来让自己在之后的某个时间段再随机抢锁，一直自旋直到抢到锁</span><br>    <span class="hljs-comment">//拿锁，CAS将标志位设为1</span><br><span class="hljs-keyword">for</span> !atomic.CompareAndSwapUint32((*<span class="hljs-type">uint32</span>)(sl), <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) &#123;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; backoff; i++ &#123;<br>            <span class="hljs-comment">//runtime.Gosched() 会让当前goroutine让出CPU，好让其他的goroutine获得执行的机会。</span><br>            <span class="hljs-comment">//当一个goroutine发生阻塞，Go会自动地把与该goroutine处于同一系统线程的其他goroutines转移到另一个系统线程上去，以使这些goroutines不阻塞</span><br>runtime.Gosched()<br>&#125;<br>        <span class="hljs-comment">//指数退避算法以指数方式重试请求（不断增加各次重试之间的等待时间，直到达到最大退避时间）</span><br><span class="hljs-keyword">if</span> backoff &lt; maxBackoff &#123;<br>backoff &lt;&lt;= <span class="hljs-number">1</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//解锁，原子操作将标志位设为0</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sl *spinLock)</span></span> Unlock() &#123;<br>atomic.StoreUint32((*<span class="hljs-type">uint32</span>)(sl), <span class="hljs-number">0</span>)<br>&#125;<br><span class="hljs-comment">// NewSpinLock instantiates a spin-lock.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewSpinLock</span><span class="hljs-params">()</span></span> sync.Locker &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span>(spinLock)<br>&#125;<br></code></pre></td></tr></table></figure><p>协程池中的同步锁原理很简单，就是暴力地使用CAS修改锁的标志位，如果未修改成功，便尝试重新拿锁，每次重新拿锁之前需要进行等待</p><p>而等待时间是以指数正增长，超过阈值便停止</p><p>如何理解下面这段代码？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; backoff; i++ &#123;<br>runtime.Gosched()<br>&#125;<br></code></pre></td></tr></table></figure><p>runtime ，即进程权限调度包，可以直接操纵CPU对进程的行为，类似unsafe方法（也许），Gosched()方法就是让当前goroutine让出CPU，好让其他的goroutine获得执行的机会。</p><p>所以这段代码的意思就是，让该协程停止拿锁，<strong>让出此时间片</strong>给其他协程，直到该循环结束</p><p>Go会自动地把与该goroutine处于同一系统线程的其他goroutines转移到另一个系统线程上去，以使这些goroutines不阻塞</p><h1 id="Pool核心代码"><a href="#Pool核心代码" class="headerlink" title="Pool核心代码"></a>Pool核心代码</h1><h2 id="Pool的结构和配置声明"><a href="#Pool的结构和配置声明" class="headerlink" title="Pool的结构和配置声明"></a>Pool的结构和配置声明</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Pool <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">//池容量，表示ants最多能创建的 goroutine数量。如果为负数，表示容量无限制；</span><br>capacity <span class="hljs-type">int32</span><br><span class="hljs-comment">//已经在运行的worker goroutine数量；</span><br>running <span class="hljs-type">int32</span><br><span class="hljs-comment">//记录池子当前的状态，是否已关闭（CLOSED）</span><br>state <span class="hljs-type">int32</span><br><span class="hljs-comment">//阻塞等待的任务数量</span><br>waiting <span class="hljs-type">int32</span><br><span class="hljs-comment">//spinlock锁，用于并发安全的从worker队列中获取空闲worker</span><br>lock sync.Locker<br><span class="hljs-comment">//存放池中所有的worker,workerArray包含可用workers队列和过期workers队列，只会从可用workers队列中取可用worker</span><br>    <span class="hljs-comment">//这个队列是一个接口，有多种实现模式</span><br>workers workerArray<br>    <span class="hljs-comment">//条件原语，pool为阻塞模式时，如果retrieveWorker函数获取不到可用worker并且没有达到池的最大阻塞数量，会一直阻塞直到被唤醒</span><br>cond *sync.Cond<br>    <span class="hljs-comment">//临时对象池 用于在retrieveWorker函数中 加速获取一个可用的worker</span><br>workerCache   sync.Pool<br>    <span class="hljs-comment">//为1表示已经停止清理过期worker,结束运行purgePeriodically</span><br>heartbeatDone <span class="hljs-type">int32</span><br>    <span class="hljs-comment">//用于通知purgePeriodically结束运行</span><br>stopHeartbeat context.CancelFunc<br>    <span class="hljs-comment">//用于配置pool的相关参数</span><br>options       *Options<br>&#125;<br><span class="hljs-keyword">type</span> Options <span class="hljs-keyword">struct</span> &#123;<span class="hljs-comment">//pool的配置, 源码使用了Option写法对配置进行可选初始化</span><br>   ExpiryDuration time.Duration <span class="hljs-comment">//pool清理过期的worker的时间间隔</span><br> <br>   PreAlloc <span class="hljs-type">bool</span> <span class="hljs-comment">//初始化时是否内存预分配</span><br> <br>   MaxBlockingTasks <span class="hljs-type">int</span> <span class="hljs-comment">//pool.Submit被阻塞的最大goroutine数量，0表示没限制</span><br> <br>   Nonblocking <span class="hljs-type">bool</span> <span class="hljs-comment">//Pool.Submit是否阻塞，为false时MaxBlockingTasks参数无效</span><br> <br>   PanicHandler <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-comment">//worker发生panic时 调用此函数，如果为nil panic会继续向外层抛出</span><br> <br>   Logger Logger <span class="hljs-comment">//日志记录器 可自定义，默认官方logger</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="初始化pool"><a href="#初始化pool" class="headerlink" title="初始化pool"></a>初始化pool</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//创建pool的核心代码</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewPool</span><span class="hljs-params">(size <span class="hljs-type">int</span>, options ...Option)</span></span> (*Pool, <span class="hljs-type">error</span>) &#123;<br>   opts := loadOptions(options...)<span class="hljs-comment">//加载配置</span><br> <br>   <span class="hljs-keyword">if</span> size &lt;= <span class="hljs-number">0</span> &#123;<span class="hljs-comment">//如果容量为负数，置为-1，表示为无限池</span><br>      size = <span class="hljs-number">-1</span><br>   &#125;<br> <span class="hljs-comment">//检查清理时间设置是否合法</span><br>   <span class="hljs-keyword">if</span> expiry := opts.ExpiryDuration; expiry &lt; <span class="hljs-number">0</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, ErrInvalidPoolExpiry<br>   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> expiry == <span class="hljs-number">0</span> &#123;<br>      opts.ExpiryDuration = DefaultCleanIntervalTime <span class="hljs-comment">//如果没设置 默认1s清理一次过期worker</span><br>   &#125;<br> <br>   <span class="hljs-keyword">if</span> opts.Logger == <span class="hljs-literal">nil</span> &#123;<br>      opts.Logger = defaultLogger<span class="hljs-comment">//没有设置，就用go官方的日志器</span><br>   &#125;<br> <br>   p := &amp;Pool&#123;<br>      capacity: <span class="hljs-type">int32</span>(size),<br>      lock:     internal.NewSpinLock(),<br>      options:  opts,<br>   &#125;<br>   p.workerCache.New = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<span class="hljs-comment">//临时对象池，retrieveWorker函数会在一些情况下通过其获取可用的worker</span><br>      <span class="hljs-keyword">return</span> &amp;goWorker&#123;<br>         pool: p,<br>         task: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>, workerChanCap),<span class="hljs-comment">//workerChanCap是一个函数，根据GOMAXPROCS数来决定task是无缓冲还是有缓冲</span><br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">if</span> p.options.PreAlloc &#123; <span class="hljs-comment">//如果要内存预分配,就使用队列的方式实现WorkerArray接口，此情况下的workers队列容量最大为size</span><br>      <span class="hljs-keyword">if</span> size == <span class="hljs-number">-1</span> &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, ErrInvalidPreAllocSize<br>          <span class="hljs-comment">//设置为无限大就无序预分配了</span><br>      &#125;<br>      p.workers = newWorkerArray(loopQueueType, size)<span class="hljs-comment">//用预分配内存方式创建的pool不能通过Tune函数动态改变池的容量</span><br>   &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//否则用栈的实现方式(默认,workers队列容量无限制)</span><br>      p.workers = newWorkerArray(stackType, <span class="hljs-number">0</span>)<br>   &#125;<br> <br>   p.cond = sync.NewCond(p.lock)<span class="hljs-comment">//初始化条件原语</span><br> <br>   <span class="hljs-keyword">var</span> ctx context.Context<br>   ctx, p.stopHeartbeat = context.WithCancel(context.Background())<br>   <span class="hljs-keyword">go</span> p.purgePeriodically(ctx)<br>    <span class="hljs-comment">//用额外的协程去启动p.purgePeriodically(ctx)，即清道夫函数，用于定期检查释放池中过期的workers，ctx用于pool控制该goroutine什么时候结束</span><br>   <span class="hljs-keyword">return</span> p, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>初始化pool之前会对参数做一些校验，比如定期清理时间的设定是否合法，是否启用官方的日志。</p><p>初始化pool后，随即创建临时池</p><p>创建后判断是否需要内存预分配，若不需要就使用栈的方式来实现WorkerArray</p><p>最后创建一个额外的goroutine分配给清道夫函数</p><h2 id="清道夫函数"><a href="#清道夫函数" class="headerlink" title="清道夫函数"></a>清道夫函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span></span> purgePeriodically(ctx context.Context) &#123;<br>   heartbeat := time.NewTicker(p.options.ExpiryDuration) <span class="hljs-comment">//定义一个断续器，根据配置的时间定期向通道发送清除信号</span><br>   <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      heartbeat.Stop()<br>      atomic.StoreInt32(&amp;p.heartbeatDone, <span class="hljs-number">1</span>)<br>   &#125;()<br> <br>   <span class="hljs-keyword">for</span> &#123;<br>      <span class="hljs-keyword">select</span> &#123; <br>      <span class="hljs-keyword">case</span> &lt;-heartbeat.C:<span class="hljs-comment">//接收到清除信号后去执行清理任务</span><br>      <span class="hljs-keyword">case</span> &lt;-ctx.Done():<span class="hljs-comment">//又或者ReleaseTimeout函数向该管道发送了信号，停止执行清理任务</span><br>         <span class="hljs-keyword">return</span><br>      &#125;<br>      <span class="hljs-comment">//执行清理任务前 先检查池是否关闭</span><br>      <span class="hljs-keyword">if</span> p.IsClosed() &#123;<br>         <span class="hljs-keyword">break</span><br>      &#125;<br> <br>      p.lock.Lock()<br>      expiredWorkers := p.workers.retrieveExpiry(p.options.ExpiryDuration) <span class="hljs-comment">//获取池中过期的workers，回收时间在time.now()-p.options.ExpiryDuration之前的worker就是过期worker，后面讲worker的这个函数</span><br>      p.lock.Unlock()<br> <br>      <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> expiredWorkers &#123;<br>         expiredWorkers[i].task &lt;- <span class="hljs-literal">nil</span> <span class="hljs-comment">//通知还在运行的过期worker 停止手上的工作</span><br>         expiredWorkers[i] = <span class="hljs-literal">nil</span>       <span class="hljs-comment">//释放过期worker</span><br>      &#125;<br>      <span class="hljs-comment">// 因为有可能所有的worker都被清理了 或者 开发者调用了Tune函数扩大了pool的容量，但仍然有goroutine被p.cond.Wait()阻塞，此时就可唤醒全部goroutine去抢夺worker</span><br>      <span class="hljs-keyword">if</span> p.Running() == <span class="hljs-number">0</span> || (p.Waiting() &gt; <span class="hljs-number">0</span> &amp;&amp; p.Free() &gt; <span class="hljs-number">0</span>) &#123;<br>         p.cond.Broadcast()<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="获取一个可用的worker"><a href="#获取一个可用的worker" class="headerlink" title="获取一个可用的worker"></a>获取一个可用的worker</h2><p>先看worker</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> goWorker <span class="hljs-keyword">struct</span> &#123; <br>    <span class="hljs-comment">//运行任务的实际执行者，它启动一个goroutine来接受任务并执行函数调用。</span><br>   pool *Pool <span class="hljs-comment">//表明这个goWorker是哪个池的</span><br> <br>   task <span class="hljs-keyword">chan</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-comment">//存放该goWorker要执行的所有工作，外部会通过调用pool.Submit方法向chan中发送任务</span><br> <br>   recycleTime time.Time <span class="hljs-comment">//一个pool有一个worker队列，存储所有goWorker，每次取一个goWorker执行task，执行完放回worker队列，会更新goWork的此字段</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span></span> retrieveWorker() (w *goWorker) &#123; <span class="hljs-comment">//获取一个可用的worker</span><br><span class="hljs-comment">//从临时对象池中获取一个新生成的worker</span><br>spawnWorker := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>   w = p.workerCache.Get().(*goWorker)<br>   w.run()<br>&#125;<br>p.lock.Lock()<br>    <br>w = p.workers.detach()<br><span class="hljs-keyword">if</span> w != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">//尝试从队列中获取worker</span><br>   p.lock.Unlock()<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> capacity := p.Cap(); capacity == <span class="hljs-number">-1</span> || capacity &gt; p.Running() &#123; <br>    <span class="hljs-comment">//如果工作队列为空并且池未满，就从临时对象池中获取</span><br>   p.lock.Unlock()<br>   spawnWorker()<br>&#125; <span class="hljs-keyword">else</span> <br>    &#123; <br>   <span class="hljs-keyword">if</span> p.options.Nonblocking &#123; <span class="hljs-comment">//如果池是非阻塞模式，则直接返回nil切片</span><br>      p.lock.Unlock()<br>      <span class="hljs-keyword">return</span><br>   &#125;<br>retry: <span class="hljs-comment">//如果池是阻塞模式，这种情况只能阻塞直到获取一个可用的worker</span><br>   <span class="hljs-keyword">if</span> p.options.MaxBlockingTasks != <span class="hljs-number">0</span> &amp;&amp; p.Waiting() &gt;= p.options.MaxBlockingTasks &#123; <span class="hljs-comment">//如果当前阻塞goroutine数量 &gt;= 设置的最大阻塞数，直接返回</span><br>      p.lock.Unlock()<br>      <span class="hljs-keyword">return</span><br>   &#125;<br>   <span class="hljs-comment">//否则阻塞直到收到通知有可用的worker</span><br>   p.addWaiting(<span class="hljs-number">1</span>)<br>   p.cond.Wait() <br>   p.addWaiting(<span class="hljs-number">-1</span>)<br>    <br>   <span class="hljs-keyword">if</span> p.IsClosed() &#123; <span class="hljs-comment">//被唤醒后如果池已经关闭则直接结束</span><br>      p.lock.Unlock()<br>      <span class="hljs-keyword">return</span><br>   &#125;<br> <br>   <span class="hljs-keyword">var</span> nw <span class="hljs-type">int</span><br>   <span class="hljs-keyword">if</span> nw = p.Running(); nw == <span class="hljs-number">0</span> &#123; <br>      p.lock.Unlock()<br>      spawnWorker() <span class="hljs-comment">//如果是被清道夫唤醒则从临时对象池中获取worker</span><br>      <span class="hljs-keyword">return</span><br>   &#125;<br>   <span class="hljs-keyword">if</span> w = p.workers.detach(); w == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">//如果正常从worker队列中没获取到</span><br>      <span class="hljs-keyword">if</span> nw &lt; p.Cap() &#123; <span class="hljs-comment">//如果当前运行数量小于容量就从临时对象池获取</span><br>         p.lock.Unlock()<br>         spawnWorker()<br>         <span class="hljs-keyword">return</span><br>      &#125;<br>      <span class="hljs-keyword">goto</span> retry <span class="hljs-comment">//否则重试之前操作</span><br>   &#125;<br>   p.lock.Unlock() <span class="hljs-comment">//正常从worker队列中获取到了则返回</span><br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法里有很多条件语句的嵌套，读起来甚是费力，也许是go语言没有括号的原因，JAVA看多了就不习惯</p><p>我们可以捋顺逻辑了：</p><ol><li><p>尝试获取worker：正常获取到则返回，若无空闲worker就从临时池里获取并返回。</p></li><li><p>未获取到worker：说明此时已经无空闲goroutine，执行下面的逻辑</p></li><li><p>若为非阻塞模式，直接返回空值</p></li><li><p>若为阻塞模式，使用死循环等待获取goroutine。这里使用了goto来实现，若当前阻塞协程数量超过阈值，直接退出。若获取不到或者无已经启用的goroutine就从临时池里获取</p></li></ol><p><strong>所以到底啥是临时池？？</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go">workerCache   sync.Pool<br><span class="hljs-comment">//点进SDK sync包下，发现以下代码</span><br><span class="hljs-keyword">type</span> Pool <span class="hljs-keyword">struct</span> &#123;<br>noCopy noCopy<br><br>local     unsafe.Pointer <span class="hljs-comment">// local fixed-size per-P pool, actual type is [P]poolLocal</span><br>localSize <span class="hljs-type">uintptr</span>        <span class="hljs-comment">// size of the local array</span><br><br>victim     unsafe.Pointer <span class="hljs-comment">// local from previous cycle</span><br>victimSize <span class="hljs-type">uintptr</span>        <span class="hljs-comment">// size of victims array</span><br><br><span class="hljs-comment">// New optionally specifies a function to generate</span><br><span class="hljs-comment">// a value when Get would otherwise return nil.</span><br><span class="hljs-comment">// It may not be changed concurrently with calls to Get.</span><br>New <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> any<br>&#125;<br></code></pre></td></tr></table></figure><p>sync.Pool 是 Golang 内置的<strong>对象池</strong>，可用于缓存临时对象，避免因频繁建立临时对象所带来的消耗以及对 GC 造成的压力。</p><p>其中<code>New func() any</code>是一个对象的构造函数，用户使用 <code>Get</code> 来从对象池中获取对象，使用 <code>Put</code> 将对象归还给对象池。整个用法还是比较简单的。</p><p>在ants中，构造函数长这样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">p.workerCache.New = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>       <span class="hljs-comment">//返回一个goWorker</span><br><span class="hljs-keyword">return</span> &amp;goWorker&#123;<br>pool: p,<br>task: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>, workerChanCap),<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以临时池的的作用就是帮我们创建goworker并交给协程池的workerArray管理，承担了一个cache的角色</p><p>利用对象池的特性，实现对象复用</p>]]></content>
    
    
    
    <tags>
      
      <tag>源码学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>netty进阶</title>
    <link href="/post/netty%E8%BF%9B%E9%98%B6.html"/>
    <url>/post/netty%E8%BF%9B%E9%98%B6.html</url>
    
    <content type="html"><![CDATA[<h1 id="MpscQueue"><a href="#MpscQueue" class="headerlink" title="MpscQueue"></a>MpscQueue</h1><p>Mpsc来自JCTools，即JAVA的高并发增强包，主要提供了一些 JDK 缺失的并发数据结构</p><ol><li>Spsc 单生产者单消费者</li><li>Mpsc 多生产者单消费者</li><li>Spmc 单生产者多消费者</li><li>Mpmc 多生产者多消费者</li></ol><p>Mpsc 的全称是 Multi Producer Single Consumer，多生产者单消费者，多个生产者线程通过CAS无锁操作提升性能，单个消费者不需要加锁；</p><p>Mpsc Queue 可以保证多个生产者同时访问队列是线程安全的，而且同一时刻只允许一个消费者从队列中读取数据。</p><p>MpscArrayQueue内部的环形数组容量为 2 的次幂，可以通过位运算快速定位到数组对应下标。</p><p><strong>Netty Reactor 线程中的任务队列 taskQueue 必须满足多个生产者可以同时提交任务，所以 JCTools 提供的 Mpsc Queue 非常适合 Netty Reactor 线程模型</strong></p><h2 id="MpscArrayQueue为例"><a href="#MpscArrayQueue为例" class="headerlink" title="MpscArrayQueue为例"></a><strong>MpscArrayQueue为例</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//继承类的所有变量声明</span><br><span class="hljs-comment">// ConcurrentCircularArrayQueueL0Pad.java</span><br><span class="hljs-type">long</span> p01, p02, p03, p04, p05, p06, p07;<br><span class="hljs-type">long</span> p10, p11, p12, p13, p14, p15, p16, p17;<br><br><span class="hljs-comment">// ConcurrentCircularArrayQueue.java</span><br><span class="hljs-comment">// 计算数组下标的掩码</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> mask;<br><span class="hljs-comment">// 存放队列数据的数组</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> E[] buffer;<br><br><span class="hljs-comment">// MpmcArrayQueueL1Pad.java</span><br><span class="hljs-type">long</span> p00, p01, p02, p03, p04, p05, p06, p07;<br><span class="hljs-type">long</span> p10, p11, p12, p13, p14, p15, p16;<br><br><span class="hljs-comment">// MpmcArrayQueueProducerIndexField.java</span><br><span class="hljs-comment">// 生产者索引</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> producerIndex;<br><br><span class="hljs-comment">// MpscArrayQueueMidPad.java</span><br><span class="hljs-type">long</span> p01, p02, p03, p04, p05, p06, p07;<br><span class="hljs-type">long</span> p10, p11, p12, p13, p14, p15, p16, p17;<br><br><span class="hljs-comment">// MpscArrayQueueProducerLimitField.java</span><br><span class="hljs-comment">// 生产者索引的最大值</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> producerLimit;<br><br><span class="hljs-comment">// MpscArrayQueueL2Pad.java</span><br><span class="hljs-type">long</span> p00, p01, p02, p03, p04, p05, p06, p07;<br><span class="hljs-type">long</span> p10, p11, p12, p13, p14, p15, p16;<br><br><span class="hljs-comment">// MpscArrayQueueConsumerIndexField.java</span><br><span class="hljs-comment">// 消费者索引</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">long</span> consumerIndex;<br><br><span class="hljs-comment">// MpscArrayQueueL3Pad.java</span><br><span class="hljs-type">long</span> p01, p02, p03, p04, p05, p06, p07;<br><span class="hljs-type">long</span> p10, p11, p12, p13, p14, p15, p16, p17;<br></code></pre></td></tr></table></figure><p>在pad类中填充了大量long的数据，其命名没有什么特殊的含义，只是起到填充的作用，这是为了解决<strong>伪共享（false sharing）</strong>问题</p><h2 id="伪共享问题"><a href="#伪共享问题" class="headerlink" title="伪共享问题"></a>伪共享问题</h2><blockquote><p>你的行为似乎有利于共享，但是却徒增消耗</p></blockquote><p>为了平衡CPU与内存的速度差异，常常会设立多层缓存机制，一般是三层，CPU 读取数据时，首先会从 L1 查找，如果未命中则继续查找 L2，如果还未能命中则继续查找 L3，最后还没命中的话只能从内存中查找，读取完成后再将数据逐级放入缓存中。</p><p>此外，多线程之间共享一份数据的时候，需要其中一个线程将数据写回主存（总线嗅探机制保证可见性），其他线程访问主存数据。</p><p>CPU 缓存由若干个缓存行（Cache Line） 组成，<strong>缓存行是 CPU 缓存可操作的最小单位</strong>。</p><p>Cache Line 的大小与 CPU 架构有关，在目前主流的 64 位架构下，Cache Line 的大小通常为 64 Byte。</p><p>而 Java 中一个 long 类型是 8 Byte，所以一个 Cache Line 可以存储 <strong>8 个 long 类型变量</strong>。</p><p>CPU 在加载内存数据时，会将相邻的数据一同读取到 Cache Line 中（一次加载连续的 64 个字节），这样就可以避免 CPU 频繁与内存进行交互了。</p><p>例如：如果访问一个 long 型的单独变量 a，并且还有另外一个 long 型变量 b 紧挨着它，那么当加载 a 时候将免费加载 b</p><p>伪共享就会在此出现：</p><ol><li>假设有 A、B、C、D 四个变量，线程1尝试修改变量A，于是将A和B、C、D一起都加载到了core1的一个 Cache Line；</li><li>此时，线程2读取变量B，也将A、C、D加载到了core2的同一 Cache Line；</li><li>线程1 对变量 A 进行修改，修改完成后将变量A值写回主存，然后 <strong>CPU1 会通知 CPU2 该缓存行已经失效</strong>；</li><li>线程 2 在Core2 中对变量 C 进行修改时，发现 Cache line 已经失效，所以需要重新从主存中读取数据加载到当前 Cache line 中。</li></ol><p><strong>当多个线程同时修改互相独立的变量时，如果这些变量共享同一个缓存行，就会出现写竞争，导致频繁从主存加载数据，影响性能</strong>。</p><img src="../img/JCtool.png" alt="JCtool" style="zoom: 67%;" /><p>常见的解决思路就是：<strong>以空间换时间，让不同线程操作的不相干变量加载到不同缓存行，避免相互影响</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FalseSharingPadding</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">long</span> p1, p2, p3, p4, p5, p6, p7;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">long</span> p9, p10, p11, p12, p13, p14, p15;<br>&#125;<br></code></pre></td></tr></table></figure><p>变量 value 前后分别填充了 7 个 long 类型的变量。</p><p>这样不论在什么情况下，都可以保证在多线程访问 value 变量时，value 与其他不相关的变量处于不同的 Cache Line</p><h2 id="MPSC方法解析"><a href="#MPSC方法解析" class="headerlink" title="MPSC方法解析"></a>MPSC方法解析</h2><h3 id="加入元素"><a href="#加入元素" class="headerlink" title="加入元素"></a>加入元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// MpscArrayQueue.java</span><br><span class="hljs-comment">//生产者加入元素</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(<span class="hljs-keyword">final</span> E e)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == e)<br>    &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">mask</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mask;<br><br>    <span class="hljs-comment">// 获取生产者索引最大限制</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">producerLimit</span> <span class="hljs-operator">=</span> lvProducerLimit();<br>    <span class="hljs-type">long</span> pIndex;<br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        <span class="hljs-comment">// 获取生产者索引</span><br>        pIndex = lvProducerIndex();<br>        <span class="hljs-comment">// 如果生产者索引达到了最大值，防止追尾</span><br>        <span class="hljs-keyword">if</span> (pIndex &gt;= producerLimit)<br>        &#123;<br>            <span class="hljs-comment">// 消费者索引，以volatile的形式获取，保证获取的是最新的值</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">cIndex</span> <span class="hljs-operator">=</span> lvConsumerIndex();<br>            <span class="hljs-comment">// 修改为当前消费者的索引加上数组的大小</span><br>            producerLimit = cIndex + mask + <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 如果依然达到了最大值，则返回false，表示队列满了，再放元素就追尾了</span><br>            <span class="hljs-keyword">if</span> (pIndex &gt;= producerLimit)<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 队列已满</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                soProducerLimit(producerLimit);        <span class="hljs-comment">// 更新 producerLimit</span><br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (!casProducerIndex(pIndex, pIndex + <span class="hljs-number">1</span>));<span class="hljs-comment">// CAS 更新生产者索引，更新成功则退出，说明当前生产者已经占领索引值</span><br>    <span class="hljs-comment">// 计算生产者索引在数组中下标</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> calcCircularRefElementOffset(pIndex, mask);<br>    <span class="hljs-comment">// 向数组中放入数据</span><br>    soRefElement(buffer, offset, e);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取生产者索引最大值和修改生产者索引最大值</span><br>  <span class="hljs-comment">// 读取producerLimit</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">lvProducerLimit</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// producerLimit本身就是volatile修饰的</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.producerLimit;<br>    &#125;<br>    <span class="hljs-comment">// 保存producerLimit</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">soProducerLimit</span><span class="hljs-params">(<span class="hljs-type">long</span> v)</span> &#123;<br>        <span class="hljs-comment">// 这个方法会加StoreStore屏障</span><br>        <span class="hljs-comment">// 会把最新值直接更新到主内存中，但其它线程不会立即可见</span><br>        <span class="hljs-comment">// 其它线程需要使用volatile语义才能读取到最新值</span><br>        <span class="hljs-comment">// 这相当于是一种延时更新的方法，比volatile语义的性能要高一些</span><br>        UnsafeAccess.UNSAFE.putOrderedLong(<span class="hljs-built_in">this</span>, P_LIMIT_OFFSET, v);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取生产者索引，更新生产者索引</span><br> <span class="hljs-comment">// 读取producerIndex</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">lvProducerIndex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// producerIndex本身就用volatile修饰了</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.producerIndex;<br>    &#125;<br> <br>    <span class="hljs-comment">// CAS更新producerIndex</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">casProducerIndex</span><span class="hljs-params">(<span class="hljs-type">long</span> expect, <span class="hljs-type">long</span> newValue)</span> &#123;<br>        <span class="hljs-comment">// CAS更新</span><br>        <span class="hljs-keyword">return</span> UnsafeAccess.UNSAFE.compareAndSwapLong(<span class="hljs-built_in">this</span>, P_INDEX_OFFSET, expect, newValue);<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 读取consumerIndex</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">lvConsumerIndex</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// 以volatile的形式加载consumerIndex</span><br>      <span class="hljs-comment">// 此时会从内存读取最新的值</span><br>      <span class="hljs-keyword">return</span> UnsafeAccess.UNSAFE.getLongVolatile(<span class="hljs-built_in">this</span>, C_INDEX_OFFSET);<br>  &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 修改数组对应偏移量的值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">soElement</span><span class="hljs-params">(E[] buffer, <span class="hljs-type">long</span> offset, E e)</span> &#123;<br>        <span class="hljs-comment">// 比使用下标更新数组元素有两个优势</span><br>        <span class="hljs-comment">// 1. 使用Unsafe操作内存更新更快</span><br>        <span class="hljs-comment">// 2. 使用putOrderedObject会直接更新到主内存，而使用下标不会立马更新到主内存</span><br>        UnsafeAccess.UNSAFE.putOrderedObject(buffer, offset, e);<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/MPSC.png" alt="MPSC"></p><ol><li>初始时，两个线程拿到的 <code>pIndex</code> 都等于producerIndex为0，小于 producerLimit ；</li><li>接着，两个线程都会尝试 CAS 更新 producerIndex + 1 ，必然只有一个线程能更新成功，另一个失败；</li><li>假设 Thread1 CAS 操作成功，那么它拿到的 <code>pIndex</code> 为0，Thread2 失败后就会重新更新 producerIndex ，然后更新成功，拿到 <code>pIndex</code> 为1；</li><li>最后，根据 <code>pIndex</code> 进行位运算，得到数组对应的下标，然后通过 <code>UNSAFE.putOrderedObject()</code> 方法将数据写入到数组中。</li></ol><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//无CAS</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 读取consumerIndex的值</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">cIndex</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lpConsumerIndex();<br>        <span class="hljs-comment">// 计算在数组中的偏移量</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.calcElementOffset(cIndex);<br>        <span class="hljs-comment">// 获取存储元素的数组</span><br>        E[] buffer = <span class="hljs-built_in">this</span>.buffer;<br>        <span class="hljs-comment">// 取元素，通过StoreStore写入队列，通过LoadLoad取出来的元素是最新值</span><br>        <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> UnsafeRefArrayAccess.lvElement(buffer, offset);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == e) &#123;<br>            <span class="hljs-comment">// 元素入队是先更新了producerIndex的值，再把更新元素到数组中</span><br>            <span class="hljs-comment">// 如果在两者之间，进行了消费，则此处是无法获取到元素的</span><br>            <span class="hljs-comment">// 所以需要进入下面的判断</span><br>            <span class="hljs-comment">// 判断consumerIndex是否等于producerIndex</span><br>            <span class="hljs-comment">// 只有两者不相等，才可以再消费元素</span><br>            <span class="hljs-keyword">if</span> (cIndex == <span class="hljs-built_in">this</span>.lvProducerIndex()) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-comment">// 使用死循环来取元素，直到取到为止</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                e = UnsafeRefArrayAccess.lvElement(buffer, offset);<br>            &#125; <span class="hljs-keyword">while</span>(e == <span class="hljs-literal">null</span>);<br>        &#125;<br>        <span class="hljs-comment">// 更新取出的位置元素为null</span><br>        UnsafeRefArrayAccess.spElement(buffer, offset, (Object)<span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">// 修改consumerIndex的索引为新值，使用StoreStore屏障，直接更新到主内存</span><br>        <span class="hljs-built_in">this</span>.soConsumerIndex(cIndex + <span class="hljs-number">1L</span>);<br>        <span class="hljs-comment">// 返回出队的元素</span><br>        <span class="hljs-keyword">return</span> e;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>因为只有一个消费者线程，所以整个 poll() 的过程没有 CAS 操作。</p><p>poll() 方法核心思路是获取消费者索引 consumerIndex，然后根据 consumerIndex 计算得出数组对应的偏移量，然后将数组对应位置的元素取出并返回，最后将 consumerIndex 移动到环形数组下一个位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">lpConsumerIndex</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">// 直接返回消费者索引</span><br>       <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.consumerIndex;<br>   &#125;<br>   <span class="hljs-comment">// 保存消费者索引值</span><br>   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">soConsumerIndex</span><span class="hljs-params">(<span class="hljs-type">long</span> l)</span> &#123;<br>       <span class="hljs-comment">// 这个方法会加StoreStore屏障</span><br>       <span class="hljs-comment">// 会把最新值直接更新到主内存中，但其它线程不会立即可见</span><br>       <span class="hljs-comment">// 其它线程需要使用volatile语义才能读取到最新值</span><br>       <span class="hljs-comment">// 这相当于是一种延时更新的方法，比volatile语义的性能要高一些</span><br>       UnsafeAccess.UNSAFE.putOrderedLong(<span class="hljs-built_in">this</span>, C_INDEX_OFFSET, l);<br>   &#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">spElement</span><span class="hljs-params">(E[] buffer, <span class="hljs-type">long</span> offset, E e)</span> &#123;<br>        <span class="hljs-comment">// 更新buffer在offset处的元素值</span><br>        UnsafeAccess.UNSAFE.putObject(buffer, offset, e);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; E <span class="hljs-title function_">lvElement</span><span class="hljs-params">(E[] buffer, <span class="hljs-type">long</span> offset)</span> &#123;<br>        <span class="hljs-comment">// 获取buffer在offset处的元素值</span><br>        <span class="hljs-keyword">return</span> UnsafeAccess.UNSAFE.getObjectVolatile(buffer, offset);<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//计算偏移量</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">calcElementOffset</span><span class="hljs-params">(<span class="hljs-type">long</span> index, <span class="hljs-type">long</span> mask)</span> &#123;<br>        <span class="hljs-comment">// REF_ARRAY_BASE，基础地址，数组在内存中的地址</span><br>        <span class="hljs-comment">// REF_ELEMENT_SHIFT，可以简单地看作一个元素占用多少字节</span><br>        <span class="hljs-comment">// 64位系统中一个引用对象占用64位，也就是8字节，但是压缩模式下占用4字节</span><br>        <span class="hljs-comment">// index &amp; mask 计算数组下标</span><br>        <span class="hljs-comment">// 比如数组大小为4，mask就为3时，4&amp;3=100&amp;011=0</span><br>        <span class="hljs-keyword">return</span> REF_ARRAY_BASE + ((index &amp; mask) &lt;&lt; REF_ELEMENT_SHIFT);<br>    &#125;<br></code></pre></td></tr></table></figure><ol><li>Unsafe 方法<ol><li>**putOrderedXxx()**，使用 StoreStore 屏障，会把最新值更新到主内存，但不会立即失效其它缓存行中的数据，是一种延时更新机制；</li><li>**putXxxVolatile()**，使用 StoreLoad 屏障，会把最新值更新到主内存，同时会把其它缓存行的数据失效，或者说会刷新其它缓存行的数据；</li><li>**putXxx(obj, offset)**，不使用任何屏障，更新对象对应偏移量的值；</li><li>**getXxxVolatile()**，使用 LoadLoad 屏障，会从主内存获取最新值；</li><li>**getXxx(obj, offset)**，不使用任何屏障，读取对象对应偏移量的值；</li></ol></li></ol><p>总结：</p><h4 id="MPSC实现高并发和高性能使用了哪些方法？"><a href="#MPSC实现高并发和高性能使用了哪些方法？" class="headerlink" title="MPSC实现高并发和高性能使用了哪些方法？"></a><em><strong>MPSC实现高并发和高性能使用了哪些方法？</strong></em></h4><ol><li>LazySet 延迟更新机制：在更新producerLimit，消费者索引，和环形数组元素时使用StoreStore屏障，虽然写操作结果有纳秒级的延迟，但是由于没有立刻读取的操作，所以没有问题，且提升了性能</li><li>使用偏移量来更新数组元素，比下标性能更好</li><li>使用UNSAFE方法来直接操作内存</li><li>使用long型变量填充来避免伪共享问题</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>下一个更大元素</title>
    <link href="/post/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0.html"/>
    <url>/post/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0.html</url>
    
    <content type="html"><![CDATA[<h3 id="556-下一个更大元素-III"><a href="#556-下一个更大元素-III" class="headerlink" title="556.下一个更大元素 III"></a>556.下一个更大元素 III</h3><p>给你一个正整数 <code>n</code> ，请你找出符合条件的最小整数，其由重新排列 <code>n</code> 中存在的每位数字组成，并且其值大于 <code>n</code> 。如果不存在这样的正整数，则返回 <code>-1</code> 。</p><p><strong>注意</strong> ，返回的整数应当是一个 <strong>32 位整数</strong> ，如果存在满足题意的答案，但不是 <strong>32 位整数</strong> ，同样返回 <code>-1</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：n = <span class="hljs-number">12</span>;<br>输出：<span class="hljs-number">21</span>;<br>输入：n = <span class="hljs-number">123</span>;<br>输出：<span class="hljs-number">132</span>;<br></code></pre></td></tr></table></figure><p><strong>思路：从后向前搜索，第一次发现左侧元素小于右侧元素时，交换，并对交换后的元素之后的元素进行反转</strong></p><p><img src="/../img/31.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97.png" alt="31.下一个排列"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextGreaterElement</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">char</span>[] nums = Integer.toString(n).toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length-<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=nums.length-<span class="hljs-number">1</span>;j&gt;i;j--)&#123;<br>                <span class="hljs-keyword">if</span>(nums[j]&gt;nums[i]) &#123;<br>            <span class="hljs-comment">//先交换</span><br>                swap(nums,i,j);<br>                <span class="hljs-comment">//再反转</span><br>                reverse(nums,i+<span class="hljs-number">1</span>,nums.length-<span class="hljs-number">1</span>);<br>                <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Long.parseLong(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(nums));<br>                <span class="hljs-keyword">return</span> res&gt;Integer.MAX_VALUE?-<span class="hljs-number">1</span>:(<span class="hljs-type">int</span>)res;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">char</span>[] nums,<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> start;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> end;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>            swap(nums,left++,right--);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">char</span>[] nums,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> nums[i];<br>        nums[i]=nums[j];<br>        nums[j]=c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>算法技巧，字符串与数字的转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将整数转换为数组</span><br><span class="hljs-type">char</span>[] nums = Integer.toString(n).toCharArray();<br><span class="hljs-comment">//将数组转换为字符串</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(nums);<br><span class="hljs-comment">//将数组转换为整数</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> Integer.parseInt(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(nums));<br><span class="hljs-comment">//将ArrayList转换为字符串</span><br>ArrayList&lt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Object[] o = list.toArray();<span class="hljs-comment">//toArray只会返回一个Object数组</span><br><span class="hljs-type">char</span>[] c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[o.length];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; o.length; i++) &#123;<br>c[i] = o[i].toString().charAt(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(c);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode初见</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java新特性</title>
    <link href="/post/Java%E6%96%B0%E7%89%B9%E6%80%A7.html"/>
    <url>/post/Java%E6%96%B0%E7%89%B9%E6%80%A7.html</url>
    
    <content type="html"><![CDATA[<p>j记录一些与我能看懂的新特性</p><h2 id="JDK9"><a href="#JDK9" class="headerlink" title="JDK9"></a>JDK9</h2><p> String 底层存储结构发生变化使用字节数组</p><h3 id="JDK10"><a href="#JDK10" class="headerlink" title="JDK10"></a>JDK10</h3><p>局部变量的类型推断 var关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//var 没有改变Java的本质，var只是一种简便的写法，</span><br><span class="hljs-comment">//就是说在定义局部变量时，任意什么类型都可以用var定义变量的类型会根据所赋的值来判断</span><br><span class="hljs-type">var</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>list.add(<span class="hljs-string">&quot;hello，world！&quot;</span>);<br>System.out.println(list);<br></code></pre></td></tr></table></figure><p>引入<code>List.copyOf()</code> 来生成不可改变的List</p><h3 id="JDK11"><a href="#JDK11" class="headerlink" title="JDK11"></a>JDK11</h3><p>引入ZGC</p><h3 id="JDK14"><a href="#JDK14" class="headerlink" title="JDK14"></a>JDK14</h3><p>移除CMS</p><h3 id="JDK15"><a href="#JDK15" class="headerlink" title="JDK15"></a>JDK15</h3><p>弃用偏向锁</p><p>正式使用ZGC</p><h3 id="JDK19"><a href="#JDK19" class="headerlink" title="JDK19"></a>JDK19</h3><p>虚拟线程</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java额外知识补充</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周赛笔记11/13/2022</title>
    <link href="/post/%E5%91%A8%E8%B5%9B%E7%AC%94%E8%AE%B011-13-2022.html"/>
    <url>/post/%E5%91%A8%E8%B5%9B%E7%AC%94%E8%AE%B011-13-2022.html</url>
    
    <content type="html"><![CDATA[<h2 id="6234-最小公倍数为-K-的子数组数目"><a href="#6234-最小公倍数为-K-的子数组数目" class="headerlink" title="6234.最小公倍数为 K 的子数组数目"></a>6234.最小公倍数为 K 的子数组数目</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <code>nums</code> 的 <strong>子数组</strong> 中满足 <em>元素最小公倍数为 <code>k</code></em> 的子数组数目。</p><p><strong>子数组</strong> 是数组中一个连续非空的元素序列。<strong>数组的最小公倍数</strong> 是可被所有数组元素整除的最小正整数。</p><p><strong>示例 1 ：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,6,2,7,1]</span>, k = 6<br>输出：4<br>解释：以 6 为最小公倍数的子数组是：<br>- <span class="hljs-comment">[3,6]</span><br>- <span class="hljs-comment">[3,6,2]</span><br>- <span class="hljs-comment">[6,2]</span><br>- <span class="hljs-comment">[6]</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//两个for循环扫描</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarrayLCM</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n=nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]==k) ans++;<br>            <span class="hljs-type">int</span> temp=nums[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-comment">//最小公倍数的传递性，a,b,c的最小公倍数为：a,b的最小公倍数k与c的最小公倍数</span><br>                temp=minMul(temp,nums[j]);<br>                <span class="hljs-keyword">if</span>(temp==k) ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-comment">//可以记住这个算法</span><br>    <span class="hljs-comment">//利用最大公约数求最小公倍数</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">minMul</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> a*b;<br>        <span class="hljs-keyword">return</span> sum/gcd(a,b);<br>    &#125;<br>    <span class="hljs-comment">//辗转相除法求最大公约数</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">return</span> (b==<span class="hljs-number">0</span>)?a:gcd(b,a%b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6235-逐层排序二叉树所需的最少操作数目"><a href="#6235-逐层排序二叉树所需的最少操作数目" class="headerlink" title="6235.逐层排序二叉树所需的最少操作数目"></a>6235.逐层排序二叉树所需的最少操作数目</h2><p>给你一个 <strong>值互不相同</strong> 的二叉树的根节点 <code>root</code> 。</p><p>在一步操作中，你可以选择 <strong>同一层</strong> 上任意两个节点，交换这两个节点的值。</p><p>返回每一层按 <strong>严格递增顺序</strong> 排序所需的最少操作数目。</p><p>节点的 <strong>层数</strong> 是该节点和根节点之间的路径的边数。</p><p><img src="/../img/6235.png" alt="6235"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10]<br>输出：3<br>解释：<br>- 交换<span class="hljs-number"> 4 </span>和<span class="hljs-number"> 3 </span>。第<span class="hljs-number"> 2 </span>层变为 [3,4] 。<br>- 交换<span class="hljs-number"> 7 </span>和<span class="hljs-number"> 5 </span>。第<span class="hljs-number"> 3 </span>层变为 [5,6,8,7] 。<br>- 交换<span class="hljs-number"> 8 </span>和<span class="hljs-number"> 7 </span>。第<span class="hljs-number"> 3 </span>层变为 [5,6,7,8] 。<br>共计用了<span class="hljs-number"> 3 </span>步操作，所以返回<span class="hljs-number"> 3 </span>。<br>可以证明<span class="hljs-number"> 3 </span>是需要的最少操作数目。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//复习二叉树的层序遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//层序遍历，生成每层的数组记录，对数组记录进行操作，记录操作次数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumOperations</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Deque&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        q.add(root);<br>        <span class="hljs-keyword">while</span>(q.peek()!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> q.size();<br>            <span class="hljs-type">int</span>[] record = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;n&gt;<span class="hljs-number">0</span>;n--)&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> q.poll();<br>                record[i++] = node.val;<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) q.add(node.left);<br>                <span class="hljs-keyword">if</span>(node.right !=<span class="hljs-literal">null</span>)q.add(node.right);<br>            &#125;<br>            res+=count(record);<br>        &#125;<br>    <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">//记录将数组变为有序的最小交换次数</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">count</span><span class="hljs-params">(<span class="hljs-type">int</span>[] record)</span>&#123;<br>        <span class="hljs-comment">//比较与排序过的数组的索引差异，不断交换，直到相同</span><br>        HashMap&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-type">int</span>[] sorted = record.clone();<br>        Arrays.sort(sorted);<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;record.length;i++) map.put(sorted[i],i);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;record.length;i++)&#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> map.get(record[i]);<br>                <span class="hljs-keyword">if</span>(index!=i)&#123;<br>                    count++;<br>                    swap(record,index,i);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>        nums[i]=nums[j];<br>        nums[j]=temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode初见</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础知识汇总</title>
    <link href="/post/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB.html"/>
    <url>/post/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB.html</url>
    
    <content type="html"><![CDATA[<h3 id="Object类中有哪些方法"><a href="#Object类中有哪些方法" class="headerlink" title="Object类中有哪些方法"></a><em>Object类中有哪些方法</em></h3><ol><li><strong>equals</strong>()：未被重写前，由&#x3D;&#x3D;来实现，比较引用数据类型的引用地址是否相同</li><li>HashCode()：本地方法，未被重写前返回对象在堆上的唯一地址值，可以看作是对象的身份ID</li><li>clone()：实现了cloneable接口才可以调用该方法，实现对象的浅复制</li><li>getClass()：final修饰，获取运行时的类型</li><li>toString()：若参数为变量，则返回对应变量的string对象，若参数为一个对象，则返回堆内存对象的地址</li><li><strong>finalize</strong>()：在GC准备释放对象所占用的内存空间之前，它将首先调用finalize()方法，finalize()方法中一般用于释放非Java 资源（如打开的文件资源、数据库连接等）,或是调用native方法时分配的内存(比如C语言的malloc()）。</li><li>wait()：使线程阻塞等待</li><li>notify()：唤醒等待的线程</li><li>nofityAll()：唤醒在该对象上等待的所有线程</li></ol><h3 id="JAVA的八大数据类型"><a href="#JAVA的八大数据类型" class="headerlink" title="JAVA的八大数据类型"></a><em>JAVA的八大数据类型</em></h3><p>可以分为四个大类：整型，字符型，浮点型，布尔型</p><ol><li>boolean：JVM中并没有提供boolean专用的字节码指令，在编译后会以int型来表示，<strong>4字节</strong>。boolean[]会以byte数组来表示，<strong>1字节</strong></li><li>char：可以赋值单字符以及整型数值，表示数字的取值范围为0~65536，<strong>2字节</strong></li><li>byte：范围为-128 - 128，1字节</li><li>short：范围为：-32768-32768，2字节</li><li>int：范围为：-2,147,483,648-2,147,483,647，4字节</li><li>long：范围为；-2^63-2^63-1，8字节</li><li>float：单精度浮点数，4字节</li><li>double：双精度浮点数，8字节</li></ol><h3 id="接口和抽象类有哪些区别"><a href="#接口和抽象类有哪些区别" class="headerlink" title="接口和抽象类有哪些区别"></a><em>接口和抽象类有哪些区别</em></h3><p>相同点：</p><ol><li>不能被实例化</li><li>可以将抽象类和接口类型作为引用类型</li><li>一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部实现</li></ol><p>不同点：</p><ol><li>抽象类中可以定义构造器，可以有抽象方法和具体方法，抽象类中可以定义成员变量，一个类只能继承一个抽象类，抽象类中可以包含静态方法，抽象类中的成员可以由private,protected,public修饰</li><li>接口中的成员全部都是由public修饰，不能定义构造器，只能有抽象方法，不能有静态方法，一个类可以实现多个接口</li></ol><p>除了语法上的异同之外，两者还有语义上的不同。抽象类适合描述某一更具体的概念，比如狗<strong>是</strong>一种<strong>动物</strong>，而不能说狗<strong>实现</strong>了动物的<strong>接口</strong>。接口则用于描述多个事物的共同特征，比如鸟<strong>实现了</strong>flyable接口，这个flyable就是一种<strong>行为特征</strong>，当然也可以描述其他的特征。</p><h3 id="String-StringBuilder-StringBuffer的区别"><a href="#String-StringBuilder-StringBuffer的区别" class="headerlink" title="String,StringBuilder,StringBuffer的区别"></a><em>String,StringBuilder,StringBuffer的区别</em></h3><ol><li>String的底层是一个由final修饰的char型数组，String是静态只读的，当改变变量的值时，其实只是改变了引用对象的指向，指向了新创建的字符串，而原字符串仍存在于字符串常量池。</li><li>StringBuffer（JDK1.0引入）：引用对象指向一个空间，包含一个可自行扩容的char型数组和字符串长度计数变量Count，StringBuffer的所有方法均被synchronized修饰。扩容时会开辟一块新的空间用于创建更大的数组，并将原数据复制过去，并改变引用对象的指向。</li><li>StringBuilder(JDK1.5引入)：取消了synchronized方法修饰，所以效率更高，但是线程不安全。</li></ol><h3 id="Object-o-new-Object-在内存中占用多少个字节？"><a href="#Object-o-new-Object-在内存中占用多少个字节？" class="headerlink" title="Object o = new Object()在内存中占用多少个字节？"></a><em><code>Object o = new Object()</code>在内存中占用多少个字节？</em></h3><p>一个对象在内存中的存储布局：<code>markword</code>：8字节，<strong>锁信息+HashCode+GC信息</strong>；<code>classPointer</code>:4字节；对齐：保证大小能<strong>被8整除</strong>；数据段：即对象内声明的变量</p><p>所以一个空对象<strong>最小为16字节</strong></p><h3 id="对象如何定位？"><a href="#对象如何定位？" class="headerlink" title="对象如何定位？"></a><em>对象如何定位？</em></h3><p><code>HotSpot</code>虚拟机默认使用直接定位：指针直接指向堆内存内的对象，对象内的<code>classPointer</code>指向方法区内的class。优点：直接访问快；缺点：GC时，若需要移动对象，则指针也需要改变</p><p>句柄方式（间接方式）：指针指向另一个结构体，该结构体内有两个指针，分别指向堆内存和方法区。优点：对象小，GC时无需改动指针。缺点：比直接访问更慢</p><h3 id="对象的创建过程"><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a><em>对象的创建过程</em></h3><p>new指令：申请内存空间，为成员变量设立默认值</p><p><code>invokespecial</code>汇编码：调用构造方法，为成员变量设定初始值</p><p><code>astore</code>汇编码：建立引用，让指针指向堆</p><h3 id="面向对象有哪些特征"><a href="#面向对象有哪些特征" class="headerlink" title="面向对象有哪些特征"></a><em>面向对象有哪些特征</em></h3><p>面向对象是一种编程思想，即万物皆可归类抽象，万物皆可对象；有三大特征</p><ol><li>封装：类与外界的封装关系，即隐藏类内部的实现机制，对外部而言，它的内部细节是隐藏的，只暴露了自身的访问方法。使用者按照既定的方式来调用方法，不必关心方法的内部实现，便于使用，增强了代码的可维护性。</li><li>继承：类与类的关系，即从已有的类中派生出新的类，即子类与父类，也可以称作超类和基类。从多个类中抽象出一个基类，使其具备多个类的共同特性，使用extends关键字继承某个类后，就具备了父类的属性，并扩展新的属性。在父类中使用private关键字来限制不会被继承。</li><li>多态：多个类的关系，必备的三个要素：继承，重写，父类引用指向子类对象</li></ol><h3 id="ArrayList与LinkedList的区别"><a href="#ArrayList与LinkedList的区别" class="headerlink" title="ArrayList与LinkedList的区别"></a><em>ArrayList与LinkedList的区别</em></h3><ol><li>ArrayList是基于索引的数据接口，底层是数组，可以在常数级的复杂度对元素进行随机访问。而LinkedList是基于Node对象列表的形式存储数据，底层是一个双向链表，查找元素是O（n）。因此LinkedList的插入，添加，删除操作，总体上会更快，因为不是数组，不需要移动元素，重新计算索引和大小，但是LinkedList更占内存，因为每一个node都会封装前驱指针和后继指针。</li><li>如果你需要经常随机访问数据，更加推荐使用ArrayList；如果需要经常插入删除元素，推荐使用LinkedList。</li><li>多提一嘴：其实总体上ArrayList性能其实更加优越一些。第一，LinkedList的每一个node都有指针，更占内存，第二：虽然LinkedList的头插效率很高，但是尾插效率却不见得十分高效，因为数组的尾插无需进行拷贝和移位，而链表则需要创建node对象。并且有人测试过，在数据量较大时，链表的中间插入仍会比ArrayList耗时更多。Joshua Bloch自己都不用LinkedList，以俺还是无脑选择ArrayList~</li></ol><h3 id="多线程环境下，操作long和double类型为什么不安全？"><a href="#多线程环境下，操作long和double类型为什么不安全？" class="headerlink" title="多线程环境下，操作long和double类型为什么不安全？"></a><em>多线程环境下，操作long和double类型为什么不安全？</em></h3><p>JAVA内存模型要求，变量的读取和写入必须是原子操作，但对于非volatile类型的long和double变量，JVM允许将64位的<strong>读操作或写操作分解成两个32位的操作</strong>。当读取一个非volatile类型的long时，如果读操作和写操作在不同的线程中执行，那么很可能读取到<strong>某个值的高32位和另一个值的低32位</strong>。就是说，在多线程环境下，使用共享且可变的long和double变量是不安全的，必须用关键字volatile声明或者用锁保护起来。但是如果在64bit的操作环境下，读写就可以是原子操作。</p><h3 id="什么是线程安全？"><a href="#什么是线程安全？" class="headerlink" title="什么是线程安全？"></a><em><strong>什么是线程安全？</strong></em></h3><p>当多个线程访问某个类时，这个类始终能表现出正确的行为，那么就称这个类是线程安全的。具体说，就是当多个线程访问某个类时，不管运行时环境采用何种调度方式将这些线程交替进行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类时线程安全的。</p><h3 id="Int和Integer的区别"><a href="#Int和Integer的区别" class="headerlink" title="Int和Integer的区别"></a><em><strong>Int和Integer的区别</strong></em></h3><ol><li>Integer是int的包装类，int则是java的一种基本的数据类型；</li><li>Integer变量必须实例化之后才能使用，而int变量不需要实例化；</li><li>Integer实际是对象的引用，当new一个Integer时，实际上生成一个指针指向对象，而int则直接存储数值</li><li>Integer的默认值是null，而int的默认值是0。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//直接存储值</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//无new创建Integer对象时，这种操作等于：Integer.valueOf(1);</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//指向堆内存中的对象</span><br></code></pre></td></tr></table></figure><p><strong>包装类的缓存机制</strong></p><p>若使用valueOf方法，则会调用缓存IntegerCache，这是一个静态内部类，会直接缓存-127到128的Integer对象。</p><p>因此，在valueOf方法中，如果值在-127-128之间，都会直接返回缓存中的该对象而不会重新生成对象。</p><p>如果超过这个范围就会直接在堆上创建一个新的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>     <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>         <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<span class="hljs-comment">//超过范围</span><br> &#125;<br></code></pre></td></tr></table></figure><p>Byte，Short，Long的缓存范围都是-128-127，Character的缓存范围是0-127，除了Integer，其他的缓存范围都是固定的</p><h3 id="ALV树和红黑树有什么区别？"><a href="#ALV树和红黑树有什么区别？" class="headerlink" title="ALV树和红黑树有什么区别？"></a><em>ALV树和红黑树有什么区别？</em></h3><ol><li>AVL树是严格平衡二叉树，左右子树树高不超过1；而红黑树是弱平衡二叉树，<strong>红黑树确保没有一条路径会比其它路径长出两倍</strong>。所以在相同的节点下，AVL树的高度要低一些，低于红黑树</li><li>AVL树和红黑树都是通过旋转来保持平衡，AVL旋转更加频繁，<strong>AVL树适合用于插入删除次数比较少，但查找多的情况</strong>。红黑树的旋转次数更少，所以对于搜索、插入、删除操作较多的情况下，使用红黑树</li><li>黑树通过它规则的设定，确保了<strong>插入和删除的时间复杂度是O(log N)</strong> ，每次插入和删除的平均旋转次数小于AVL树。但是AVL树的查找效率高于红黑树</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Java基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NIO select poll和epoll</title>
    <link href="/post/NIO-select-poll%E5%92%8Cepoll.html"/>
    <url>/post/NIO-select-poll%E5%92%8Cepoll.html</url>
    
    <content type="html"><![CDATA[<h1 id="套接字编程"><a href="#套接字编程" class="headerlink" title="套接字编程"></a>套接字编程</h1><p>Socket，表示进程间网络通信的特殊文件类型。本质是内核借助缓冲区形成的伪文件。<code>Linux</code>将<strong>套接字封装成文件</strong>的目的是为了<strong>统一接口</strong>，使得<strong>读写套接字和读写文件的操作一致</strong>。</p><p>在TCP&#x2F;IP协议中，“IP地址+TCP或UDP端口号”<strong>唯一标识网络通讯中的一个进程</strong>。</p><p>“IP地址+端口号”就对应一个socket。欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用Socket来描述网络连接的一对一关系。</p><p><img src="/../img/socket.png" alt="socket"></p><p>一个<strong>文件描述符</strong>指向一个<strong>套接字</strong></p><p><strong>一个套接字</strong>内部由<strong>内核</strong>借助<strong>两个缓冲区</strong>实现，一个写缓冲、读缓冲。</p><p><strong>在通信过程中， 套接字一定是成对出现的</strong>。一端的发送缓冲区对应对端的接收缓冲区</p><p><img src="/../img/sokect1.png" alt="sokect1"></p><ol><li>socket()创建一个socket</li><li>bind()为socket绑定ip+port</li><li>listen()设置监听上限，即同时跟服务器建立socket连接的数量</li><li>accept()：阻塞监听客户端连接，创建一个新的socket用来与客户端通信</li><li>connect()：客户端使用现有的socket与服务器建立连接，如果不使用bind绑定客户端地址结构，采用“隐式绑定”，系统自动分配ip+port</li></ol><h1 id="网络IO"><a href="#网络IO" class="headerlink" title="网络IO"></a>网络IO</h1><p>同步：同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。<strong>也就是说，调用会等待返回结果计算完成才能继续执行。</strong>BIO,NIO,select,poll,epoll都是同步的，只不过会有阻塞，非阻塞的区别。</p><p>异步：异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。<strong>也就是说，其实异步调用会直接返回，但是这个结果不是计算的结果，当结果计算出来之后，才通知被调用的程序。</strong></p><p>阻塞：阻塞调用是指<strong>调用结果返回之前</strong>，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务。</p><p>非阻塞：不管可不可以读写，<strong>它都会立即返回</strong>，返回成功说明读写操作完成了，返回失败会设置相应errno状态码，根据这个errno可以进一步执行其他处理。它不会像阻塞IO那样，卡在那里不动。</p><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p>即阻塞IO，一个socket对应一个线程，若无数据发送则会一直阻塞等待，造成资源浪费</p><p>特别是在JAVA环境下，线程的创建，切换，代价高昂</p><p>结构简单，适合规模小，低并发的情况</p><p><img src="/../img/BIO.png" alt="BIO"></p><h4 id="特点：面向流的，阻塞的"><a href="#特点：面向流的，阻塞的" class="headerlink" title="特点：面向流的，阻塞的"></a>特点：面向流的，阻塞的</h4><p>java1.4以前的io模型，一连接对一个线程，原始的IO是面向流的，不存在缓存的概念。</p><p>Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。</p><p>此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区</p><p>Java IO的各种流是阻塞的，这意味着当一个线程调用read或 write方法时，该线程被阻塞，直到有一些数据被读取，或数据完全写入，该线程在此期间不能再干任何事情了。</p><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>非阻塞IO，顾名思义就是所有IO操作都是立刻返回而不会阻塞当前用户进程</p><p><img src="/../img/non-blocking-io.png" alt="non-blocking-io"></p><p>当用户进程发出 read 操作时，如果 kernel 中的数据还没有准备好，那么它并不会 block 用户进程，而是立刻返回一个 EAGAIN error。</p><p>从用户进程角度讲 ，它发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦 kernel 中的数据准备好了，并且又再次收到了用户进程的 system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p><p>所以，Non-blocking I&#x2F;O 的特点是用户进程需要不断的主动询问 kernel 数据好了没有。</p><h2 id="JAVA-NIO——NEW-IO"><a href="#JAVA-NIO——NEW-IO" class="headerlink" title="JAVA NIO——NEW IO"></a>JAVA NIO——NEW IO</h2><p>JAVA底层对于NIO的实现，配合了多路复用机制：</p><p>使用一个线程不断轮询来管理所有套接字，即一个while死循环来不断遍历，一旦发现有数据便进行处理。</p><p>做到了单线程也能管理所有套接字。这是非阻塞的，就算没有数据也不会停下来，而是返回无数据的标识，然后再进行下一次的轮询。</p><p>IO多路复用是面向缓冲区的，每个连接都有一个缓冲区来暂存数据，由管道来进行双向传输</p><p><img src="/../img/reactor2.png" alt="reactor2"></p><h2 id="selector"><a href="#selector" class="headerlink" title="selector"></a>selector</h2><p>实现循环监听通道信号的组件</p><p>一个selector 对应一个线程， 多个channel以事件的方式注册于selector，代表一个进程便可以处理多个连接</p><p>selector 会在各个通道上切换，只有在连接&#x2F;通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，避免了多线程之间的上下文切换导致的开销</p><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>通道类似于流，但有些区别如下：</p><ol><li>通道可以同时进行读写，而流只能读或者只能写</li><li>通道可以实现异步读写数据</li><li>通道可以从缓冲读数据，也可以写数据到缓冲</li></ol><p>channel 是双向的, 可以返回底层操作系统的情况, 比如Linux ，底层的操作系统通道就是双向的</p><h3 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h3><p>Buffer 就是一个内存块 ，底层是有一个数组</p><p>channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer</p><p>数据的读取写入是通过Buffer, 这个和BIO不同 , BIO 中要么是输入流，或者是输出流，不能双向</p><p>但是NIO的Buffer 是可以读也可以写, 需要 flip 方法切换</p><h4 id="特点：面向块，非阻塞"><a href="#特点：面向块，非阻塞" class="headerlink" title="特点：面向块，非阻塞"></a>特点：面向块，非阻塞</h4><p>NIO是面向缓冲区的。数据被读取到缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性。</p><p>Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。</p><p>NIO是可以做到用一个线程来处理多个操作的。selector会不断循环监听channel，如果通道中没有数据即没有请求时它可以去处理别的通道或者做其他的事情，如果通道中有数据它就会选择这个通道然后进行处理，实现了一个线程处理多个连接。</p><h1 id="I-x2F-O-多路复用"><a href="#I-x2F-O-多路复用" class="headerlink" title="I&#x2F;O 多路复用"></a>I&#x2F;O 多路复用</h1><p>所谓 I&#x2F;O 多路复用指的就是 <strong>select&#x2F;poll&#x2F;epoll</strong> 这一系列的多路选择器：支持单一线程同时监听多个文件描述符（I&#x2F;O 事件），阻塞等待，并在其中某个文件描述符可读写时收到通知。</p><p> I&#x2F;O 复用其实复用的不是 I&#x2F;O 连接，而是<strong>复用线程</strong>，让一个 thread能够处理多个连接（I&#x2F;O 事件）。</p><h1 id="select"><a href="#select" class="headerlink" title="select"></a><code>select</code></h1><p>select 是 epoll 之前 Linux 使用的 I&#x2F;O 事件驱动技术。</p><p><strong>select监听文件描述符的数据结构是一个位图，即fd_set</strong> </p><p>如果取 fd_set 长度为 1 字节，fd_set 中的每bit可以对应一个文件描述符fd，则1字节长的fd_set最大可以对应 8 个fd</p><ol><li>执行<code>FD_ZERO(&amp;set),</code> 则 set 用位表示是 0000,0000 </li><li>若 fd＝5, 执行 <code>FD_SET(fd, &amp;set)</code>; 后 set 变为 0001,0000(第 5 位置为 1) </li><li>再加入 fd＝2, fd&#x3D;1，则 set 变为 0001,0011 执行 <code>select(6, &amp;set, 0, 0, 0)</code> 阻塞等待 </li><li>若 fd&#x3D;1, fd&#x3D;2 上都发生可读事件，则 select 返回，此时 set 变为 0000,0011 (没有事件发生的 fd&#x3D;5 被清空)</li></ol><p>可监控的文件描述符个数取决于 <code>sizeof(fd_set)</code> 的值。假设服务器上 <code>sizeof(fd_set)＝512</code>，每 bit 表示一个文件描述符，则服务器上支持的最大文件描述符是 512*8&#x3D;4096。</p><p>执行select系统调用后，内核会返回一个整数，若小于零，代表没有任何数据或请求到达，若大于零，代表可以进行处理。若等于零，代表等待超时。</p><p><strong>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</strong></p><p><strong>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</strong></p><p><strong>fd_set的大小是有限制的，即单个进程能维护的套接字的大小有限，32位为1024，64位机默认是2048。可以修改。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>      read_fd_set = all_fd_set;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;阻塞中... lastfd=%d\n&quot;</span>, lastfd);<br>    <span class="hljs-comment">//获取标志位</span><br>      <span class="hljs-type">int</span> nready = select(lastfd+<span class="hljs-number">1</span>, &amp;read_fd_set, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>      <span class="hljs-keyword">switch</span> (nready) &#123;<br>          <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> :<br>              <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;select time out ......\n&quot;</span>);<br>              <span class="hljs-keyword">break</span>;<br>          <span class="hljs-keyword">case</span> <span class="hljs-number">-1</span> :<br>              perror(<span class="hljs-string">&quot;select error \n&quot;</span>);<br>              <span class="hljs-keyword">break</span>;<br>          <span class="hljs-keyword">default</span>:<br>              <span class="hljs-comment">// 监听到新的客户端连接</span><br>              <span class="hljs-keyword">if</span> (FD_ISSET(lfd, &amp;read_fd_set)) &#123;<br>                  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client_addr</span>;</span> <br>                  <span class="hljs-type">socklen_t</span> cliaddr_len = <span class="hljs-keyword">sizeof</span>(client_addr);<br>                  <span class="hljs-type">char</span> cli_ip[INET_ADDRSTRLEN] = <span class="hljs-string">&quot;&quot;</span>;  <br>                  <span class="hljs-comment">// 肯定有连接不会阻塞</span><br>                  <span class="hljs-type">int</span> clientfd = accept(lfd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;client_addr, &amp;cliaddr_len);<br>                  inet_ntop(AF_INET, &amp;client_addr.sin_addr, cli_ip, INET_ADDRSTRLEN);<br>                  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;----------------------------------------------\n&quot;</span>);<br>                  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client ip=%s,port=%d\n&quot;</span>, cli_ip, ntohs(client_addr.sin_port));<br>                  <span class="hljs-comment">// 将clientfd加入读集合</span><br>                  FD_SET(clientfd, &amp;all_fd_set);  <br>                  lastfd = clientfd;<br>                  <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> == --nready) &#123;<br>                      <span class="hljs-keyword">continue</span>;<br>                  &#125;<br>              &#125;<br>              <span class="hljs-type">int</span> i;<br>              <span class="hljs-comment">//遍历所有的fdset来处理事件</span><br>              <span class="hljs-keyword">for</span> (i = lfd + <span class="hljs-number">1</span>;i &lt;= lastfd; i++) &#123;<br>                  <span class="hljs-comment">// 处理读事件</span><br>                  <span class="hljs-keyword">if</span> (FD_ISSET(i, &amp;read_fd_set)) &#123;<br>                      <span class="hljs-type">char</span> recv_buf[<span class="hljs-number">512</span>] = <span class="hljs-string">&quot;&quot;</span>;<br>                      <span class="hljs-type">int</span> rs = read(i, recv_buf, <span class="hljs-keyword">sizeof</span>(recv_buf));<br>                      <span class="hljs-keyword">if</span> (rs == <span class="hljs-number">0</span> ) &#123;<br>                          close(i);<br>                          FD_CLR(i, &amp;all_fd_set);<br>                      &#125; <span class="hljs-keyword">else</span> &#123;<br>                          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,recv_buf);<br>                          <span class="hljs-comment">// 给每一个服务端写数据</span><br>                          <span class="hljs-type">int</span> j;<br>                          <span class="hljs-keyword">for</span> (j = lfd + <span class="hljs-number">1</span>;j &lt;= lastfd; j++) &#123;<br>                              <span class="hljs-keyword">if</span> (j != i) &#123;<br>                                  write(j, recv_buf, <span class="hljs-built_in">strlen</span>(recv_buf));<br>                              &#125;<br>                          &#125;<br>                      &#125;<br>                  &#125;<br>              &#125;<br>      &#125;<br>      <br>  &#125;<br><br></code></pre></td></tr></table></figure><h1 id="poll"><a href="#poll" class="headerlink" title="poll"></a><code>poll</code></h1><p>poll 的实现和 select 非常相似，只是描述 fd 集合的方式不同，poll 使用 pollfd 结构而不是 select 的 fd_set 结构，poll 解决了最大文件描述符数量限制的问题，但是同样需要从用户态拷贝所有的 fd 到内核态，也需要线性遍历所有的 fd 集合，所以它和 select 只是实现细节上的区分，并没有本质上的区别。</p><h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a><code>epoll</code></h1><p>select&amp;poll 错误预估了一件事，当数十万并发连接存在时，可能每一毫秒只有数百个活跃的连接，同时其余数十万连接在这一毫秒是非活跃的。当监控的文件描述符数量很多时，就会造成效率损失。</p><p>与前面所有的轮询机制不同，epoll使用的是<strong>事件驱动</strong></p><p>即当发生事件时，每个fd上有注册有回调函数，当网卡接收到数据时会回调该函数，同时将该fd的引用放入rdlist就绪链表中。</p><p>当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。</p><p>如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户。</p><p>避免了遍历所有的fd，只检查发生事件的fd</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 数据结构</span><br><span class="hljs-comment">// 每一个epoll对象都有一个独立的eventpoll结构体</span><br><span class="hljs-comment">// 用于存放通过epoll_ctl方法向epoll对象中添加进来的事件</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">eventpoll</span> &#123;<br>    <span class="hljs-comment">/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">rb_root</span>  rbr;<br>    <span class="hljs-comment">/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> rdlist;<br>&#125;;<br></code></pre></td></tr></table></figure><p>执行流程</p><ol><li>调用epoll_create()创建一个ep对象，在内核空间中开辟了一块空间存储eventpoll，返回一个文件句柄，即红黑树的根节点</li><li>调用epoll_ctl()向红黑树中添加、删除、修改fd</li><li>调用epoll_wait()等待，当有事件发生时网卡驱动会调用fd上注册的回调函数并将该fd添加到rdlist中。epoll_wait 实际上就是去检查 rdllist 双向链表中是否有就绪的 fd，当 rdllist 为空（无就绪 fd）时挂起当前进程，直到 rdllist 非空时进程才被唤醒并返回。</li></ol><p><img src="/../img/epoll.png" alt="epoll"></p><p>总结：</p><ol><li>EPOLL支持的最大文件描述符上限是整个系统最大可打开的文件数目, 1G内存理论上最大创建10万个文件描述符</li><li>每个文件描述符上都有一个callback函数，当socket有事件发生时会回调这个函数将该fd的引用添加到就绪列表中，select和poll并不会明确指出是哪些文件描述符就绪，而epoll会。造成的区别就是，系统调用返回后，调用select和poll的程序需要遍历监听的整个文件描述符找到是谁处于就绪，而epoll则直接处理即可</li><li>select、poll采用轮询的方式来检查所有文件描述符是否处于就绪态，而epoll采用回调机制。造成的结果就是，随着fd的增加，select和poll的效率会线性降低，而epoll不会受到太大影响，<strong>除非活跃的socket很多</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//开辟内核空间，返回文件描述符</span><br><span class="hljs-type">int</span> epfd = epoll_create(<span class="hljs-number">1</span>);<br>event.data.fd = lfd;<br>event.events = EPOLLIN;<br>epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;event);<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;阻塞中....\n&quot;</span>);<br>    <span class="hljs-comment">//从事件集中获取文件描述符</span><br>        <span class="hljs-type">int</span> nready = epoll_wait(epfd, events, <span class="hljs-number">20</span>, <span class="hljs-number">-1</span>);<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nready; ++i) &#123;<br>            <span class="hljs-comment">// 监听到新的客户端连接</span><br>            <span class="hljs-keyword">if</span> (events[i].data.fd == lfd) &#123;<br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client_addr</span>;</span> <br>                <span class="hljs-type">socklen_t</span> cliaddr_len = <span class="hljs-keyword">sizeof</span>(client_addr);<br>                <span class="hljs-type">char</span> cli_ip[INET_ADDRSTRLEN] = <span class="hljs-string">&quot;&quot;</span>;  <br>                <span class="hljs-comment">// 肯定有连接不会阻塞</span><br>                <span class="hljs-type">int</span> clientfd = accept(lfd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;client_addr, &amp;cliaddr_len);<br>                inet_ntop(AF_INET, &amp;client_addr.sin_addr, cli_ip, INET_ADDRSTRLEN);<br>                event.data.fd = clientfd;<br>                event.events = EPOLLIN | EPOLLET;<br>                epoll_ctl(epfd, EPOLL_CTL_ADD, clientfd, &amp;event);<br>                <br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;----------------------------------------------\n&quot;</span>);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client ip=%s,port=%d\n&quot;</span>, cli_ip, ntohs(client_addr.sin_port));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">char</span> recv_buf[<span class="hljs-number">512</span>] = <span class="hljs-string">&quot;&quot;</span>;<br>                <span class="hljs-type">int</span> rs = read(events[i].data.fd, recv_buf, <span class="hljs-keyword">sizeof</span>(recv_buf));<br>                <span class="hljs-keyword">if</span> (rs &lt; <span class="hljs-number">0</span>) &#123;<br>                    close(events[i].data.fd);<br>                    epoll_ctl(epfd, EPOLL_CTL_DEL, events[i].data.fd, &amp;event);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,recv_buf);<br>            &#125;<br>        &#125;      <br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="C10K问题"><a href="#C10K问题" class="headerlink" title="C10K问题"></a>C10K问题</h1><p><strong>服务器如何支持10k个并发连接？</strong></p><h2 id="为每个连接分配一个独立的线程-x2F-进程"><a href="#为每个连接分配一个独立的线程-x2F-进程" class="headerlink" title="为每个连接分配一个独立的线程&#x2F;进程"></a>为每个连接分配一个独立的线程&#x2F;进程</h2><p>这一思路最为直接。但是，由于申请进程&#x2F;线程会占用相当可观的系统资源，同时对于多进程&#x2F;线程的管理会对系统造成压力，因此，这种方案不具备良好的可扩展性。这一思路在服务器资源还没有富裕到足够程度的时候，是不可行的。即便资源足够富裕，效率也不够高。</p><p>总之，此思路技术实现会使得资源占用过多，可扩展性差，在实际应用中已被抛弃。</p><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a><strong>IO多路复用</strong></h2><ol><li>循环逐个处理各个连接，每个连接对应一个 socket。当所有 socket 都有数据的时候，这种方法是可行的。但是，当应用读取某个 socket 的文件数据不 ready 的时候，整个应用会阻塞在这里，等待该文件句柄ready，即使别的文件句柄 ready，也无法往下处理。任一文件句柄的不成功会阻塞住整个应用。</li><li>使用select方法解决上面阻塞的问题。在读取文件句柄之前，先查下它的状态，如果ready 了，就进行处理；如果不 ready， 就不进行处理；于是，有了 select 方案。用一个 fd_set 结构体来告诉内核同时监控多个文件句柄，当其中有文件句柄的状态发生指定变化（例如某句柄由不可用变为可用）或超时，则调用返回。同时，在使用上，因为只有一个字段记录关注和发生事件，所以每次调用之前，要重新初始化fd_set结构体。并且因为监听的是所有fd，所以当fd过多时，检查状态就会很慢</li><li>poll 和select原理基本相同，不过消除了文件句柄上限。使用不同字段分别标注“关注事件和发生事件”，来避免重复初始化。</li><li>使用epoll，“poll逐个排查所有文件句柄状态”效率不高。如果在调用返回的时候，只给应用提供发生了状态变化（很可能是数据 ready）的文件句柄，进行排查的效率就高很多。epoll 采用了这种设计，适用于大规模的应用场景。实验表明：当文件句柄数目超过10之后，epoll 性能将优于 select 和 poll；当文件句柄数目达到 10K 的时候，epoll 已经超过 select 和 poll 两个数量级。</li></ol><h2 id="C10M：服务器如何支持10M个并发连接？"><a href="#C10M：服务器如何支持10M个并发连接？" class="headerlink" title="C10M：服务器如何支持10M个并发连接？"></a>C10M：服务器如何支持10M个并发连接？</h2><p>内核是问题所在，要高效地去除阻塞，让CPU更多地处理核心任务。不要让内核执行所有繁重的任务。将数据包处理、内存管理、处理器调度等任务从内核转移到应用程序，由应用程序高效地完成。让Linux只处理控制层，数据层完全交给应用程序来处理。</p><p>当连接很多时，首先需要大量的进程&#x2F;线程。同时，系统中的应用进程&#x2F;线程可能大量地都处于 ready 状态，需要系统不断地进行快速切换，系统的上下文的切换是有代价的。</p><p>所以我们面临的瓶颈有两个：一个是进程&#x2F;线程作为处理单元，还是太厚重了；另一个是系统调度的代价太高了。</p><p>如果有一种更轻量级的进程&#x2F;线程作为处理单元，而且它们的调度可以做到很快，也许就能解决问题，这就是<strong>协程</strong></p><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>协程在实现上都是试图用一组少量的线程来实现多个任务，一旦某个任务阻塞，则可能用同一线程继续运行其他任务，避免大量上下文的切换。每个协程所独占的系统资源往往只有栈部分。各个协程之间的切换，往往是用户通过代码来显式指定的（跟各种callback 类似），不需要内核参与，可以很方便实地现异步。</p><p>这个技术本质上是<strong>异步非阻塞</strong>技术，它是将事件回调进行了包装，让程序员看不到里面的事件循环。程序员就像写阻塞代码一样简单。</p><p>比如调用 client-&gt;recv() 等待接收数据时，就像阻塞代码一样写。实际上是，底层库在执行recv时悄悄保存了一个状态，比如代码行数、局部变量的值。然后，就跳回到EventLoop中了。什么时候真的数据到来时，它再把刚才保存的代码行数、局部变量值取出来，又开始继续执行。</p><p>这就是协程的本质。<strong>协程是异步非阻塞的另外一种展现形式</strong>。Golang、Erlang、Lua协程都是这个模型。</p>]]></content>
    
    
    
    <tags>
      
      <tag>网络编程基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>洪水淹没算法</title>
    <link href="/post/%E6%B4%AA%E6%B0%B4%E6%B7%B9%E6%B2%A1%E7%AE%97%E6%B3%95.html"/>
    <url>/post/%E6%B4%AA%E6%B0%B4%E6%B7%B9%E6%B2%A1%E7%AE%97%E6%B3%95.html</url>
    
    <content type="html"><![CDATA[<h2 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a><a href="https://leetcode.cn/problems/max-area-of-island/">695. 岛屿的最大面积</a></h2><p><img src="/../img/maxarea1-grid.jpg" alt="maxarea1-grid"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：grid = [[<span class="hljs-number">0,0,1,0</span>,<span class="hljs-number">0,0,0,1</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,1</span>,<span class="hljs-number">1,1,0,0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0,1,1,0</span>,<span class="hljs-number">1,0,0,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0,1,0,0</span>,<span class="hljs-number">1,1,0,0</span>,<span class="hljs-number">1,0,1,0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0,1,0,0</span>,<span class="hljs-number">1,1,0,0</span>,<span class="hljs-number">1,1,1,0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,1,0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,1</span>,<span class="hljs-number">1,1,0,0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,1</span>,<span class="hljs-number">1,0,0,0</span>,<span class="hljs-number">0</span>]]<br>输出：<span class="hljs-number">6</span><br>解释：答案不应该是 <span class="hljs-number">11</span> ，因为岛屿只能包含水平或垂直这四个方向上的 <span class="hljs-number">1</span> 。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxAreaOfIsland</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> m=grid.length;<br>        <span class="hljs-type">int</span> n=grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>)&#123;<br>                    res=Math.max(res,FloodFill(grid,i,j));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">//淹没与i,j相邻的陆地并记录下面积</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">FloodFill</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid,<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-keyword">if</span>(!isValid(i,j,grid)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        grid[i][j]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> FloodFill(grid,i+<span class="hljs-number">1</span>,j)<br>        +FloodFill(grid,i,j+<span class="hljs-number">1</span>)<br>        +FloodFill(grid,i-<span class="hljs-number">1</span>,j)<br>        +FloodFill(grid,i,j-<span class="hljs-number">1</span>) +<span class="hljs-number">1</span>;<br><br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">int</span>[][] grid)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">0</span> &amp;&amp; j&gt;=<span class="hljs-number">0</span> &amp;&amp; i&lt;grid.length &amp;&amp; j&lt;grid[<span class="hljs-number">0</span>].length)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></h2><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：grid = [<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>]<br>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//二维数组的递归遍历和floodfill算法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numIslands</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                    res++;<br>                    FloodFill(grid,i,j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">//洪水填充算法，将1周围的所有1都改变为0，最终使得图中的1的数目便是岛屿的数目</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">FloodFill</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-keyword">if</span>(!isValid(i,j,grid)) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span>;<br>        grid[i][j] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        FloodFill(grid,i+<span class="hljs-number">1</span>,j);<br>        FloodFill(grid,i,j+<span class="hljs-number">1</span>);<br>        FloodFill(grid,i-<span class="hljs-number">1</span>,j);<br>        FloodFill(grid,i,j-<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">char</span>[][] grid)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">0</span> &amp;&amp; j&gt;=<span class="hljs-number">0</span> &amp;&amp; i&lt;grid.length &amp;&amp; j&lt;grid[<span class="hljs-number">0</span>].length)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode初见</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html"/>
    <url>/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络的分层模型"><a href="#计算机网络的分层模型" class="headerlink" title="计算机网络的分层模型"></a>计算机网络的分层模型</h1><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><ol><li>应用层：计算机上的网络应用，传输应用报文，如HTTP，SMTP</li><li>表示层：用于处理交换信息的表示格式（处理语法和处理语义），格式变换，数据加密解密，数据压缩等功能</li><li>会话层：向表示层建立连接，并传输有序的数据，也就是建立同步SYN</li><li>运输层：负责两个进程的通信，即端到端，如TCP UDP</li><li>网络层：讲分组从源端传到目的端，注重传输过程中的路径选择，如IP</li><li>链路层：讲网络层的数据包封装成帧，如CSMA</li><li>物理层：以比特流的方式传输</li></ol><p>上面4层是端到端的，也就是关注的是数据从源主机交付到目的主机，而不管每步是怎么传输的</p><p>下面3层是点到点的，关注数据在传输过程中下一步是怎么走的，也就是路由是如何转发的</p><h3 id="TCP-x2F-IP四层模型"><a href="#TCP-x2F-IP四层模型" class="headerlink" title="TCP&#x2F;IP四层模型"></a>TCP&#x2F;IP四层模型</h3><ol><li>应用层（应用层+表示层+会话层）</li><li>运输层</li><li>网络层</li><li>网络接口层（物理层+链路层）</li></ol><h3 id="五层参考模型"><a href="#五层参考模型" class="headerlink" title="五层参考模型"></a>五层参考模型</h3><ol><li>应用层</li><li>运输层 </li><li>网络层</li><li>链路层</li><li>物理层</li></ol><h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>特点</p><ol><li>无连接状态：UDP无需任何准备就可以传输数据，也没有引入建立连接的时延。并且UDP也不维护连接状态</li><li>精确控制发送数据的时机：应用程序将数据传给UDP，UDP可以立即将数据封装为UDP报文并传递给网络层，而TCP引入了拥塞机制来控制发送方的频率。</li></ol><p>报文结构：</p><p>UDP首部仅四个部分</p><ol><li>源端口号：2字节</li><li>目的端口号：2字节</li><li>长度：2字节</li><li>校验和：2字节</li></ol><p>UDP的校验和：应用数据的所有16比特字之和的反码</p><h1 id="TCP详解"><a href="#TCP详解" class="headerlink" title="TCP详解"></a>TCP详解</h1><p>特征：工作在运输层，为应用层序提供可靠传输服务，确保网络包<strong>无损坏，无间隔，非冗余，按序排列</strong></p><p><strong>TCP首部的控制位字段部分</strong></p><ol><li>ACK&#x3D;1 表明确认字段有效</li><li>RST&#x3D;1 表示TCP连接出现严重错误（比如期望确认号与实际收到的确认号不同），必须释放连接，再重新建立连接</li><li><strong>SYN</strong>&#x3D;1 表示这是一个连接请求或者连接接受报文</li><li>FIN&#x3D;1 表示此段数据的发送端已经发送完毕最后一个数据段，并要求释放连接</li></ol><h2 id="TCP的有限状态机"><a href="#TCP的有限状态机" class="headerlink" title="TCP的有限状态机"></a>TCP的有限状态机</h2><p><img src="/../img/TCPFSM.png" alt="TCPFSM"></p><h2 id="三次握手："><a href="#三次握手：" class="headerlink" title="三次握手："></a><strong>三次握手：</strong></h2><ol><li>一开始，客户端和服务端都处于 <code>CLOSED</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态</li><li>客户端会随机初始化序号（<code>client_isn</code>），将此序号置于 TCP 首部的「序号」字段中，同时把 <code>SYN</code> 标志位置为 <code>1</code> ，表示 <code>SYN</code> 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code>SYN-SENT</code> 状态。</li><li>服务端收到客户端的 <code>SYN</code> 报文后，首先服务端也随机初始化自己的序号（<code>server_isn</code>），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 <code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code> 状态。</li><li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code> 标志位置为 <code>1</code> ，其次「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 <code>ESTABLISHED</code> 状态。<strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong></li><li>服务端收到客户端的应答报文后，也进入 <code>ESTABLISHED</code> 状态。</li></ol><p>SYN ：<em>Syn</em>chronize Sequence Numbers 即握手信号</p><h3 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手"></a><em><strong>为什么需要三次握手</strong></em></h3><ol><li>避免历史连接：由于网络阻塞导致或者客户端宕机导致发出两个SYN不同的连接报文，若只有两次握手，服务端会在收到第一次SYN报文后就进入ESTABLISHED状态发送数据，这就是历史连接。而真正有效的连接其实是第二次，所以第一次发送的数据就白白浪费了。如果有三次握手，相当于是给了服务器一个缓冲确认机会，确保没有历史连接。</li><li>同步双方序列号：最少三次握手，才能确保双方的初始序列号都被确认收到，从而建立可靠的同步</li><li>避免资源浪费：如果只有两次握手，服务器在收到SYN报文后就进入ESTABLISHED状态发送数据，而发送的数据不一定能保证能被客户端收到，所以三次握手可以确保双方都可以正确接收数据，避免浪费</li></ol><h3 id="为什么每建立一个新的连接都需要重新指定初始化序列号"><a href="#为什么每建立一个新的连接都需要重新指定初始化序列号" class="headerlink" title="为什么每建立一个新的连接都需要重新指定初始化序列号"></a><em><strong>为什么每建立一个新的连接都需要重新指定初始化序列号</strong></em></h3><p>如果没有重新指定序列号而是使用与上次连接一样的序列号，那么因为网络阻塞而延迟到达的历史报文就可能被新建立的连接正常接收，从而接收到错误的消息。计算机会基于一个算法来随机生成序列号，这个序列号会根据计时器递增，所以基本不可能出现“撞序列号”的情况。</p><h3 id="为什么要为TCP设立MSS？"><a href="#为什么要为TCP设立MSS？" class="headerlink" title="为什么要为TCP设立MSS？"></a><em>为什么要为TCP设立MSS？</em></h3><blockquote><p><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度</p></blockquote><p> IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。所以如果分片只依靠IP数据报的MTU，<strong>那么当如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传</strong>。由 IP 层进行分片传输，是非常没有效率的。为了达到最佳的传输效能 TCP 协议在<strong>建立连接的时候通常要协商双方的 MSS 值</strong>，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。</p><h2 id="握手过程中的超时重传"><a href="#握手过程中的超时重传" class="headerlink" title="握手过程中的超时重传"></a>握手过程中的超时重传</h2><ol><li>第一次握手丢失：如果客户端迟迟收不到SYN-ACK报文，证明第一次的握手报文丢失，需要进行超时重传，<strong>重传的 SYN 报文的序列号都是一样的</strong>，使用指数后退机制，每次超时重传时间是上一次的2倍，最后一次的等待时间是32秒，之后客户端会断开连接</li><li>第二次握手丢失：如果服务器收到了第一次握手报文，但是服务器发送的SYN-ACK报文丢失了。此时就会出现一个比较复杂的情况：客户端会觉得自己第一次握手丢失，服务器因为收不到第三次握手会认为自己的第二次握手丢失了。所以<strong>双方都会触发重传</strong>，如果其中一方的重传次数超过最大次数，就会断开连接。</li><li>第三次握手丢失：当客户端发出最后一个ACK报文后，就会进入ESTABLISHED状态。但是当服务器迟迟没有收到时，就会触发重传，重传第二次握手报文，直到握手成功或者超过最大次数。<strong>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文，所以这里是由服务器来重传而不是客户端</strong></li></ol><p><img src="/../img/TCPFSM1.png" alt="TCPFSM1"></p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a><strong>四次挥手</strong></h2><ol><li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li><li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSE_WAIT</code> 状态。</li><li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li><li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li><li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li><li>服务端收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li><li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。</li></ol><p><strong>主动进行关闭的一方才会有time_wait状态</strong></p><h3 id="为什么需要四次挥手"><a href="#为什么需要四次挥手" class="headerlink" title="为什么需要四次挥手"></a><em>为什么需要四次挥手</em></h3><p>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</p><p>服务端收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送</p><p>等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接</p><p><strong>简而言之就是在FIN_WAIT2状态下，客户端仍然需要处理网路中未收取完的数据</strong>，所以需要多确认一次来确保双方都已经完成数据的收发，可以彻底关闭连接</p><h2 id="握手过程中的超时重传-1"><a href="#握手过程中的超时重传-1" class="headerlink" title="握手过程中的超时重传"></a>握手过程中的超时重传</h2><ol><li>第一次挥手丢失：当客户端没有接收到服务器的ACK报文时，就无法进入FIN_WAIT2状态，所以就会进行重传，同样的指数后退机制，直到超过阈值，客户端会直接断开连接</li><li>第二次挥手丢失：如果服务器的第二次握手丢失了，由于ACK报文是不会重传的，所以这次还是由客户端重传，超过阈值时，会直接断开连接</li><li>第三次挥手丢失：在FIN_WAIT2阶段，当服务器发完所有数据后，便会发送FIN报文，若该报文丢失，服务端就会重发 FIN 报文，这与客户端重发 FIN 报文的重传次数控制方式是一样的。</li><li>第四次挥手丢失：当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 <code>TIME_WAIT</code> 状态，但是若服务器迟迟没有收到ACK报文，就会一直处于LAST_ACK阶段，由于ACK报文不会重传，服务端就会重传FIN报文。当然由于TIME_WAIT阶段时长为2MSL，所以超过这个时间便会断开连接</li></ol><p><strong>特别注意，如果客户端是由close函数关闭的，那么其处于FIN_WAIT2的时长是有限制的，如果迟迟未收到服务器的FIN报文便会自动断开连接</strong></p><h3 id="为什么TIME-WAIT的时长设置为2MSL"><a href="#为什么TIME-WAIT的时长设置为2MSL" class="headerlink" title="为什么TIME_WAIT的时长设置为2MSL"></a><em>为什么TIME_WAIT的时长设置为2MSL</em></h3><blockquote><p>MSL：即报文最大生存时间</p><p>MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 <strong>MSL 应该要大于等于 TTL 消耗为 0 的时间</strong>，以确保报文已被自然消亡</p></blockquote><p>TIME_WAIT 等待 2 倍的 MSL，因为<strong>一来一回需要等待 2 倍的时间</strong>。比如，如果服务器没有收到断开连接的最后的 ACK 报文，就会触发超时重发 <code>FIN</code> 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。 这其实是相当于<strong>至少允许报文丢失一次</strong>。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。</p><p>为什么不是 4 或者 8 MSL 的时长：如果有一个丢包率达到百分之一的糟糕网络，连续两次丢包的概率其实也只有万分之一，这个概率实在是太小了，2倍是一个折中的选择。如果TIME_WAIT过长，会占用大量网络IO资源。</p><h3 id="为什么我们需要TIME-WAIT"><a href="#为什么我们需要TIME-WAIT" class="headerlink" title="为什么我们需要TIME_WAIT"></a><em>为什么我们需要TIME_WAIT</em></h3><ol><li><p>防止历史连接的数据，被新的连接错误接收：因为TIME_WAIT时间设置为2MSL，所以可以保证历史连接的数据报都消失，再出现的数据报都一定是新连接产生的</p></li><li><p>保证服务端能被正确的关闭，TIME_WAIT的作用就是等待足够的时间以确保最后的ACK可以被服务器收到，总而帮助其正常关闭</p></li><li><p>CLOSED 没有任何连接状态</p></li><li><p>LISTEN 侦听状态，等待来自远方TCP端口的连接请求 </p></li><li><p>SYN-SENT 在发送连接请求后，等待对方确认 </p></li><li><p>SYN-RECEIVED 在收到和发送一个连接请求后，等待对方确认 </p></li><li><p>ESTABLISHED 代表传输连接建立，双方进入数据传送状态 </p></li><li><p>FIN-WAIT-1 主动关闭,主机已发送关闭连接请求，等待对方确认 </p></li><li><p>FIN-WAIT-2 主动关闭,主机已收到对方关闭传输连接确认，等待对方发送关闭传输连接请求 </p></li><li><p>TIME-WAIT 完成双向传输连接关闭，等待所有分组消失 </p></li><li><p>CLOSE-WAIT 被动关闭,收到对方发来的关闭连接请求，并已确认 </p></li><li><p>LAST-ACK 被动关闭,等待最后一个关闭传输连接确认，并等待所有分组消失</p></li><li><p>CLOSING 如果通信双方同时发送FIN数据包，则同时进行关闭操作，则双方将同时进入TCP_CLOSING状态。 具体的，本地发送一个FIN数据包以结束本地数据包发送，如果在等待应答期间，接收到远端发送的FIN数据包，则本地将状态设置为TCP_CLOSING状态。 在接收到应答后，再继续装入到TCP_CLOSE_WAIT状态。</p></li></ol><h3 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h3><ol><li><strong>当cwnd &lt; ssthresh时，慢启动，指数增长</strong></li><li><strong>当cwnd &gt; ssthresh时，拥塞避免，线性增长</strong></li><li><strong>出现三个冗余确认，快速恢复，ssthresh &#x3D; cwnd&#x2F;2 ; cwnd &#x3D; ssthresh+3*MSS；此后每收到一个冗余ACK就增加一个MSS，直到收到正确的ACK，cwnd&#x3D;ssthresh,进入慢增长</strong></li><li><strong>出现timeout，ssthresh &#x3D; cwnd&#x2F;2 ; cwnd &#x3D; 1MSS</strong></li></ol><h2 id="TCP可靠传输机制的保证："><a href="#TCP可靠传输机制的保证：" class="headerlink" title="TCP可靠传输机制的保证："></a>TCP可靠传输机制的保证：</h2><ol><li><p>检验和：用于检验一个分组中的比特错误</p></li><li><p>定时器：用于超时检验，发生超时事件时重传</p></li><li><p>序号：为一系列分组编号，可以检测出丢失分组以及冗余分组</p></li><li><p>ACK：用于告诉发送方分组被正确接收</p></li><li><p>NAK：用于告诉发送方分组未被正确接收</p></li><li><p>窗口：发送方被限制发送的序号范围</p></li></ol><h4 id="GBN-回退N步-go-back-N"><a href="#GBN-回退N步-go-back-N" class="headerlink" title="GBN 回退N步 go-back-N"></a>GBN 回退N步 go-back-N</h4><p>将序号队列分为四部分</p><ol><li>已被确认</li><li>窗口内：已发送，未被确认</li><li>窗口内：可用，未发送</li><li>不可用</li></ol><p>若窗口内某一序号n的ACK timeout，则需要重传n之后的所有分组</p><p>当接收到正确序号的ACK时，窗口便前移一个序号</p><p>0123 +rcv ack0 &#x3D;&gt; 1234</p><p>1234 +rcv ack1 &#x3D;&gt; 2345</p><p>ack2 timeout &#x3D;&gt;re_send (2345)</p><p>接受方无buffer，失序分组会被丢弃，所以需要重发来重新确认顺序</p><h4 id="选择性重传SR-selective-repeat"><a href="#选择性重传SR-selective-repeat" class="headerlink" title="选择性重传SR selective repeat"></a>选择性重传SR selective repeat</h4><p>接收方添加buffer，按序提交给上层</p><p>发送方只重发没有确认的分组</p><p>为每一个分组都添加timer，缓冲区的存在可以暂存失序但正确的分组</p><p>待重传分组到达并恢复顺序后，再统一交付给上层</p><h3 id="TCP协议存在什么缺陷？"><a href="#TCP协议存在什么缺陷？" class="headerlink" title="TCP协议存在什么缺陷？"></a>TCP协议存在什么缺陷？</h3><ol><li>存在队头阻塞的问题，必须保证缓存内的数据报全部到达且有序，才能向上层交付，否则会被一直阻塞</li><li>网络迁移时需要重新进行握手建立连接</li><li>连接建立需要较长的时延</li></ol><h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a><em>TCP和UDP的区别</em></h2><ol><li>通信即时性：UDP协议的双方随时都可以进行通信，而TCP协议的双方必须经过三次握手后才能通信，并且要经过四次挥手才能断开连接</li><li>对象不同：UDP是面向报文的，接收来自应用层的数据直接加上首部就发送，数据是有边界的，而TCP是将应用层的数据看作字节流，为其设立缓存，没有边界，保证顺序和可靠。</li><li>通信数量不同：UDP支持单播，多播，广播；TCP只支持单播</li><li>数据的安全性不同：网络层以上提供的都是不可靠的传输协议，UDP也是。而TCP保证了可靠传输，解决了丢失，乱序等问题</li><li>报文大小不同：UDP首部结构简单，8字节；而TCP报文首部有20字节，最大可达60字节。</li></ol><h2 id="如何使UDP可靠"><a href="#如何使UDP可靠" class="headerlink" title="如何使UDP可靠"></a>如何使UDP可靠</h2><p>运输层不能改变，网络层及下层都无法保证可靠，所以需要从应用层来保证可靠</p><p>核心出发点：在应用层模仿TCP的可靠性传输</p><p>如：</p><ol><li>添加添加seq&#x2F;ack机制，确保数据发送到对端</li><li>添加发送和接收缓冲区，主要是用户超时重传</li><li>添加超时重传机制</li></ol><p>送端发送数据时，生成一个随机seq&#x3D;x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack&#x3D;x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。</p><p>只不过都是由应用层的软件来实现的，比如使用UDP数据包+序列号，UDP数据包+时间戳等方法，在服务器端进行应答确认机制。</p><p>比如RUDP或者RTP都是基于UDP实现的可靠传输协议。</p><h2 id="QUIC协议"><a href="#QUIC协议" class="headerlink" title="QUIC协议"></a>QUIC协议</h2><p>HTTP3弃用TCP后，使用了<strong>基于UDP</strong>的QUIC协议，使用UDP实现了TCP+TLS的特性，且仅需一次握手即可建立可靠连接（<strong>0-RTT 握手</strong>）</p><p>QUIC协议基本解决了TCP协议存在的缺陷</p><p><img src="/../img/QUIC.png" alt="QUIC"></p><h3 id="如何实现可靠传输"><a href="#如何实现可靠传输" class="headerlink" title="如何实现可靠传输"></a>如何实现可靠传输</h3><ol><li>包号PKN+确认应答SACK来保证确认接收和数据有序性</li><li>滑动窗口：应用层实现</li><li>拥塞控制：应用层实现</li></ol><p><strong>应用层实现的功能可以拥有很快的更新速度，因为可以随浏览器更新，而不会受到操作系统内核的限制</strong></p><h3 id="如何避免队头阻塞"><a href="#如何避免队头阻塞" class="headerlink" title="如何避免队头阻塞"></a>如何避免队头阻塞</h3><p>由于TCP为了保证数据的有序到达，只有保证缓冲区数据有序，窗口才能滑动，否则只能重传并等待。停留「发送窗口」会使得发送方无法继续发送数据；停留「接收窗口」会使得应用层无法读取新的数据。</p><p>HTTP&#x2F;2 通过抽象出 Stream 的概念，实现了 HTTP 并发传输，一个 Stream 就代表 HTTP&#x2F;1.1 里的请求和响应，多个Stream使用一个TCP连接，不同 Stream 的帧是可以乱序发送的（因此可以并发不同的 Stream ），因为每个帧的头部会携带 <strong>Stream ID</strong> 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息，而同一 Stream 内部的帧必须是严格有序的。</p><p><strong>但是 由于HTTP&#x2F;2 多个 Stream 请求都是在一条 TCP 连接上传输，这意味着多个 Stream 共用同一个 TCP 滑动窗口，其实还是没有跳出滑动窗口的逻辑，当发生数据丢失，滑动窗口是无法往前移动的，此时就会阻塞住所有的 HTTP 请求，这属于 TCP 层队头阻塞</strong>。</p><p>QUIC 也借鉴 HTTP&#x2F;2 里的 Stream 的概念，但是 <strong>QUIC 给每一个 Stream 都分配了一个独立的滑动窗口，这样使得一个连接上的多个 Stream 之间没有依赖关系，都是相互独立的，各自控制的滑动窗口</strong>。</p><p>假如 Stream2 丢了一个 UDP 包，也只会影响 Stream2 的处理，不会影响其他 Stream，与 HTTP&#x2F;2 不同，HTTP&#x2F;2 只要某个流中的数据包丢失了，其他流也会因此受影响。</p><h3 id="如何实现更快的连接建立和连接迁移"><a href="#如何实现更快的连接建立和连接迁移" class="headerlink" title="如何实现更快的连接建立和连接迁移"></a><em>如何实现更快的连接建立和连接迁移</em></h3><p>由于此前TCP和TLS属于不同的协议，所以需要分批次来握手</p><p>而QUIC 协议并不是与 TLS 分层，而是<strong>内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果</strong></p><p>基于TCP+TLS的传输协议在IP地址发生改变时，需要断开连接并重新建立连接，迁移成本较高。</p><p>而QUIC协议会为客户端和服务器指定连接ID，因此即使 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，达到了<strong>连接迁移</strong>的功能。</p><h2 id="为什么QQ使用的是UDP协议"><a href="#为什么QQ使用的是UDP协议" class="headerlink" title="为什么QQ使用的是UDP协议"></a>为什么QQ使用的是UDP协议</h2><p>登陆和保持连接状态采用TCP，和好友之间发送消息采用UDP，内网传文件采用了P2P</p><ol><li>当时没有epoll这种可以支持成千上万tcp并发连接的技术，所以使用了应用层封装后的UDP来解决大并发的问题。后面也懒得修改</li><li>国内网络环境水平参差复杂，特别是在千禧年，带宽窄且抖动厉害，此时TCP的等待握手反而会成为劣势，占用宝贵的时间资源和性能资源</li><li>UDP的特性，即时封装即时发送，所以在在应用层的控制下，可以更快地探测和重传。</li></ol><p>QQ如何实现可靠：使用上层协议来实现可靠，如果客户端使用UDP协议发出消息后，服务器收到该包，需要使用UDP协议发回一个应答包。如此来保证消息可以无遗漏传输</p><h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><p>超文本传输协议，基于TCP实现</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>可靠</li><li>简单快速：客户向服务器请求服务时，只需传输方法和路径</li><li>灵活：支持任意类型的数据</li><li>无状态，无持久化</li></ol><h4 id="请求指令"><a href="#请求指令" class="headerlink" title="请求指令"></a>请求指令</h4><ol><li>GET：从服务器获取一个资源</li><li>PUT：将来自客户端的资源存储到服务器中</li><li>POST：将客户端数据发送到服务器应用程序中去</li><li>DELETE：从服务器中删除资源</li><li>HEAD：仅发送HTTP首部</li></ol><p>GET和POST的区别：</p><ol><li>get通过URL传输数据，比如以字段&#x3D;value的形式，以？和&amp;连接。传输少量数据，URL是可见的，可能会泄漏信息。</li><li>POST可以传输大量数据，且支持标准字符集，可以正确传输中文字符</li><li>前者着重于获取资源，后者着重于发送数据</li></ol><h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><p>响应报文都会携带一个状态码来告知请求报文的状态</p><ol><li>200：正确返回</li><li>302：重定向</li><li>404：没找到</li></ol><h2 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h2><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><ol><li>起始行：请求指令，URL，HTTP版本号</li><li>首部：描述浏览器可以接受的字符集，编码方式，期望的语言</li><li>主体：可能会有，也可能没有</li></ol><h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><ol><li>起始行：版本号，状态码</li><li>首部：返回的数据类型，长度等信息</li><li>主体：二进制流</li></ol><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>身份标识：向服务器表明自己的身份</p><p>Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</p><p>Cookie存储的数据量有限，且都是保存在<strong>客户端浏览器</strong>中，大小一般不超过4kb</p><p><img src="/../img/cookie.png" alt="cookie"></p><p>在服务器发送响应后，会顺带将Set-Cookie也发送给客户端。</p><p>当客户端保存后，之后给服务器发送请求时，都会在请求中包含Cookie的头部</p><p>应用：判断用户是否已经登录网站，购物车</p><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>当用户登录时，发送用户名和密码后，服务端查询数据库是否存在该用户，如果有的话，会自动生成一个sessionid，用于记录登录的时间、状态、属于哪个用户，过期时间等信息，并将这些信息<strong>保存在服务端</strong></p><p>同时，将这些信息通过<strong>cookie的形式</strong>将这些数据返回给客户端</p><p>当用户再次登录该服务器，访问其他接口的时候，会自动带上sessionid，服务器接收到请求后会自动查询有没有存储这个sessionid的信息</p><p><img src="/../img/session.png" alt="session"></p><p>Cookie和Session的区别：</p><ol><li>Session因为存储在服务器上，所以安全性比Cookie更高。</li><li>Cookie中只能存储ASCII字符串，如果是略微复杂的信息如java 对象，unicode字符串，比较艰难，需要进行编码，而session可以存取任意类型的数据，包括java对象</li><li>隐私策略不同：cookie对客户端可见，客户端的程序是可以窥探到cookie的。而session对客户端是不可见的。</li><li>cookie的过期时间可以设置得很长，而session因为存储在服务器上，出于性能的考虑，不能将存活时间设置得太长</li><li>当并发量高的时候，session的资源消耗会很高，而cookie就不会给服务器造成太大压力</li></ol><p>存在的问题</p><ol><li>存储在服务器，消耗大量的存储资源</li><li>查询速度会成为瓶颈，导致响应速度慢</li><li>在跨端、跨服务器时，需要session同步</li><li>通过架设数据库集群redis，会导致维护成本高，配置复杂</li></ol><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>服务器不存储用户数据，而是直接通过加密的方式把用户数据通过令牌的方式返回给客户端，该令牌将会由服务器自己设置。</p><p>每次用户访问时，都会携带这个令牌，用来证明自己的身份，从而得到自己的状态和数据。</p><p>服务器不需要存储用户资源导致资源占用过多的问题，也不需要每次查询从而加快了响应速度，而且传递的方式也由双方协定，不管是否跨域，都可以正常传递。</p><p><img src="/../img/token.png" alt="token"></p><p>但是，这种token容易被伪造，因为只要任何人拿到了这种令牌都可以称自己是合法的用户</p><p>从而获取一些私密的信息，此时如果服务器能拥有某种方式使得能证明该用户是合法的就显得极为重要</p><p><strong>sign</strong>:由服务端进行设置，且只有服务器知道签名和密钥。</p><p>当用户登录时，服务器提取将用户信息（payload）和header组成新的数据，然后再加上sign进行加密得到一个token。</p><p>当用户发起请求后，由服务器对sign进行解密，然后再结合自己设置的sign进行对比，如果一致，就证明该token合法，如果不一致，该token就是非法的</p><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>是token的一个实现形式，全称为JSON Web Token，本质是一个字符串，他将用户的信息保存到一个json字符串中，然后进行编码后得到一个<code>JWT token</code>，<strong>并且这个<code>JWT token</code>带有签名信息，接收后可以校验是否被篡改</strong></p><p>JWT的优势：</p><ol><li>数据量小，传输速度快</li><li>以JSON加密保存，跨语言</li><li>不依赖于cookie和session，适合于分布式微服务</li></ol><h3 id="JWT的结构"><a href="#JWT的结构" class="headerlink" title="JWT的结构"></a>JWT的结构</h3><h4 id="header"><a href="#header" class="headerlink" title="header"></a>header</h4><p>头部是一个描述JWT元数据的JSON对象</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;alg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;HS256&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//签名使用的算法</span><br>  <span class="hljs-attr">&quot;typ&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;JWT&quot;</span><span class="hljs-comment">//令牌名称</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h4><p>有效载荷，提供七个可选字段：</p><p><code>iss</code>：发行人 <code>exp</code>：到期时间 <code>sub</code>：主题 <code>aud</code>：用户 <code>nbf</code>：在此之前不可用 <code>iat</code>：发布时间 <code>jti</code>：JWT ID用于标识该JWT</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;sub&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1234567890&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Helen&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;admin&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h4><p>签名哈希部分是对上面两部分数据签名，需要使用base64编码后的header和payload数据，通过指定的算法生成哈希，以确保数据不会被篡改。</p><p>首先，需要指定一个密钥（secret）。该密钥仅仅为保存在服务器中，并且不能向用户公开。</p><p>然后，使用header中指定的签名算法（默认情况下为HMAC SHA256）根据以下公式生成签名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">HMACSHA256(base64UrlEncode(header)+<span class="hljs-string">&quot;.&quot;</span>+base64UrlEncode(payload),secret);<br></code></pre></td></tr></table></figure><p>在计算出签名哈希后，JWT头，有效载荷和签名哈希的三个部分组合成一个字符串，每个部分用<code>.</code>分隔，就构成整个JWT对象</p><p><img src="/../img/JWT.png" alt="JWT"></p><p>注意JWT每部分的作用，在服务端接收到客户端发送过来的JWT token之后：</p><p>header和payload可以直接利用base64解码出原文，从header中获取哈希签名的算法，从payload中获取有效数据<br>signature由于使用了<strong>不可逆的加密算法</strong>，无法解码出原文，它的作用是<strong>校验token有没有被篡改</strong>。</p><p>服务端获取header中的加密算法之后，利用该算法加上secretKey对header、payload进行加密，比对加密后的数据和客户端发送过来的签名是否一致，注意secretKey只能保存在服务端。</p><p>对于不同的加密算法secretKey含义有所不同，一般对于MD5类型的摘要加密算法，secretKey实际上代表的是盐值</p><h2 id="HTTP1-0和HTTP1-1的区别"><a href="#HTTP1-0和HTTP1-1的区别" class="headerlink" title="HTTP1.0和HTTP1.1的区别"></a>HTTP1.0和HTTP1.1的区别</h2><h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><p>​       HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启长连接keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p><h3 id="节约带宽"><a href="#节约带宽" class="headerlink" title="节约带宽"></a>节约带宽</h3><p>​       HTTP1.0中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。HTTP1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了节约了带宽。</p><h3 id="HOST域"><a href="#HOST域" class="headerlink" title="HOST域"></a>HOST域</h3><p>​       在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名，HTTP1.0没有host域。随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都支持host域，且请求消息中如果没有host域会报告一个错误（400 Bad Request）。</p><h3 id="缓存处理"><a href="#缓存处理" class="headerlink" title="缓存处理"></a>缓存处理</h3><p>​       在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</p><h3 id="错误通知的管理"><a href="#错误通知的管理" class="headerlink" title="错误通知的管理"></a>错误通知的管理</h3><p>​       在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p><h2 id="HTTP1-1和HTTP2-0的区别"><a href="#HTTP1-1和HTTP2-0的区别" class="headerlink" title="HTTP1.1和HTTP2.0的区别"></a>HTTP1.1和HTTP2.0的区别</h2><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>​HTTP2引入了帧和流的概念，将数据分成一个个的二进制形式的帧。帧上面除了 HTTP 数据，还包含数据长度、流标识符、帧类型等信息。而流就是一个建立连接后的双向的虚拟字节流，流具有并行性，即二进制帧都是并行传输的，无需按序等待。HTTP&#x2F;2 会将所有 HTTP 请求打散成帧，在一个 TCP 连接上做并发请求，充分利用 TCP 带宽。避免了队头阻塞。</p><h3 id="头部数据压缩"><a href="#头部数据压缩" class="headerlink" title="头部数据压缩"></a>头部数据压缩</h3><p>​       在HTTP1.1中，HTTP请求和响应都是由状态行、请求&#x2F;响应头部、消息主体三部分组成。一般而言，消息主体都会经过gzip压缩，或者本身传输的就是压缩过后的二进制文件，但状态行和头部却没有经过任何压缩，直接以纯文本传输。随着Web功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越大，HTTP2.0对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</p><h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p>​       服务端推送是一种在客户端请求之前发送数据的机制。网页使用了许多资源：HTML、样式表、脚本、图片等等。在HTTP1.1中这些资源每一个都必须明确地请求。这是一个很慢的过程。为了改善延迟，HTTP2.0引入了server push，它允许服务端推送资源给浏览器，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。</p><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>HTTP+SSL，是可加密的，身份认证的网络协议，更加安全</p><h2 id="SSL-x2F-TLS"><a href="#SSL-x2F-TLS" class="headerlink" title="SSL&#x2F;TLS"></a>SSL&#x2F;TLS</h2><p>HTTP的缺点：报文都是明文的，始终可见，安全性低</p><p>对称加密：双方使用同一种方式来加密和解密，如果加密的规则被破解，那么就不存在密文了</p><p>非对称加密：公钥加密后，必须由私钥解密；反之必须由公钥解密。</p><p>SSL证书：由CA颁发，拥有SSL证书的服务器就可以向客户端提供公钥，支持HTTPS连接</p><h1 id="计算机输入URL后会发生什么"><a href="#计算机输入URL后会发生什么" class="headerlink" title="计算机输入URL后会发生什么"></a><em><strong>计算机输入URL后会发生什么</strong></em></h1><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>客户端发起请求后，浏览器解析域名。首先浏览器会查看本地磁盘的host文件（已被舍弃），是否有对应的IP地址，如果有就直接使用</p><p>如果没有，就会发送一个<em><strong>DNS</strong></em>请求给本地的DNS服务器，本地DNS服务器会查询缓存记录，如果缓存存在，就直接返回结果。如果没有，使用<em><strong>迭代查询</strong></em>，本地DNS服务器逐个请求：根服务器-&gt;顶级域名服务器-&gt;权威域名服务器，最后获得IP地址，存入缓存。获取IP地址后，向目的地址主机的<em><strong>80端口</strong></em>发送请求报文。</p><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p><em><strong>TCP</strong></em>的三次握手，运输层接收应用层的数据并封装为TCP报文，交给网络层</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>若该主机为第一次接入该家庭网络或者其他私网，那么在发送TCP报文前还需要借助基于UDP的<em><strong>DHCP</strong></em>协议来获取源IP地址。</p><p>DHCP使用以0.0.0.0为源地址，255.255.255.255为广播地址，向<em><strong>67端口</strong></em>发送发现报文。DHCP服务器接收到后便会向客户端做出响应，最终客户端会收到DHCP ACK报文，其中包含IP地址以及租用期。</p><p>其中对于家庭网络或者其他私网，为了与广域网中的其他子网进行数据传输，还需要借助<em><strong>NAT</strong></em>协议，即网络地址转换，对外：将子网内的IP地址统一转换为在广域网内通信的IP地址；对内：借助NAT转换表将分组转发给内部主机。</p><p>网络层接收TCP报文，将其封装为IP数据报，以<em><strong>IPV4</strong></em>协议为例，IPV4数据报包含了32位的目的和源地址，header总大小为20字节，如果数据报大于了链路层所能承载的最大单元MTU，就要进行<em><strong>数据报分片</strong></em>。</p><p>主机通过<em><strong>ICMP</strong></em>协议获取网络层的传输状态，若目的网络不可达，路由器便会向客户端发送类型为3的ICMP报文来指示错误，其中ICMP报文封装在IP数据报中。</p><p>网络层使用路由器来实现分组交换：每个路由器内部都会动态维护一张<em><strong>转发表</strong></em>，遵循最长前缀匹配原则来找到输出链路，其中转发路径由<em><strong>路由选择算法</strong></em>来实现。</p><p>若使用的是IPV6协议，网络层的整个运输链路只要存在使用IPV4的节点，就需要进行处理，比如将IPV6封装在IPV4数据报内，进行兼容传输。</p><p>网络层关注的是主机到主机或者主机到路由器，链路传输的管理就交给链路层。</p><h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><p>IP数据报被包装为链路层帧，帧使用<em><strong>CRC</strong></em>即循环冗余检测来进行差错检测，使用多路访问协议来避免出现帧碰撞。</p><p>CRC的原理：多项式编码，双方协商好一个多项式，在数据的二进制编码后加上r个零，并使用异或除法除以该多项式，将获得的余数加在数据后，检测时使用这个多项式异或除，若余数为0，则证明无差错。</p><p>多路访问协议：信道划分+随机接入，ALOHA，CSMA</p><p>其中链路层的数据传输依靠<em><strong>MAC</strong></em>地址，MAC地址是扁平化的，即一个网卡就对应一个MAC地址，不会改变，也不会动态分配分层，类似于一个人的DNA。IP地址与MAC地址的转换依靠地址解析协议ARP，MAC地址与IP地址的映射存储于<em><strong>ARP表</strong></em>中，当无法查询到映射时，便会使用MAC广播地址发送查询分组。比如若该主机第一次接入该网络，则需要使用广播帧来获取网关路由器的MAC地址</p><p>链路层的以太网帧转发依赖于<em><strong>链路层交换机</strong></em>：同样具有转发表，交换机具有自学习的特性，若长时间未收到以表内某个地址作为源地址的帧，就会删除该表项，保证转发表内存放的都是高频率使用的表项。</p><h2 id="最终"><a href="#最终" class="headerlink" title="最终"></a>最终</h2><p><strong>经过DHCP获取IP地址</strong>-&gt;<strong>ARP查询广播获取网关地址</strong>-&gt;<strong>DNS服务器获取目的IP地址</strong>-&gt;<strong>运输层包装TCP报文</strong>-&gt;<strong>路由选择</strong>-&gt;<strong>TCP三次握手</strong>建立可靠连接后</p><p>应用便可以向该域名发送HTTP GET报文，最终获取到HTTP响应，应用抽取HTML文件，显示到浏览器上。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap</title>
    <link href="/post/HashMap.html"/>
    <url>/post/HashMap.html</url>
    
    <content type="html"><![CDATA[<h1 id="HashCode"><a href="#HashCode" class="headerlink" title="HashCode"></a><code>HashCode</code></h1><p>HashCode()，在未被重写前，即object类中，是一个Native方法，默认返回JVM生成的随机数，是一个独特值，可以看作是对象的身份ID</p><p>而在String类中，HashCode被重写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> hash;<br>       <span class="hljs-keyword">if</span> (h == <span class="hljs-number">0</span> &amp;&amp; value.length &gt; <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-type">char</span> val[] = value;<br><br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; value.length; i++) &#123;<br>               h = <span class="hljs-number">31</span> * h + val[i];<br>           &#125;<br>           hash = h;<br>       &#125;<br>       <span class="hljs-keyword">return</span> h;<br>   &#125;<br></code></pre></td></tr></table></figure><p><em><strong>为什么使用31作为乘数？？？</strong></em></p><ol><li>31是一个不大不小的奇质数，如果选择偶数计算，会导致乘积运算时的数据溢出。如果选择一个很小的数，那么<code>hashcode</code>会分布在一个很小的范围内，容易造成哈希值的冲突；如果选择一个很大的数，那么可能会超出整型变量的范围。</li><li>在二进制中31等于2&lt;&lt;5-1，那么<code>31*i</code>即为<code>（i&lt;&lt;5）-i</code>，这种乘积运算可以直接通过位移来提升性能，JVM也支持这种优化方式</li><li>不止31，33，37，39，41也可以作为乘数，当我们使用超过50,000个 单词来计算<code>hashcode</code>，这5个乘数都得到的哈希值冲突都小于7，31最小。同时hash的目的就是让数据尽可能分散排布，而以31作为乘数得到的结果分布最为均匀。</li></ol><h3 id="HashMap如何计算索引值"><a href="#HashMap如何计算索引值" class="headerlink" title="HashMap如何计算索引值"></a>HashMap如何计算索引值</h3><h4 id="第一步：计算hash"><a href="#第一步：计算hash" class="headerlink" title="第一步：计算hash"></a>第一步：计算hash</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br><span class="hljs-comment">//将key的hashCode值 与 key的hashCode值的高16位(无符号右移)，进行^异或运算，得到一个hash值</span><br></code></pre></td></tr></table></figure><p>原理：引入扰动函数</p><p>扰动函数就是为了增大随机性，减少碰撞，在引入扰动函数后散列表的数据分布更加均匀</p><h4 id="第二步：计算索引"><a href="#第二步：计算索引" class="headerlink" title="第二步：计算索引"></a>第二步：计算索引</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//n为数组长度从</span><br>index = hash &amp; (n-<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>一般的散列算法是以取余%来计算散列值的，但是CPU在做 &#x2F;除 或 %取余运算时，效率是很低的。</p><p>所以使用位运算<code>与</code>，可以实现相同的结果，而且效率更高。</p><h2 id="HashMap的容量"><a href="#HashMap的容量" class="headerlink" title="HashMap的容量"></a>HashMap的容量</h2><p>HashMap的初始化容量通常设置为2的幂次方大小，未指定大小时<strong>默认初始化为16</strong>，</p><p>这与<code>hash &amp; (n-1)</code>密切相关，<strong>2次幂大小的数与运算与取余运算的效果相同</strong></p><p>要减一，即n-1，我们才能获得一个01111这样的值（<strong>在和hash进行与运算的时候才可以获得范围合法的索引</strong>）</p><p>若指定一个奇数作为capacity，就会调用<code>tableSizeFor()</code></p><p>若传入17，向正方向寻找一个最接近17的2的幂次方，即为32</p><p>通过位移运算+或运算将17的每一位都改为1，然后再加1，最后就可以得到32</p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//负载因子</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<br></code></pre></td></tr></table></figure><p>负载因子就是一个阈值，当数据量超过这个阈值后，便要进行扩容</p><p>因为<code>hashcode</code>的特性，一个散列表地址可能对应多个元素，所以即使元素数量大于散列表地址数量，也可能出现无法把散列表占满的情况，在这种情况下，某些位置会出现碰撞，这降低了<code>HashMap</code>的性能</p><p>所以当散列表的位置使用到一定程度时，就需要进行扩容，默认0.75，也就是当使用3&#x2F;4后，就进行扩容</p><p><em><strong>为什么扩容时会直接乘以2</strong>：</em></p><ol><li>以2倍扩容的方式扩容，元素在新表中的位置要么不动，要么原脚标位+扩容长度（二的幂次方偏移量），这样会使扩容的效率大大提高（<strong>JDK1.8后扩容不用重新rehash</strong>）</li><li>可以使元素均匀的散布hashmap中，减少hash碰撞</li></ol><h3 id="转换红黑树的条件"><a href="#转换红黑树的条件" class="headerlink" title="转换红黑树的条件"></a><em>转换红黑树的条件</em></h3><ol><li>链表长度大于8</li><li>Entry数组大于64</li></ol><h3 id="HashCode-和equals-的关系，如何使用？"><a href="#HashCode-和equals-的关系，如何使用？" class="headerlink" title="HashCode()和equals()的关系，如何使用？"></a><em>HashCode()和equals()的关系，如何使用？</em></h3><ol><li>equals()来自Object()类，默认使用&#x3D;&#x3D;来比较地址值，判断引用指向是否是一个对象。通过重写该方法来定义新的规则，比如String类中的equals方法就是逐个比较字符串的字符</li><li>HashCode()来自Object()类，这是一个本地方法，在没有被重写时默认返回对象在堆内存上的独特值，可以认为是对象在堆内存中的身份证号，具有唯一性。重写HashCode后，可以返回计算而出的哈希值，即散列算法，用于确定元素的桶位置，例如HashMap</li><li>如何使用：查找一个元素，当调用散列算法后，快速定位到相应位置，若该桶内有元素，则调用equals()，由于哈希碰撞的存在，HashCode()相等时，不一定就是相应的元素，所以必须调用equals()来判断是否为要查找的元素</li></ol><h3 id="x3D-x3D-和equals的区别"><a href="#x3D-x3D-和equals的区别" class="headerlink" title="&#x3D;&#x3D;和equals的区别"></a><em>&#x3D;&#x3D;和equals的区别</em></h3><p>&#x3D;&#x3D;：若比较的是基本数据类型，则比较的是数值是否相等；如果比较的是引用数据类型，则比较的是地址值</p><p>equals()：用来比较引用指向的对象地址是否相等。不可用于基本数据类型的比较。</p><p>在Object类中，equals就是由&#x3D;&#x3D;来实现的，可以认为equals在被重写前，两者作用是相等的</p><h3 id="为何重写equals后一定要重写hashcode"><a href="#为何重写equals后一定要重写hashcode" class="headerlink" title="为何重写equals后一定要重写hashcode?"></a><em>为何重写equals后一定要重写hashcode?</em></h3><p>根据hashcode的规则，两个对象相等其哈希值一定相等</p><p>所以当重写equals后比如在String类中，两个字面量相同的字符串对象equals后一定返回true</p><p>但是如果不重写hashcode，默认返回JVM生成的独特值，此时两个对象的hashcode可能不会相等，与上文说的规则相矛盾。所以必须重写hashcode来符合这个规则</p><h3 id="HashMap为什么是线程不安全的"><a href="#HashMap为什么是线程不安全的" class="headerlink" title="HashMap为什么是线程不安全的"></a><em>HashMap为什么是线程不安全的</em></h3><ol><li>JDK1.7可能造成死循环：由于resize时的数据迁移采用头插法（当时的人觉得比较高效），而头插法会导致链表顺序颠倒（因为先插入的元素在后面），当线程A未完成transfer操作时被挂起，而线程B成功完成了transfer操作，线程A再次获取时间片后继续执行transfer，由于头插法导致链表顺序颠倒，便有可能导致生成环形链表。</li><li>JDK1.8可能造成数据丢失：假设两个线程A、B都在进行put操作，并且hash函数计算出的插入下标是相同的，当线程A执行过程中由于时间片耗尽导致被挂起，而线程B得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程A获得时间片，由于之前已经进行了hash碰撞的判断，所有此时不会再进行判断，而是直接进行插入，这就导致了线程B插入的数据被线程A覆盖了，从而线程不安全。</li></ol><h3 id="HashMap如何保证线程安全"><a href="#HashMap如何保证线程安全" class="headerlink" title="HashMap如何保证线程安全"></a><em>HashMap如何保证线程安全</em></h3><ol><li>Collections.synchronizedMap()方法传入HashMap的引用变量，返回一个新的Map，这个新的Map就是线程安全的，返回的并不是HashMap，而是map的一种实现。该方法封装了所有不安全的HashMap方法，使用了synchronized方法来进行互斥，和HashTable差不多，该方法使用代理模式new了一个新的类，这个类实现了Map接口。该方法的优点：实现简单；缺点：加锁的粒度较大，性能比较差。被synchronizedMap()包裹的map是可以传入null 键的。而concurrentHashmap不可以。</li><li>使用ConcurrentHashMap，使用了新的锁机制，把hashmap拆分成了多个独立的块，这样在高并发的情况下减少了锁冲突的可能。使用的是NonfairSync，这个特性调用CAS指令来保证原子性和互斥性。如果多个线程恰好操作到同一个segment，只有一个线程得到运行。优点：互斥的代码段小，性能更好，发生锁碰撞的几率低。缺点：代码繁琐。</li></ol><h1 id="ConcurrenHashMap和HashTable"><a href="#ConcurrenHashMap和HashTable" class="headerlink" title="ConcurrenHashMap和HashTable"></a>ConcurrenHashMap和HashTable</h1><p>HashTable它的每一个方法都是使用了synchronized同步锁机制，将整个入口锁起来，在多线程的情况下，他整个数组结构的入口就只能一条线程执行完成之后其他线程才能进入，无论下标是否相同，是否存在hash碰撞。</p><p>而ConcurrenHashMap由JDK1.5引入，降低了锁粒度且保证了线程安全</p><p>HashEntry内的成员变量value等都是<strong>volatile类型</strong>的，这样就保证别的线程对value值的修改，get方法可以马上看到</p><p>在JDK1.7之前，在初始化ConcurrentHashMap的时候，会初始化一个Segment数组,容量为<strong>16</strong>，Segment内部有一个table数组，存储entry数组+链表的结构</p><p>每个Segment都继承了ReentrantLock类，也就是说每个Segment类本身就是一个锁，使用了分段锁的机制，降低了锁粒度。</p><p>在查找时，定位segment和定位table后，依次扫描这个table元素下的的链表，要么找到元素，要么返回null。</p><p>在JDK1.8之后，引入红黑树且取消了segment设计。使用synchronize关键字，为每一个node对象加同步锁，将锁的粒度将到最低。</p><h1 id="TreeMap和HashMap"><a href="#TreeMap和HashMap" class="headerlink" title="TreeMap和HashMap"></a>TreeMap和HashMap</h1><p><em><strong>为什么HashMap是无序的？</strong></em></p><p>在对HashMap元素进行遍历的时候，是以数组下标为顺序，若该slot下存在链表和红黑树，则向下遍历，直到遍历完该slot下的所有元素。</p><p>众所周知，出现哈希冲突而存放在链表中的元素是不会按照顺序排放的，所以HashMap无序。</p><p>而<strong>TreeMap</strong> 的底层数据结构是一棵红黑树，红黑树上的元素都是有顺序的</p><p><em><strong>TreeMap如何实现排序？</strong></em></p><p>当使用无参构造时<code>TreeMap treeMap = new TreeMap();</code>，默认是升序的</p><p>但是TreeMap的构造方法可以传入一个Comparator对象，重写其中的Compare方法就可以定于以何种规则排序key</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//按照key字母顺序排序</span><br>TreeMap&lt;String,Integer&gt; treeMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;String,Integer&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Object o1, Object o2)</span> &#123;<br>                <span class="hljs-keyword">return</span> ((String)o1).compareTo((String)o2);<br>            &#125;<br>&#125;);<br><span class="hljs-comment">//Compare方法的原理：返回-1，无需交换元素，返回1，交换元素</span><br></code></pre></td></tr></table></figure><p>HashMap：适用于Map插入，删除，定位元素；</p><p>TreeMap：适用于按自然顺序或自定义顺序遍历键（key）,性能不如HashMap</p><h1 id="LinkedHashMap和HashMap"><a href="#LinkedHashMap和HashMap" class="headerlink" title="LinkedHashMap和HashMap"></a>LinkedHashMap和HashMap</h1><p><img src="/../img/linkedHashmap.png" alt="linkedHashmap"></p><p>简单的说，LinkedHashMap其实就是在HashMap的基础上再维护了一个双向链表，来保持顺序性</p><p>这个顺序默认是<strong>插入顺序</strong>，可以将其看作是实现hashmap查找效率的链表</p><p>可以通过设置accessOrder设置为访问顺序</p><p>accessOrder默认为false，当设置为true时，会在每次get或put后将元素移动至双向链表尾部（LRU）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用linkedHashMap模拟实现LRU</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-type">int</span> cap;<br>    LinkedHashMap&lt;Integer,Integer&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cap = capacity;<br>    &#125;<br>    <span class="hljs-comment">//加入链表尾部</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeRecently</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> cache.get(key);<br>        cache.remove(key);<br>        cache.put(key,val);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span>(!cache.containsKey(key)) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        makeRecently(key);<br>        <span class="hljs-keyword">return</span> cache.get(key);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span>(cache.containsKey(key))&#123;<br>            cache.put(key,value);<br>            makeRecently(key);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cache.size() &gt;= <span class="hljs-built_in">this</span>.cap)&#123;<br>            <span class="hljs-comment">//找到链表头部的key,就是最久未使用的key,调用一次next()就是第一个元素</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">toBeRemoved</span> <span class="hljs-operator">=</span> cache.keySet().iterator().next();<br>            cache.remove(toBeRemoved);<br>        &#125;<br>        cache.put(key,value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>买股票问题</title>
    <link href="/post/%E4%B9%B0%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98.html"/>
    <url>/post/%E4%B9%B0%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98.html</url>
    
    <content type="html"><![CDATA[<h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h2><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。<br>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出，最大利润 = 6-1 =<span class="hljs-number"> 5 </span>。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-comment">//dp数组，dp[i][j],今天是第i天，交易状态为j，利润为dp[i][j];</span><br>        <span class="hljs-type">int</span>[][] dp =<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-comment">//base case</span><br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)&#123;<br>                dp[i][<span class="hljs-number">0</span>] =<span class="hljs-number">0</span>;<br>                dp[i][<span class="hljs-number">1</span>] = -prices[i];<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//0代表已卖出，手中无股票；1代表未卖出，手中持有股票</span><br>            dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+prices[i]);<br>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>],-prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h2><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：prices = [7,1,5,3,6,4]<br>输出：7<br>解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 3 </span>天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 =<span class="hljs-number"> 5 </span>-<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 4 </span>。<br>     随后，在第<span class="hljs-number"> 4 </span>天（股票价格 = 3）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 =<span class="hljs-number"> 6 </span>-<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 3 </span>。<br>     总利润为<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 7 </span>。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//特殊之处：可以进行无数次买卖，所以在进行一次买入时可能总利润已经为正数</span><br>    <span class="hljs-comment">//而只能进行一次买卖的情况下，在买入前的总利润只能为零</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)&#123;<br>                dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>                dp[i][<span class="hljs-number">1</span>] = -prices[i];<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+prices[i]);<br>            <span class="hljs-comment">//区别在这里</span><br>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]-prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123. 买卖股票的最佳时机 III"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></h2><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">最多进行两笔交易<br>输入：prices = [3,3,5,0,0,3,1,4]<br>输出：6<br>解释：在第<span class="hljs-number"> 4 </span>天（股票价格 = 0）的时候买入，在第<span class="hljs-number"> 6 </span>天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 =<span class="hljs-number"> 3 </span>。<br>     随后，在第<span class="hljs-number"> 7 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 8 </span>天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 =<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//因为限制了买卖次数，所以需要一个三维的dp数组来进行穷举和状态转移</span><br>    <span class="hljs-comment">//k代表到第i天内，可以最多进行k次交易</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max_k</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][max_k+<span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=max_k;k&gt;<span class="hljs-number">0</span>;k--)&#123;<br>                <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)&#123;<br>                    dp[i][k][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>                    dp[i][k][<span class="hljs-number">1</span>] = -prices[i];<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                dp[i][k][<span class="hljs-number">0</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>] + prices[i]);<br>                <span class="hljs-comment">//在买入的时候进行k的状态转移，因为一次买入就代表一次交易的开始</span><br>                dp[i][k][<span class="hljs-number">1</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][k-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>][max_k][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188. 买卖股票的最佳时机 IV"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></h2><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">自定义k的情况<br>输入：k = 2, prices = [2,4,1]<br>输出：2<br>解释：在第<span class="hljs-number"> 1 </span>天 (股票价格 = 2) 的时候买入，在第<span class="hljs-number"> 2 </span>天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 =<span class="hljs-number"> 2 </span>。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//需要对k进行判断，若k大于某个值便按照无限次来计算，避免了超时的情况</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span>prices.length;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(k&gt;n/<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> ifKequalsInfinite(prices);<br>        <span class="hljs-type">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][k+<span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-comment">//当k=0时，取一些永远不可能的特殊值</span><br>            dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>            dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -<span class="hljs-number">666</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=k;j&gt;<span class="hljs-number">0</span>;j--)&#123;<br>                <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)&#123;<br>                    dp[i][j][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>                    dp[i][j][<span class="hljs-number">1</span>] = -prices[i];<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                dp[i][j][<span class="hljs-number">0</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>],dp[i-<span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>]+prices[i]);<br>                <span class="hljs-comment">//如果要保证今天可以进行一次交易，那么到昨天的总交易次数最大只能为j-1，留下一次给今天</span><br>                dp[i][j][<span class="hljs-number">1</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]-prices[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-comment">//当k足够大时，看作无限大</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">ifKequalsInfinite</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span>&#123;<br>         <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> == -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// base case</span><br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>            dp[i][<span class="hljs-number">1</span>] = -prices[i];<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);<br>        dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode初见</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="/post/Spring.html"/>
    <url>/post/Spring.html</url>
    
    <content type="html"><![CDATA[<h1 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h1><p>Bean的创建分为三个基本步骤</p><ol><li>实例化：可以理解为new一个对象，<code>AbstractAutowireCapableBeanFactory</code>中的<code>createBeanInstance</code>方法</li><li>属性注入：可以理解为setter方法完成属性注入，<code>AbstractAutowireCapableBeanFactory</code>的<code>populateBean</code>方法</li><li>初始化：按照Spring的规则配置一些初始化的方法，例如实现AOP代理，注解。<code>AbstractAutowireCapableBeanFactory</code>的<code>initializeBean</code>方法</li></ol><p>而Bean的完整生命周期就是在上面三个步骤中穿插执行<code>BeanPostProcessor</code>后置处理器的过程</p><p><img src="/../img/bean1.png" alt="bean1"></p><p>普通Java对象可以理解为它是用Class对象作为「模板」进而创建出具体的实例，而Spring所管理的Bean不同的是，除了Class对象之外，还会使用<code>BeanDefinition</code>的实例来描述对象的信息，比如说，我们可以在Spring所管理的Bean有一系列的描述：@Scope、@Lazy等等。可以理解为：Class只描述了类的信息，而<code>BeanDefinition</code>描述了对象的信息。</p><p>​Spring在启动的时候需要「扫描」在<code>XML/注解/JavaConfig</code> 中需要被Spring管理的Bean信息，随后，会将这些信息封装成<code>BeanDefinition</code>，最后会把这些信息放到一个<code>beanDefinitionMap</code>中，key是<code>beanName</code>，value则是<code>BeanDefinition</code>对象，目前真实对象还没实例化，接着会遍历这个<code>beanDefinitionMap</code>，执行<code>BeanFactoryPostProcessor</code>这个Bean工厂后置处理器</p><p>​比如说，我们平时定义的占位符信息，就是通过<code>BeanFactoryPostProcessor</code>的子类<code>PropertyPlaceholderConfigurer</code>进行注入进去，我们也可以自定义<code>BeanFactoryPostProcessor</code>来对我们定义好的Bean元数据进行获取或者修改</p><p>​<code>BeanFactoryPostProcessor</code>后置处理器执行完了以后，就到了实例化对象，在Spring里边是通过<strong>反射</strong>来实现的，一般情况下会通过反射选择合适的构造器来把对象实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//反射创建</span><br><span class="hljs-type">Constructor</span> <span class="hljs-variable">ctor</span> <span class="hljs-operator">=</span> Class.getDeclareConstructor();<br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ctor.newInstance();<br></code></pre></td></tr></table></figure><p>​实例化只是把对象给创建出来，而对象具体的属性是还没注入的，比如我的对象是UserService，而UserService对象依赖着SendService对象，这时候的SendService还是null的，使用<code>populateBean()</code>进行属性注入，这里便会牵扯出<strong>循环依赖</strong>的问题</p><p>​属性注入后会判断该Bean是否实现了Aware相关的接口，如果存在则填充相关的资源，<code>invokeAwareMethod()</code>，进行<code>BeanName</code>，<code>BeanFactory</code>，<code>BeanClassLoader</code>属性设置</p><p>​Aware相关的接口处理完之后，就会到<code>BeanPostProcessor</code>后置处理器，<code>BeanPostProcessor</code>后置处理器有两个方法，一个是before，一个是after</p><p>​<code>BeanPostProcessor</code>相关子类的before方法执行完，则执行init相关的方法，比如说<code>@PostConstruct</code>、实现了<code>InitializingBean</code>接口、定义的<code>init-method</code>方法</p><p>​init方法执行完之后，就会执行<code>BeanPostProcessor</code>的after方法，AOP就在此实现（关键子类<code>AnnotationAwareAspectJAutoProxyCreator</code>），基本重要的流程已经走完了，我们就可以获取到对象去使用了</p><p><img src="/../img/bean.jpg" alt="bean"></p><h1 id="对IOC的理解"><a href="#对IOC的理解" class="headerlink" title="对IOC的理解"></a>对IOC的理解</h1><p>控制反转：一种编程思想，即讲对象交给spring容器来帮我们进行管理。</p><p>DI：依赖注入，把对应的值注入到具体的对象中，即@Autowired或者populateBean</p><p>容器：存放对象，使用Map结构来存储，在spring中一般存在三级缓存，singletonObject存放完整的Bean对象，bean的整个生命周期，从创建到销毁都是由容器来管理。</p><h1 id="AOP是如何实现的"><a href="#AOP是如何实现的" class="headerlink" title="AOP是如何实现的"></a>AOP是如何实现的</h1><p>AOP是IOC的一个扩展功能，现有IOC，再有AOP，AOP是IOC整个流程的一个扩展点</p><ol><li>advice:切面的工作被描述为通知</li><li>Joinpoint：动态代理所代理实现类中的各个方法称为连接点</li><li>Pointcut：代理类中真正增强的方法</li><li>Aspect：将通知用到切入点的过程叫切面</li></ol><p>在bean的创建过程中有一个步骤可以对bean进行扩展实现，beanPostProcessor后置处理，而AOP就是其中一个扩展</p><ol><li>代理对象的创建（advice，切面，切点）</li><li><strong>通过JDK或者CGLIB的方式来生成代理对象</strong></li><li>在执行方法调用的时候，会调用到生成的字节码文件中，会调用DynamicAdvisoredInterceptor类中的intercept方法，从此方法开始执行</li><li>根据之前定义好的通知生成拦截器</li><li>按照拦截器链中以此获取每一个通知，开始进行执行</li></ol><h1 id="循环依赖和三级缓存"><a href="#循环依赖和三级缓存" class="headerlink" title="循环依赖和三级缓存"></a>循环依赖和三级缓存</h1><p>所谓的<code>循环依赖</code>，就是两个或则两个以上的<code>bean</code>互相依赖对方，最终形成<code>闭环</code></p><p>比如“A对象依赖B对象，而B对象也依赖A对象”，或者“A对象依赖B对象，B对象依赖C对象，C对象依赖A对象”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">private</span> B b;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-keyword">private</span> A a;<br>&#125;<br></code></pre></td></tr></table></figure><p>在常规情况下，会出现以下情况</p><ol><li>通过构建函数创建A对象（A对象是<strong>半成品</strong>，还没注入属性和调用init方法）。</li><li>A对象需要注入B对象，发现<strong>对象池</strong>里还没有B对象（对象在创建并且注入属性和初始化完成之后，会放入对象缓存里）。</li><li>通过构建函数创建B对象（B对象是半成品，还没注入属性和调用init方法）。</li><li>B对象需要注入A对象，发现对象池里还没有A对象。</li><li>创建A对象，循环以上步骤。</li></ol><p>解决循环依赖的最核心思想：<em><strong>提前曝光</strong></em></p><p>将半成品A提前放入缓存池，从而可以让B对象成功完成属性注入和初始化，成品B可以让半成品A完成初始化，从而打破了循环依赖</p><ol><li>通过构建函数创建A对象（A对象是半成品，还没注入属性和调用init方法）。</li><li>A对象需要注入B对象，发现缓存里还没有B对象，将<code>半成品对象A</code>放入<code>半成品缓存</code>。</li><li>通过构建函数创建B对象（B对象是半成品，还没注入属性和调用init方法）。</li><li>B对象需要注入A对象，从<code>半成品缓存</code>里取到<code>半成品对象A</code>。</li><li>B对象继续注入其他属性和初始化，之后将<code>完成品B对象</code>放入<code>完成品缓存</code>。</li><li>A对象继续注入属性，从<code>完成品缓存</code>中取到<code>完成品B对象</code>并注入。</li><li>A对象继续注入其他属性和初始化，之后将<code>完成品A对象</code>放入<code>完成品缓存</code>。</li></ol><h2 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//一级缓存：存放成品bean</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">256</span>);<br><br><span class="hljs-comment">//二级缓存，存放半成品bean，提前曝光的核心</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);<br><br><span class="hljs-comment">//三级缓存，存放bean工厂对象，用来生成半成品bean并存入二级缓存中</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);<br></code></pre></td></tr></table></figure><p>直接看流程图：</p><p><img src="/../img/SpringCache.png" alt="SpringCache"></p><p><em><strong>问：这里的第三级缓存有什么用？</strong></em></p><p>如果我们不考虑AOP的情况下，第三级缓存真没什么用，它直接将实例化阶段创建的对象给返回了。</p><p>如果我们考虑上了AOP，那么流程图会变成：</p><p><img src="/../img/SpringCache1.png" alt="SpringCache1"></p><p>我们对A进行了<code>AOP</code>代理的话，那么此时<code>getEarlyBeanReference</code>将返回一个代理后的对象，而不是实例化阶段创建的对象，这样就意味着B中注入的A将是一个代理对象而不是A的实例化阶段创建后的对象。</p><p><em><strong>问：初始化的时候是对A对象本身进行初始化，而容器中以及注入到B中的都是代理对象，这样不会有问题吗？</strong></em></p><p>不会，这是因为不管是<code>cglib</code>代理还是<code>jdk</code>动态代理生成的代理类，<strong>内部都持有一个目标类的引用</strong>，当调用代理对象的方法时，实际会去调用目标对象的方法，A完成初始化相当于代理对象自身也完成了初始化。</p><p><em><strong>问：三级缓存为啥要存一个工厂，而不是直接存一个引用进去呢？</strong></em></p><p>工厂的目的在于只有真正发生循环依赖的时候，才会去生成代理对象。如果未发生循环依赖，那么就只有一个工厂放那儿，<strong>但是不会去通过这个工厂去真正创建对象</strong>。</p><p><em><strong>问：为什么要使用第三级缓存呢，不管有没有循环依赖，我们都提前创建好代理对象，并将代理对象放入缓存，出现循环依赖时，其他对象直接就可以取到代理对象并注入。这样就只会使用两级缓存，不是更方便嘛？</strong></em></p><p>如果要使用二级缓存解决循环依赖，意味着Bean在构造完后就需要创建代理对象，这样<strong>违背了Spring设计原则</strong>！！</p><p>Spring结合AOP跟Bean的生命周期，是在Bean创建完全之后通过<code>AnnotationAwareAspectJAutoProxyCreator</code>这个<strong>后置处理器</strong>来完成的，在这个后置处理的<code>postProcessAfterInitialization</code>方法中对初始化后的Bean完成AOP代理。如果出现了循环依赖，那没有办法，只有给Bean先创建代理，但是没有出现循环依赖的情况下，设计之初就是让<strong>Bean在生命周期的最后一步完成代理</strong>而不是在实例化后就立马完成代理。</p><p><em><strong>使用二级缓存：</strong></em></p><p><img src="/../img/SpringCache3.png" alt="SpringCache3"></p><p><em><strong>使用三级缓存：</strong></em></p><p><img src="/../img/SpringCache2.png" alt="SpringCache2"></p><p><em><strong>总结：Spring如何解决循环依赖？</strong></em></p><p>答：Spring通过三级缓存解决了循环依赖，其中一级缓存为单例池（<code>singletonObjects</code>，一个并发HashMap）,二级缓存为早期曝光对象<code>earlySingletonObjects</code>，三级缓存为早期曝光对象工厂（<code>singletonFactories</code>），二三级缓存均为普通的HashMap。</p><p>当A、B两个类发生循环引用时，在A完成实例化后，就使用实例化后的对象去创建一个对象工厂，并添加到三级缓存中，如果A被AOP代理，那么通过这个工厂获取到的就是A代理后的对象，如果A没有被AOP代理，那么这个工厂获取到的就是A实例化的对象。</p><p>当A进行属性注入时，会去创建B，同时B又依赖了A，所以创建B的同时又会去调用getBean(a)来获取需要的依赖，此时的getBean(a)会从缓存中获取，第一步，先获取到三级缓存中的工厂；第二步，调用对象工工厂的getObject方法来获取到对应的对象，得到这个对象后将其注入到B中。紧接着B会走完它的生命周期流程，包括初始化、后置处理器等。</p><p>当B创建完后，会将B再注入到A中，此时A再完成它的整个生命周期。至此，循环依赖结束！</p><h1 id="JDK和CGLIB动态代理的区别"><a href="#JDK和CGLIB动态代理的区别" class="headerlink" title="JDK和CGLIB动态代理的区别"></a><code>JDK</code>和<code>CGLIB</code>动态代理的区别</h1><p><strong>JDK代理</strong>使用的是<strong>反射机制生成</strong>一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。</p><p><strong>CGLIB代理使用字节码处理框架ASM</strong>，对代理对象类的class文件加载进来，<strong>通过修改字节码生成子类。</strong></p><p>JDK创建代理对象效率较高，执行效率较低，JDK动态代理机制是委托机制，只能对实现接口的类生成代理，通过反射动态实现接口类。</p><p>CGLIB创建代理对象效率较低，执行效率高，CGLIB则使用的继承机制，针对类实现代理，被代理类和代理类是继承关系，所以代理类是可以赋值给被代理类的，因为是继承机制，不能代理final修饰的类。</p><p><strong>如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP</strong>，可以强制使用CGLIB实现AOP，如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换。</p><p><strong>JDK动态代理只能为接口创建代理，使用上有局限性。</strong>实际的场景中我们的类不一定有接口，此时如果我们想为普通的类也实现代理功能，我们就需要用到CGLIB来实现了。</p><p>JDK代理是不需要依赖第三方的库，只要JDK环境就可以进行代理，需要满足以下要求：<br> <strong>1.实现InvocationHandler接口，重写invoke()<br> 2.使用Proxy.newProxyInstance()产生代理对象<br> 3.被代理的对象必须要实现接口</strong></p><p>CGLIB 必须依赖于CGLIB的类库,需要满足以下要求：<br> <strong>1.实现MethodInterceptor接口，重写intercept()<br> 2.使用Enhancer对象.create()产生代理对象</strong></p><p>CGLIB是一个强大、高性能的字节码生成库，它用于在运行时扩展Java类和实现接口，本质上它是通过动态的生成一个子类去覆盖所要代理的类（非final修饰的类和方法）。</p><p>Enhancer既能够代理普通的class，也能够代理接口。Enhancer创建一个被代理对象的子类并且拦截所有的方法调用（包括从Object中继承的toString和hashCode方法）。Enhancer不能够拦截final方法，例如Object.getClass()方法，这是由于Java final方法语义决定的。基于同样的道理，Enhancer也不能对final类进行代理操作。</p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>Spring将JDBC的事务概念带到了业务层中，同样继承了ACID特性，同样也有四种隔离级别</p><p>只不过开启&#x2F;提交&#x2F;回滚的操作交给Spring来执行，而不用自行编码</p><p>一般只需一个注解<code>@Transactional </code>修饰方法。那么整个方法的代码块都将以事务的规则执行</p><h3 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h3><p>当事务方法被另外一个事务方法调用时，必须指定事务应该如何传播</p><p>例如，方法可能继续在当前事务中执行，也可以开启一个新的事务，在自己的事务中执行。</p><h4 id="REQUIRED"><a href="#REQUIRED" class="headerlink" title="REQUIRED"></a><code>REQUIRED</code></h4><p>如果外部方法开启事务并且是 REQUIRED 的话，所有 REQUIRED 修饰的内部方法和外部方法均属于同一事务 ，只要一个方法回滚，整个事务都需要回滚。如果外部方法没有开启事务的话，REQUIRED 修饰的内部方法会开启自己的事务，且开启的事务相互独立，互不干扰。</p><h4 id="REQUIRES-NEW"><a href="#REQUIRES-NEW" class="headerlink" title="REQUIRES_NEW"></a><code>REQUIRES_NEW</code></h4><p>不管外部方法是否开启事务，REQUIRES_NEW 修饰的内部方法都会开启自己的事务，且开启的事务与外部的事务相互独立，互不干扰。</p><h4 id="NESTED"><a href="#NESTED" class="headerlink" title="NESTED"></a><code>NESTED</code></h4><p>如果当前存在事务，就在当前事务内执行；否则，就执行与 REQUIRED 类似的操作。</p><h4 id="SUPPORTS"><a href="#SUPPORTS" class="headerlink" title="SUPPORTS"></a><code>SUPPORTS</code></h4><p>如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</p><h4 id="NOT-SUPPORTED"><a href="#NOT-SUPPORTED" class="headerlink" title="NOT_SUPPORTED"></a><code>NOT_SUPPORTED</code></h4><p>以非事务方式运行，如果当前存在事务，则把当前事务挂起。</p><h4 id="MANDATORY"><a href="#MANDATORY" class="headerlink" title="MANDATORY"></a><code>MANDATORY</code></h4><p>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</p><h4 id="NEVER"><a href="#NEVER" class="headerlink" title="NEVER"></a><code>NEVER</code></h4><p>以非事务方式运行，如果当前存在事务，则抛出异常。</p><h3 id="Spring事务的实现原理是什么？"><a href="#Spring事务的实现原理是什么？" class="headerlink" title="Spring事务的实现原理是什么？"></a><em>Spring事务的实现原理是什么？</em></h3><p>Spring有两种事务的实现方式，第一是编程式事务，即通过手动编码的方式，创建<code>TransactionTemplate</code>对象进行execute()传入业务代码或者<code>transactionManager</code>对象通过commit()提交业务代码来实现。第二就是声明式事务，即使用注解的形式直接拦截方法，基于AOP。编程式事务的粒度更小，是代码块级别的。而声明式事务的粒度稍大一些是整个方法。</p><p>事务操作是AOP的一个核心体现，当一个方法添加<code>@Transactional</code>后，Spring会基于这个类生成代理对象，当使用这个代理对象的方法时，如果有事务，那么会先关闭连接的autocommit，先执行业务逻辑。若无异常，代理逻辑就会提交。若出现异常，就会进行回滚操作。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JAVA进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL</title>
    <link href="/post/mySQL.html"/>
    <url>/post/mySQL.html</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>关系型数据库，插件式的存储引擎，这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p><ol><li>客户端通过协议与服务器连接，发送查询语句，先检查缓存是否命中，若命中直接返回，否则进行语句解析</li><li>预处理，检查语句是否有语法错误，查询优化（是否会使用索引扫描），生成查询计划，启动查询引擎，开始查询，底层存储引擎调用API获取数据，返回给客户端</li><li>MYSQL默认使用B+树索引</li></ol><h3 id="字段选择优先级（由优至劣）"><a href="#字段选择优先级（由优至劣）" class="headerlink" title="字段选择优先级（由优至劣）"></a>字段选择优先级（由优至劣）</h3><ol><li>整型</li><li>time：定长运算快</li><li>enum：枚举，能约束值，内部由整型存储</li><li>char：定长，需要考虑字符集</li><li>varchar：不定长，考虑字符集的转换与排序的校对集，速度慢</li><li>text：无法使用内存临时表</li></ol><p><em><strong>定长优先。能选整型就不要选字符串，够用就行，不要富余分配空间，尽量避免使用Null</strong></em></p><p>varchar最多可以定义65535个字节</p><h3 id="事务的ACID"><a href="#事务的ACID" class="headerlink" title="事务的ACID"></a>事务的ACID</h3><ol><li>原子性：要么全部成功，要么全部失败。由undo_log来保证</li><li>一致性：数据库总是从一个状态转移到另一个状态</li><li>隔离性：最终提交前，其他事务不可见，MVCC</li><li>持久性：事务一旦提交，修改将会永久保存到数据库中，内存+redo_log</li></ol><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><h3 id="1NF-第一范式"><a href="#1NF-第一范式" class="headerlink" title="1NF(第一范式)"></a>1NF(第一范式)</h3><p>属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。<strong>1NF 是所有关系型数据库的最基本要求</strong> ，也就是说关系型数据库中创建的表一定满足第一范式</p><blockquote><p><strong>如果关系表中的属性不可再细分且属性列不可重复，该关系满足第1范式</strong></p></blockquote><h3 id="2NF-第二范式"><a href="#2NF-第二范式" class="headerlink" title="2NF(第二范式)"></a>2NF(第二范式)</h3><p>2NF 在 1NF 的基础之上，消除了非主属性对于码的部分函数依赖。如下图所示，展示了第一范式到第二范式的过渡。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键</p><blockquote><p><strong>第二范式要求关系表中所有数据都要和关系表的主键有完全函数依赖（即属性不能只和主键有部分依赖关系）</strong></p></blockquote><h3 id="3NF-第三范式"><a href="#3NF-第三范式" class="headerlink" title="3NF(第三范式)"></a>3NF(第三范式)</h3><p>3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。符合 3NF 要求的数据库设计，<strong>基本</strong>上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求</p><blockquote><p><strong>每一个非主属性既不部分依赖于码也不传递依赖于码</strong></p></blockquote><ul><li>1NF：属性不可再分。</li><li>2NF：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。</li><li>3NF：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖</li></ul><h3 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h3><ol><li>read uncommitted：所有事务都可以看见未提交的结果，产生脏读</li><li>read committed：一个事务从开始到提交前，任何数据改变都是不可见的，产生不可重复读问题</li><li>repeatable read：<code>MySQL</code>默认的隔离级别，解决不可重复读问题，保证同一事物的多个实例在并发读取事务时，会读取到同样的数据行，产生幻读问题（<code>InnoDB</code>的MVCC解决了幻读问题）</li><li>serializable：最高级别的隔离，强制事务排序，不可能相互冲突，其实就是加锁，效率低</li></ol><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p><code>MyISAM</code>和<code>InnoDB</code>的区别是什么</p><ol><li><code>InnoDB</code>：支持事务，支持外键，聚集索引：文件存储于主键索引的叶子节点上，所以主键索引效率很高，但是辅助索引需要进行回表，并且主键不能过大，因为辅助索引也会存储主键，所以过大的主键会影响索引的大小。最小粒度锁为行锁</li><li><code>MyISAM</code>：不支持事务，不支持外键，非聚集索引，索引保存的是数据文件的指针，主键索引和辅助索引独立。会创建一个单独的变量保存整个表的行数，读取表行数的速度更快。最小粒度锁为表锁，并发性能不好。</li></ol><h2 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h2><p><img src="/../img/13526879-3037b144ed09eb88.png" alt="13526879-3037b144ed09eb88"></p><p>MySQL 主要由下面几部分构成：</p><ul><li><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li><li><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）</li></ul><blockquote><p>连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 SQL 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件</p><p><strong>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</strong></p></blockquote><ul><li><p><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</p></li><li><p><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</p></li><li><p><strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。</p></li><li><p><strong>日志模块：</strong>在server层是binlog归档日志模块</p></li><li><p><strong>插件式存储引擎</strong> ： 主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎</p></li><li><p><strong>查询语句的执行流程如下：权限校验（如果命中缓存）—&gt;查询缓存—&gt;分析器—&gt;优化器—&gt;权限校验—&gt;执行器—&gt;引擎</strong></p></li><li><p><strong>更新语句执行流程如下：分析器—-&gt;权限校验—-&gt;执行器—&gt;引擎—redo log(prepare 状态)—&gt;binlog—&gt;redo log(commit状态)</strong></p></li></ul><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p><em><strong>为什么要有索引</strong></em></p><p>一般的应用系统读写比例大约在10：1左右，而且数据的插入和更新出现性能问题的几率小于查询。在生产环境中，最容易出现问题的就是查询操作，因此对查询性能的优化就显得十分重要。</p><p>索引的本质就是一个满足某种查找算法的数据结构，常见的有BST，AVL，红黑树，Btree，B+树等等</p><p>这些结构以某种方式指向数据（索引结点指向数据记录物理地址的指针）</p><ol><li>索引大大减少了服务器需要扫描的数据量，提高了检索效率</li><li>避免排序，减少CPU消耗</li><li>将随机IO转换为顺序IO</li></ol><p>索引也是一张表，保存了主键和索引，指向了实体表，也需要占用内存。索引存储于外存，所以索引的查询也需要磁盘IO开销,访问外存的时间成本大约是内存的十万倍</p><p>虽然提高了查询速度，但是在对实体表进行更新时，索引也需要进行相应的维护更新，而索引的维护也需要开销，降低了更新表的速度</p><h3 id="HASH索引"><a href="#HASH索引" class="headerlink" title="HASH索引"></a>HASH索引</h3><p>Memory引擎默认Hash索引</p><p>等值查询很快，计算的hash值与对应的行指针一并存入表中，哈希碰撞的元素以链表的形式相连。也不支持排序，以及模糊查询，并且由于散列算法，键值对的存储是无序的，所以不支持范围查询。</p><h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h3><p><code>InnoDB</code>，<code>MyISAM</code>默认是B+树</p><p>考虑到IO时十分高昂的操作，且数据库动辄百万级数据量，所以当一次IO时，常常以页作为单位来读取数据，当读取一页的数据至内存缓冲区时，实际上才发生了一次IO，所以控制IO的次数对于索引效率的提升，至关重要。</p><p>B+树的特点：</p><ol><li>除叶子结点外的子节点：只起到索引的作用，仅存储指针，不存储信息</li><li>所有信息存储于叶子结点，所有叶子结点在底部链接形成一个双向链表（范围查询）</li></ol><p>在<code>InnoDB</code>中，叶子节点的容量默认为一页16KB</p><p><strong>叶子节点结构(聚簇索引为例)：页目录（主键）+用户数据区域（单向链表，通过主键排序，在插入数据的时候便会排序）</strong></p><p><strong>非叶子节点结构：页指针+指向的该页的最小主键值</strong></p><h3 id="MYSQL索引分类"><a href="#MYSQL索引分类" class="headerlink" title="MYSQL索引分类"></a><strong>MYSQL索引分类</strong></h3><ol><li>主键索引：一张表一个主键索引，通常与表一起创建。</li><li>唯一索引：如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。这么做的好处：一是简化了MySQL对这个索引的管理工作，这个索引也因此而变得更有效率；二是MySQL会在有新记录插入数据表时，如果字段的值已经出现过了，MySQL将拒绝插入那条新记录。也就是说，唯一索引可以保证数据记录的唯一性。事实上，在许多场合，人们创建唯一索引的目的往往不是为了提高访问速度，而只是为了避免数据出现重复。</li><li>普通索引：建立在普通字段上的索引，唯一任务是加快对数据的访问速度。因此，应该只为那些最经常出现在查询条件（WHEREc）或排序条件（ORDERBY）中的数据列创建索引。只要有可能，就应该选择一个数据最整齐、最紧凑的数据列（如一个整数类型的数据列）来创建索引。</li><li>复合索引：字符类型字段的前几个字符建立，可以覆盖多个数据列，遵循最左匹配原则，可能会因为order by失效。</li></ol><p>三星索引：衡量一个索引是否达到最佳表现的三个维度</p><ol><li>第一星：where后面的等值谓词，可以匹配索引列的顺序：意义在于谓索匹配的越多，索引片越窄，最终扫描的数据行也是越小。把 <strong>WHERE 后的等值条件列作为索引最开头的列，如此，必须扫描的索引片宽度就会缩至最短。</strong></li><li>第二星：order by的排序是否和索引的顺序一致：意义在于避免进行额外的排序，增加消耗。<strong>将 ORDER BY 列加入到索引中，保持列的顺序</strong></li><li>第三星：select的字段是否都为索引列：意义在于避免每一个索引行查询，都需要去聚簇索引进行一次随机IO查询。<strong>将查询语句中剩余的列都加入到索引中。</strong></li></ol><h3 id="普通索引和唯一索引有什么区别？"><a href="#普通索引和唯一索引有什么区别？" class="headerlink" title="普通索引和唯一索引有什么区别？"></a><em><strong>普通索引和唯一索引有什么区别？</strong></em></h3><p><strong>概念上的不同</strong>：普通索引可以重复。而唯一索引和主键一样，不可以重复，但在一张表里面只能有一个主键，不能为空，唯一索引可有多个。唯一索引可有一条记录为null。在学校，一般用学号做主键，身份证号作为唯一索引</p><p><strong>查询实现的不同</strong>：若查询语句为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> T <span class="hljs-keyword">where</span> k<span class="hljs-operator">=</span><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>普通索引：查找到满足条件的第一个记录后，继续查找下个记录，直到碰到第一个不满足k&#x3D;4的记录。</p><p>唯一索引：查到第一个满足条件的，就停止搜索。</p><p>若重复数据很多，普通索引多了一次“查找和判断下一条记录”的操作，可能会多次IO，但是总体性能其实差别不大</p><p><strong>更新性能不同</strong>：往表中插入一个新记录，<code>InnoDB</code>会有什么反应？</p><p>若在内存中，普通索引直接插入，而唯一索引会判断一次是否有冲突，再插入。判断的性能消耗可以不计</p><p>若不在内存中，普通索引会将数据记录在change buffer；唯一索引会将数据页读入内存再插入。众所周知数据库的IO成本很高，所以普通索引更新数据的性能是要更优的。</p><p><strong>总结：若更新性能优先级更高，选择普通索引。</strong></p><h2 id="主键索引-聚簇索引"><a href="#主键索引-聚簇索引" class="headerlink" title="主键索引(聚簇索引)"></a>主键索引(聚簇索引)</h2><p><img src="/../img/B+tree.png" alt="B+tree"></p><h2 id="二级索引-辅助索引"><a href="#二级索引-辅助索引" class="headerlink" title="二级索引(辅助索引)"></a><strong>二级索引(辅助索引)</strong></h2><p>同样是B+树，以非主键而是以自定义规则的索引，以满足不同的查询需求，属于非聚集索引。</p><p>叶子节点的用户数据区不再存储完整记录，而是存储<strong>主键+部分记录</strong>。</p><p>所以使用辅助索引有时候需要进行回表，即部分记录无法满足查询需求，需要使用主键来重新到主键索引查找。</p><h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>使用表中的多个字段创建索引，就是 <strong>联合索引</strong>，也叫 <strong>组合索引</strong> 或 <strong>复合索引</strong></p><p><em><strong>什么情况下设置了复合索引，但不会使用？</strong></em></p><ol><li>没有符合最左匹配原则</li><li>字段进行了隐私数据类型转化</li><li>引擎估算走辅助索引的时间反而比全表扫描的时间更长</li></ol><h3 id="什么是最左匹配原则？"><a href="#什么是最左匹配原则？" class="headerlink" title="什么是最左匹配原则？"></a><em><strong>什么是最左匹配原则？</strong></em></h3><p>对于复合索引，若有字段123，若查询时省略字段1，则无法使用索引。</p><p>因为数据库依据联合索引最左的字段来构建 B+ 树，叶子节点的排序是以字段123的顺序进行的，只有先确定了前一个（左侧的值）后，才能确定下一个值。a有序，b才能有序，若a省略，则无法有序查找bc。</p><p>所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据</p><h3 id="非聚簇索引的优缺点？"><a href="#非聚簇索引的优缺点？" class="headerlink" title="非聚簇索引的优缺点？"></a><em><strong>非聚簇索引的优缺点？</strong></em></h3><p>优点：<strong>更新代价比聚集索引要小</strong> 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的</p><p>缺点：</p><ol><li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li><li><strong>可能会二次查询(回表)</strong> :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询</li></ol><h3 id="聚簇索引的优缺点？"><a href="#聚簇索引的优缺点？" class="headerlink" title="聚簇索引的优缺点？"></a><em><strong>聚簇索引的优缺点？</strong></em></h3><p>优点：聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据</p><p>缺点：</p><ol><li><strong>依赖于有序的数据</strong> ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li><li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚集索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的</li></ol><h3 id="MYSQL默认使用B-树，为啥要用B-树，不用B树？"><a href="#MYSQL默认使用B-树，为啥要用B-树，不用B树？" class="headerlink" title="MYSQL默认使用B+树，为啥要用B+树，不用B树？"></a><em><strong>MYSQL默认使用B+树，为啥要用B+树，不用B树？</strong></em></h3><p>因为两者都是存储于磁盘，而IO是花销很大的操作，InnoDB每次申请磁盘空间时都会申请若干条连续的磁盘块来组成一页，并放入内存，读取索引，放回磁盘，不断重复，直到找到数据。</p><p>所以如果每次申请到的数据都能有助于定位到所需数据，这将会减少IO次数，提高查询效率。</p><p>对于B树，因为B树的每一个结点都会存储键，指针和数据，每个磁盘块的信息存储能力有限，树的高度也会更高，增加了IO次数，所以B树的查询效率波动很大。</p><p>而B+树的非叶子结点只存储键，所以B+树的非叶子结点可以存储更多的信息，降低了树高度，平均一次IO可以获取更多索引，所以B+树更适合外存索引，且查询效率更稳定</p><p>其中在 MySQL 底层对 B+ 树进行进一步优化：</p><p><strong>叶子节之间是双向链表，节点内部是单向链表，且在链表的头结点和尾节点也是循环指向的</strong>。（范围查询的关键）</p><h3 id="为什么不用红黑树？"><a href="#为什么不用红黑树？" class="headerlink" title="为什么不用红黑树？"></a><em><strong>为什么不用红黑树？</strong></em></h3><p>无论是二叉树还是红黑树，都会因为树的深度过深而导致IO次数变多，效率不高</p><h3 id="InnoDB一颗高度为3的B-树可以存放多少行数据？"><a href="#InnoDB一颗高度为3的B-树可以存放多少行数据？" class="headerlink" title="InnoDB一颗高度为3的B+树可以存放多少行数据？"></a><em><strong><code>InnoDB</code>一颗高度为3的B+树可以存放多少行数据？</strong></em></h3><p><code>InnoDB</code>的一页大小为16k，若一行数据的大小为1k，那么可以存储16行数据</p><p>若主键ID为<code>bigint</code>型，8字节，指针为6字节，总大小为14字节，那么一页可以存储1170个指针</p><p>所以数据量大约为1170  * 1170 *  16&#x3D; 大约两千万</p><h1 id="MySQL的锁"><a href="#MySQL的锁" class="headerlink" title="MySQL的锁"></a>MySQL的锁</h1><h2 id="按锁的属性分"><a href="#按锁的属性分" class="headerlink" title="按锁的属性分"></a>按锁的属性分</h2><p>共享锁：即读锁</p><p>排他锁：即写锁</p><h3 id="按锁的粒度分"><a href="#按锁的粒度分" class="headerlink" title="按锁的粒度分"></a>按锁的粒度分</h3><p>行级锁：锁住一行或者多行记录</p><p>表级锁：给整个表加锁</p><p>页级锁：介于行级锁和表锁的一种锁，一次锁定相邻的一组记录</p><p>记录锁：行级锁的一种，锁住一条记录，避免数据在查询时被修改的不可重复读问题</p><p>间隙锁：行级锁的一种，只出现在Repeatable read的事务中，解决了幻读的问题</p><p>临键锁：<code>InnoDB</code>的行锁默认算法，就是记录锁和间隙锁的结合版，会锁住查询的记录，同时也会锁住范围内的所有间隙空间</p><h3 id="按锁的状态分"><a href="#按锁的状态分" class="headerlink" title="按锁的状态分"></a>按锁的状态分</h3><p>意向共享锁</p><p>意向排他锁</p><h1 id="MySQL的主从同步"><a href="#MySQL的主从同步" class="headerlink" title="MySQL的主从同步"></a>MySQL的主从同步</h1><p>MySQL内建的复制功能是构建大型，高性能应用程序的基础。</p><p>将MySQL的数据分布到多个系统上去，这种分布的机制，是通过将MySQL的某一台主机的数据复制到其它主机（slave）上，并重新执行一遍来实现。</p><p>复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。</p><p>主服务器将更新写入二进制日志文件，并维护文件的一个索引以跟踪日志循坏，这些日志可以记录发送到从服务器的更新。</p><p>当一个从服务器连接主服务器时，它通知主服务器从服务器在日志中读取的最后一次成功更新的位置。从服务器接收从那时起发生的任何更新，然后封锁并等待主服务器通知的更新。</p><h2 id="MySQL支持哪些复制"><a href="#MySQL支持哪些复制" class="headerlink" title="MySQL支持哪些复制"></a>MySQL支持哪些复制</h2><ol><li>基于语句的复制：在主服务器上执行的sql语句，在从服务器上执行同样的语句。MySQL默认采用基于语句的复制，效率比较高。一旦发现没法精确复制时，会自动选着基于行的复制。</li><li>基于行的复制：把改变的内容复制过去，而不是把命令在从服务器上执行一遍。从MySQL 5.0开始支持</li><li>混合类型的复制：默认采用基于语句的复制，一旦发现基于语句的无法精确复制时，就会采用基于行的复制</li></ol><h2 id="为什么需要主从同步"><a href="#为什么需要主从同步" class="headerlink" title="为什么需要主从同步"></a>为什么需要主从同步</h2><ol><li>若出现锁表不能读的情况，此时可以使用主从复制，让主库负责写，从库负责读，这样就不影响业务的正常运行</li><li>当IO频率越来越大时，业务量越来越大时，单机已无法满足，此时多库的处理可以提高IO的性能</li></ol><h1 id="MySQL的锁机制"><a href="#MySQL的锁机制" class="headerlink" title="MySQL的锁机制"></a>MySQL的锁机制</h1><h2 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h2><p>记录锁是封锁这一条记录，阻止其他事务插入，更新，删除这一条记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> `test` <span class="hljs-keyword">WHERE</span> `id`<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br></code></pre></td></tr></table></figure><h2 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h2><p>间隙锁是封锁索引记录中的间隙，或者第一条索引记录之前或者之后的范围的数据，间隙锁面向的是范围，所以是<strong>左开右开区间</strong></p><p>产生条件：<strong>RR隔离级别</strong></p><p>对唯一索引进行操作：</p><ol><li>对于指定查询某一条记录的加锁语句，<strong>如果该记录不存在，会产生记录锁和间隙锁，如果记录存在，则只会产生记录锁</strong>，如：<code>WHERE id = 5 FOR UPDATE;</code></li><li>对于查找某一范围内的查询语句，会产生间隙锁，如：<code>WHERE id BETWEEN 5 AND 7 FOR UPDATE;</code></li></ol><p>对普通索引进行操作：</p><ol><li>在普通索引列上，<strong>不管是何种查询，只要加锁，都会产生间隙锁，这跟唯一索引不一样；</strong></li><li>在普通索引跟唯一索引中，数据间隙的分析，数据行是优先根据普通索引排序，再根据唯一索引排序。</li></ol><p>例如表中有6条记录，其中索引d分别为0，5，10，15，20，25</p><p>执行 <code>select * from t where d=5 for update</code>，就不止是给数据库中已 有的6个记录加上了行锁，还同时加了 7 个间隙锁。、</p><p>比如（0，5）区间内被加上间隙锁，这个区间内无法插入新记录，一定程度上避免了幻读，<strong>但是并没有完全解决幻读</strong>。</p><p><strong>在RC级别下，间隙锁会失效</strong></p><h2 id="临键锁"><a href="#临键锁" class="headerlink" title="临键锁"></a>临键锁</h2><p><strong>间隙锁和行锁合称临键锁（ next-key lock）</strong>，每个 next-key lock 是<strong>前开后闭区间</strong>，同样只在RR级别下有效</p><ol><li>若对存在的记录加锁，则会锁住前后两个区间的内容</li><li>若对不存在的记录加锁，则会锁住该记录所在区间的内容</li></ol><h1 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h1><p>Multi-Version Concurrency Control多版本并发控制，实现对数据库的并发访问，实现读写冲突不加锁，非阻塞并发读。</p><p>数据库的并发有三种场景</p><ol><li>读读：不存在任何问题，不需要并发控制</li><li>读写：有线程安全问题，可能会造成脏读，幻读，不可重复读等问题</li><li>写写：有线程安全问题，可能存在更新丢失的问题</li></ol><p>MVCC的实现原理就是为事务分配单项增长的时间戳，为每个修改保存一个版本，版本与时间戳相关联，解决了脏读，幻读，不可重复读的问题，但是不能解决更新丢失的问题，可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低</p><h3 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h3><p>也叫锁定读Locking Read，读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁，比如update 、delete 、insert</p><h3 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h3><p>也叫普通读Consistent Read，就是单纯的select语句，但不包括for update，就是不加锁的非阻塞读，前提是不使用serializable的隔离级别，实现原理即MVCC</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h3><p>每行记录除了自定义的字段外，还有数据库隐式定义的字段</p><p>DB_TRX_ID<br>6字节，最近修改事务的ID，即创建这条记录或者最后一次修改这条记录的事务ID</p><p>DB_ROLL_PTR</p><p>7字节，回滚指针，指向这条记录的上一个版本，用于配合undolog</p><p>DB_ROW_ID</p><p>6字节，隐藏的主键，如果数据表没有主键，innoDB就会自动生成一个row_id</p><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>即回滚日志，即进行插入，更新，删除操作后生成的记录链</p><p>当进行insert时，产生的undo log只在事务回滚的时候需要，可以在事务提交后被丢弃</p><p>当进行update和delete操作时，undo log不仅在事务回滚时需要，在快照读时也需要，所以必须保留，只有在回滚或者快照读不涉及该日志时，undo log才会被purge线程清除（若delete_bit为true，且DB_TRX_ID相对于purge线程的read view可见，那么这条记录就一定可以被清除）</p><p><img src="/../img/undolog.png" alt="undolog"></p><p>由上图可知，不同事物或者相同事物对同一条记录的修改，就会导致该记录的undolog生成一条记录版本的线性链，链首就是最新的旧记录，链尾就是最早的旧记录</p><h3 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h3><p>Read View是实现repeatable read的基础，当事务进行快照读的时候会产生一个读视图，用来对当前事务的可见性进行判断，也就是说，事务会将生成的Read View作为条件来判断当前事务能够看见哪个版本的数据，有可能读到最新的数据，也有可能读到undolog里面的某个版本的数据。</p><h4 id="Read-View的可见性算法"><a href="#Read-View的可见性算法" class="headerlink" title="Read View的可见性算法"></a>Read View的可见性算法</h4><p>Read View的三个全局属性：</p><ol><li>trx_list：事务列表，即视图生成时刻系统正活跃未提交的事务ID</li><li>up_limit_id：记录事务列表中ID最小的ID</li><li>low_limit_id：视图生成时刻系统尚未分配的下一个事务（例如事务123正在活跃，事务4已提交，此时下一个事务ID就是5）</li></ol><p>具体的算法如下</p><ol><li>取出当前最新记录的DB_TRX_ID，即当前事务ID</li><li>比较DB_TRX_ID&lt;up_limit_id，如果小于则说明当前事务能看见DB_TRX_ID所在的记录，如果大于等于就进入下一个判断</li><li>判断DB_TRX_ID&gt;&#x3D;low_limit_id，如果大于等于，代表DB_TRX_ID所在的记录在readView<strong>生成后才出现</strong>，对于当前事务肯定不可见，如果小于，进入下一个判断</li><li>判断DB_TRX_ID是否在活跃事务列表中，如果在，说明在视图生成时刻，该事务还没有提交，当前事务无法看见。若不在，说明以及提交，修改的结果可以看见（除自己以外的活跃trx_id都不可见）</li></ol><h4 id="RC，RR级别下的视图"><a href="#RC，RR级别下的视图" class="headerlink" title="RC，RR级别下的视图"></a>RC，RR级别下的视图</h4><p>在RR级别下某个事务对记录的第一次快照读会创建一个视图，此后在进行快照读时都会使用同一个视图，所以无论是否有其他事务对记录进行了修改，使用的都是这个视图，修改是不可见的，所以实现了可重复读的级别</p><p>在RC级别下，每次快照读都会生成一个新的视图，所以在RC级别下总是可以看见其他事务的提交</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>MVCC其实就是在事务进行并发读写时提供一个快照，事务只能看见符合可见性的版本链内的记录，从而实现了并发读写的隔离性。</p><h1 id="MVCC解决幻读了嘛"><a href="#MVCC解决幻读了嘛" class="headerlink" title="MVCC解决幻读了嘛"></a><em><strong>MVCC解决幻读了嘛</strong></em></h1><blockquote><p>幻读【前后多次读取，数据总量不一致】</p></blockquote><ol><li>快照读：快照读就是普通的select语句，通过MVCC的方式解决了幻读，MVCC为保证了事务执行过程中看到的数据是一致的，使用ReadView和可见性算法可以实现即使有新记录插入，当前事务也是看不到的。</li><li>当前读：除了select语句外的所有操作都是当前读，当前读使用<strong>临键锁来避免幻读</strong>，当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞。</li></ol><p>但是在RR级别下，仍然有一些情况会出现幻读</p><h3 id="第一种情况：同一事务，使用update导致快照读生成的ReadView被更改"><a href="#第一种情况：同一事务，使用update导致快照读生成的ReadView被更改" class="headerlink" title="第一种情况：同一事务，使用update导致快照读生成的ReadView被更改"></a>第一种情况：同一事务，使用update导致快照读生成的ReadView被更改</h3><ol><li>若在事务开始执行之前，表中是没有id&#x3D;5的这条记录的，所以查询不到</li><li>然后事务 B 插入一条 id &#x3D; 5 的记录，并且提交了事务</li><li>此时，<strong>事务 A 更新 id &#x3D; 5 这条记录</strong>，<strong>事务 A 看不到 id &#x3D; 5 这条记录，但是他去更新了这条记录</strong>，<strong>然后再次查询 id &#x3D; 5 的记录，事务 A 就能看到事务 B 插入的纪录了，幻读就是发生在这种违和的场景</strong>。</li></ol><p><img src="/../img/phantom.png" alt="phantom"></p><p>总结：</p><ol><li>在可重复读隔离级别下，事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，之后事务 B 向表中新插入了一条 id &#x3D; 5 的记录并提交。</li><li>接着，事务 A 对 id &#x3D; 5 这条记录进行了更新操作，在这个时刻，这条新记录的DB_TRX_ID的值就变成了事务 A 的事务 id。</li><li>之后事务 A  再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。</li></ol><p>因为这种特殊现象的存在，所以我们认为 <strong>MySQL Innodb 中的 MVCC 并不能完全避免幻读现象</strong>。</p><h3 id="第二种情况：同一事务，先快照读，再当前读导致幻读"><a href="#第二种情况：同一事务，先快照读，再当前读导致幻读" class="headerlink" title="第二种情况：同一事务，先快照读，再当前读导致幻读"></a>第二种情况：同一事务，先快照读，再当前读导致幻读</h3><ol><li>T1 时刻：事务 A 先执行快照读语句：<code>select * from t_test where id &gt; 100</code> 得到了 3 条记录。</li><li>T2 时刻：事务 B 往插入一个 id&#x3D; 200 的记录并提交；</li><li>T3 时刻：事务 A 再执行当前读语句<code>select * from t_test where id &gt; 100 for update</code> 就会得到 4 条记录，此时也发生了幻读现象。</li></ol><p><strong>要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句</strong>，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。</p><p><em><strong>总结：MVCC只能很大程度上避免幻读，但是个别情况下，仍然会发生幻读</strong></em></p><h1 id="MySQL调优"><a href="#MySQL调优" class="headerlink" title="MySQL调优"></a>MySQL调优</h1><p>代码优化：</p><ol><li>少使用select*，指定具体字段</li><li>尽量少使用order by排序，而使用联合索引</li><li>减少使用Null，有多个null的可以加默认值</li><li>where后少使用函数运算</li><li>避免超过五个以上的表连接</li></ol><p>SQL：</p><ol><li>对于高频筛选字段可以适当建立索引</li><li>一个表的索引不超过五个</li><li>联合索引，遵守最左匹配原则</li></ol><p><em><strong>如果MySQL出现慢查询，问题在哪？</strong></em></p><ol><li>索引失效或者无索引</li><li>强制查询不存在的字段，此时MySQL会查询整张表</li><li>两张表字符集不一样或者编码不一样，但是需要联表查询</li><li>多线程查询操作，若线程A查询了很大的一块数据，此时server正在返回A的查询结果并占用了所有的IO，线程B的查询性能就会受限</li></ol><p><em><strong>如何解决呢？</strong></em></p><ol><li>一次查询数量过于庞大，拆成多次查询、拼装</li><li>分离冷热数据，将大字段或者是查询频率少的数据分出一张新表</li><li><code>IN</code>子查询影响查询性能，用<code>JOIN</code>方式代替</li><li>用了反向查询（比如<code>NOT IN</code>）或者<code>IN</code>语句参数集太多，可能会导致全表扫描，这种情况尽量拆分语句</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>数据库基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>netty项目记录</title>
    <link href="/post/netty%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94react%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%AE%80%E8%BF%B0.html"/>
    <url>/post/netty%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94react%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%AE%80%E8%BF%B0.html</url>
    
    <content type="html"><![CDATA[<p>如何编写并启动一个服务端？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//指定bossGroup，也就是负责处理连接请求的线程</span><br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//指定workerGroup，也就是负责处理IO请求的线程</span><br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();  <span class="hljs-comment">//8个</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//创建启动类</span><br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>            <span class="hljs-comment">//链式编程为启动类加入线程，channel,handler</span><br>            bootstrap.group(bossGroup, workerGroup)<br>                    .channel(NioServerSocketChannel.class)<br>                    .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.INFO))<br>                <span class="hljs-comment">//为管道加入handler或者自定义的handler，netty扩展性的体现</span><br>                    .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            <span class="hljs-comment">//获取到pipeline</span><br>                            <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> socketChannel.pipeline();<br>                            <span class="hljs-comment">//因为是基于http协议，使用http的编码和解码器</span><br>                            pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpServerCodec</span>());<br>                            <span class="hljs-comment">//是以块方式写，添加 ChunkedWriteHandler 处理器</span><br>                            pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChunkedWriteHandler</span>());<br>                            <span class="hljs-comment">/*</span><br><span class="hljs-comment">                            说明：</span><br><span class="hljs-comment">                            1. http 数据在传输过程中是分段，HttpObjectAggregator，就是可以将多个报文段聚合</span><br><span class="hljs-comment">                            2. 这就是为什么，当浏览器发送大量数据时，就会发出多次http请求。</span><br><span class="hljs-comment">                             */</span><br>                            pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpObjectAggregator</span>(<span class="hljs-number">8192</span>));<br>                            <span class="hljs-comment">/*</span><br><span class="hljs-comment">                             * 说明：</span><br><span class="hljs-comment">                             *  1.对应websocket ，它的数据是以帧（frame）形式传播</span><br><span class="hljs-comment">                             *  2. 可以看到WebSocketFrame ，下面有六个子类</span><br><span class="hljs-comment">                             *  3. 浏览器请求时，ws://localhost:7000/hello 表示请求的uri</span><br><span class="hljs-comment">                             *  4. WebSocketServerProtocolHandler 核心功能是将 http协议升级为 ws 协议，保持长连接</span><br><span class="hljs-comment">                             *  5. 是通过一个状态码 101</span><br><span class="hljs-comment">                             */</span><br>                            pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocketServerProtocolHandler</span>(contentPath));<br>                            <span class="hljs-comment">//自定义的handler，处理业务逻辑</span><br>                            pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocketServerHandler</span>());<br>                        &#125;<br>                    &#125;);<br>            System.out.println(<span class="hljs-string">&quot;netty 服务器启动&quot;</span>);<br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.bind(port).sync();<br>            <span class="hljs-comment">//监听关闭</span><br>            channelFuture.channel().closeFuture().sync();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//关闭</span><br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自定义的handler</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSocketServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;TextWebSocketFrame&gt; &#123;<br>    <span class="hljs-comment">//定义一个channel组，管理所有的channel</span><br>    <span class="hljs-comment">//GlobalEventExecutor.INSTANCE 是全局的事件执行器，是一个单例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ChannelGroup</span> <span class="hljs-variable">channelGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultChannelGroup</span>(GlobalEventExecutor.INSTANCE);<br>    <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">//收到消息后触发的方法</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;服务器端收到消息&quot;</span>);<br>        <span class="hljs-comment">//获取到当前的channel</span><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> ctx.channel();<br>        <span class="hljs-comment">//这时我们遍历channelGroup，根据不同的情况，回送不同的消息</span><br>        channelGroup.forEach(ch -&gt; &#123;<br>            <span class="hljs-keyword">if</span>(channel != ch)&#123; <span class="hljs-comment">//不是当前的channel，转发消息</span><br>                <span class="hljs-comment">//将信息刷回客户端</span><br>                ch.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TextWebSocketFrame</span>(msg.text()));<br>            &#125;<br>        &#125; );<br>        <span class="hljs-comment">//回复消息</span><br>        <span class="hljs-comment">//ctx.channel().writeAndFlush(new TextWebSocketFrame(&quot;服务器事件&quot; + LocalDateTime.now() + &quot;  &quot; + msg.text()));</span><br>    &#125;<br>    <span class="hljs-comment">//当web客户端连接后，触发方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//id表示唯一的值，LongText 是唯一的 ShortText 不是唯一</span><br>        <span class="hljs-comment">//System.out.println(&quot;handlerAdded 被调用&quot; + ctx.channel().id().asLongText());</span><br>        <span class="hljs-comment">//System.out.println(&quot;handlerAdded 被调用&quot; + ctx.channel().id().asShortText());</span><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> ctx.channel();<br>        <span class="hljs-comment">//将该客户加入聊天的信息推送给其他在线的客户端</span><br>        <span class="hljs-comment">//该方法会将 channelGroup 中所有的channel 遍历，并发送消息，我们不需要自己遍历</span><br>        <span class="hljs-comment">//channelGroup.writeAndFlush(new TextWebSocketFrame(&quot;[客户端]&quot; + channel.remoteAddress() + &quot;加入聊天&quot;</span><br><span class="hljs-comment">//                      + sdf.format(new Date()) + &quot;\n&quot;));</span><br>        channelGroup.add(channel);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlerRemoved</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;handlerRemoved 被调用&quot;</span> + ctx.channel().id().asLongText());<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;异常发生&quot;</span> + cause.getMessage());<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>netty基础</title>
    <link href="/post/netty%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html"/>
    <url>/post/netty%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html</url>
    
    <content type="html"><![CDATA[<h2 id="为什么我们不用Java-NIO？"><a href="#为什么我们不用Java-NIO？" class="headerlink" title="为什么我们不用Java NIO？"></a><em><strong>为什么我们不用Java NIO？</strong></em></h2><p>原生的Java NIO编程，对编程能力要求比较高，需要处理连接异常、网络闪断、拆包粘包、网络拥塞、长短连接等各种各样的网络通讯细节问题，这是一件非常困难且耗时的事情。并且，原生Java NIO还有一个臭名昭著的<em><strong>Epoll Bug</strong></em>，它会导致Selector空轮询，最终导致CPU 100%。官方声称在JDK 1.6版本的update 18修复了该问题，但是直到JDK1.7版本该问题仍旧存在，只不过该Bug发生概率降低了一些而已，它并没有被根本解决。</p><h2 id="Netty和Tomcat有什么区别？"><a href="#Netty和Tomcat有什么区别？" class="headerlink" title="Netty和Tomcat有什么区别？"></a><em><strong>Netty和Tomcat有什么区别？</strong></em></h2><p>Netty是一个基于NIO的异步网络通信框架，性能高，<strong>封装了原生NIO</strong>，降低了编码复杂度。</p><p>Tomcat是一个Web服务器，是一个Servlet容器，内部只运行Servlet程序并处理HTTP请求。</p><p>Netty封装的是IO模型，用于处理网络数据的传输，不关心具体的协议，其定制性更高</p><h1 id="reactor线程模型"><a href="#reactor线程模型" class="headerlink" title="reactor线程模型"></a>reactor线程模型</h1><p>reactor就是IO多路复用（NIO）+线程池的结合优化版</p><p>reactor线程模型：主要有四个角色</p><ol><li>Reactor：把IO事件分配给对应的handler处理，就是IO多路复用的select实现，即轮询监听</li><li>Acceptor：处理客户端连接事件，创建Handler对象</li><li>Handler：将自身与事件绑定，执行非阻塞读、写任务，负责channel的读入，业务处理完成后，负责将结果写出channel</li><li>worker：用来处理handler传来的业务的线程</li></ol><p>其中1，2，3存放于主线程中，也称为bossGroup</p><p>4存放于从线程，也就是线程池中，也称为workerGroup</p><h2 id="单reactor-多线程"><a href="#单reactor-多线程" class="headerlink" title="单reactor-多线程"></a>单reactor-多线程</h2><p><img src="/../img/reactor3.png" alt="reactor3"></p><h2 id="主从reactor-多线程"><a href="#主从reactor-多线程" class="headerlink" title="主从reactor-多线程"></a>主从reactor-多线程</h2><p>这种模型下是把Reactor线程拆分了mainReactor和subReactor两个部分</p><p>mainReactor只处理连接事件，读写事件交给subReactor来处理。业务逻辑还是由线程池来处理</p><p><img src="/../img/reactor4.png" alt="reactor4"></p><h3 id="Netty的线程模型是怎么样的"><a href="#Netty的线程模型是怎么样的" class="headerlink" title="Netty的线程模型是怎么样的"></a><em><strong>Netty的线程模型是怎么样的</strong></em></h3><p>Netty同时支持Reactor单线程模型，多线程模型，主从多线程模型，用户可以配置参数在这三种模型之间切换</p><p>服务端启动时，通常会创建两个NioEventLoopGroup实例，对应两个独立的Reactor线程池，bossGroup负责处理客户端的连接请求，workerGroup负责处理IO相关的操作，执行任务等。用户可以根据ServerBootstrap启动类选择参数配置线程模型。</p><h3 id="Netty为什么高性能？"><a href="#Netty为什么高性能？" class="headerlink" title="Netty为什么高性能？"></a><em><strong>Netty为什么高性能？</strong></em></h3><ol><li>NIO模型，用最少的资源完成最多的任务</li><li>内存零拷贝，减少不必要的拷贝造成资源浪费，实现更高效率的传输</li><li>串行化处理读写：消息的处理尽可能在同一个线程内完成，避免切换线程的花销，避免多线程竞争和同步锁。调整NIO线程池的线程参数，可以同时启动多个串行化的线程，相比于多线程竞争机制性能更优。</li><li>支持protobuf：<code>protobuf</code> (protocol buffer) 是谷歌内部的混合语言数据标准。通过将结构化的数据进行序列化(串行化)，用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。是一个高性能的编解码框架，序列化数据后数据更小，传输速度更快，安全性也更高，netty可以直接在handler内添加protobuf编码解码器。</li><li>内存池设计，申请的内存可以重用</li></ol><h2 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h2><p>现象：发送abc和def，结果接收到abcdef</p><p>原因：</p><ol><li>应用层：接收方的bytebuf设置太大（默认1024）</li><li>TCP滑动窗口足够大，且接收方处理不及时</li><li>TCP的Nagle算法：为了减少广域网的小分组数目，从而减小网络拥塞的出现，会造成粘包。</li></ol><p>netty的解决方案：</p><ol><li>短连接，发完一次消息后便断开连接。下一次发消息的时候再次建立连接，重置了缓冲区</li><li>设置合理的缓冲区</li></ol><h2 id="半包"><a href="#半包" class="headerlink" title="半包"></a>半包</h2><p>现象：发送abcdef接收到abc和def</p><p>原因：</p><ol><li>应用层：bytebuf过小</li><li>TCP滑动窗口过小</li><li>链路层：MSS限制</li></ol><p>netty解决方案</p><p><code>FixedLengthFrameDecoder</code>定长帧解码器：固定收到的帧的大小，若收到半包，则延迟交付，直到收到其他消息满足大小，再交付</p><p><code>LineBasedFrameDecoder</code>行帧解码器：根据特定字符来区分完整的信息，避免半包</p><p><code>LengthFiledBasedFrameDecoder</code> ：指定内容长度，偏移量，从第几个字节开始读，跳过几个字节再读，从而精准读取内容避免半包</p><h1 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a><strong>零拷贝</strong></h1><p>零拷贝（zero-copy），是指在计算机执行IO操作时，CPU 不需要先将数据从一个内存区域复制到另一个内存区域。具体来讲，就是数据从网络设备到用户程序空间传递的过程中，减少数据拷贝次数，减少系统调用，实现 CPU 的零参与，彻底消除 CPU 在这方面的负载。</p><h3 id="传统的Linux-I-x2F-O模式"><a href="#传统的Linux-I-x2F-O模式" class="headerlink" title="传统的Linux I&#x2F;O模式"></a>传统的Linux I&#x2F;O模式</h3><p><img src="/../img/DMAIO.png" alt="DMAIO"></p><p><code>shell read(file_fd, tmp_buf, len); write(socket_fd, tmp_buf, len);</code></p><ol><li>用户进程通过<code>read</code>函数向内核（kernel）发起系统调用，<strong>CPU 将用户进程从用户态切换到内核态</strong>；</li><li>CPU 利用 DMA 控制器将数据从主存或硬盘拷贝到内核空间（kernel space）的读缓冲区（read buffer）；</li><li>CPU 将读缓冲区中的数据拷贝到用户空间（user space）的用户缓冲区（user buffer）；</li><li><strong>CPU 将用户进程从内核态切换回用户态</strong>，<code>read</code>调用执行返回；</li><li>用户进程通过<code>write</code>函数向内核发起系统调用，<strong>CPU 将用户进程从用户态切换到内核态</strong>；</li><li>CPU 将用户缓冲区中的数据拷贝到内核空间的网络缓冲区（socket buffer）;</li><li>CPU 利用 DMA 控制器将数据从网络缓冲区拷贝到网卡，进行数据传输；</li><li>CPU <strong>将用户进程从内核态切换回用户态</strong>，<code>write</code>调用执行返回。</li></ol><p>数据必须经过用户缓冲区才能到达Socket缓冲区，虽然加入了DMA来处理内核与硬件的数据传输，但是仍然效率不高</p><h3 id="由mmap实现用户态直接I-x2F-O"><a href="#由mmap实现用户态直接I-x2F-O" class="headerlink" title="由mmap实现用户态直接I&#x2F;O"></a>由mmap实现用户态直接I&#x2F;O</h3><p><code>tmp_buf = mmap(file_fd, len);write(socket_fd, tmp_buf, len);</code></p><p>使用 mmap 的目的是将内核中读缓冲区（read buffer）的地址与用户空间的缓冲区（user buffer）进行映射，从而实现内核缓冲区与应用程序内存的共享，省去了将数据从内核读缓冲区（read buffer）拷贝到用户缓冲区（user buffer）的过程，CPU直接将内核缓冲区中的数据拷贝到Socket缓冲区，节省了一次CPU拷贝。</p><p><img src="/../img/DMAIO1.png" alt="DMAIO1"></p><p>当<code>mmap</code>一个文件时，如果这个文件被另一个进程所截获，那么<code>write</code>系统调用会因为访问非法地址被<code>SIGBUS</code>信号终止，<code>SIGBUS</code>默认会杀死进程并产生一个 <code>coredump</code>，服务器可能因此被终止。</p><h3 id="Sendfile实现内核内的数据传输"><a href="#Sendfile实现内核内的数据传输" class="headerlink" title="Sendfile实现内核内的数据传输"></a>Sendfile实现内核内的数据传输</h3><p><code>sendfile(socket_fd, file_fd, len);</code></p><p>通过 Sendfile 系统调用，<strong>数据可以直接在内核空间内部进行 I&#x2F;O 传输，省去了数据在用户空间和内核空间之间的来回拷贝</strong>。</p><p><img src="/../img/DMAIO2.png" alt="DMAIO2"></p><p>基于 Sendfile 系统调用的零拷贝方式，整个拷贝过程会发生<strong>2次上下文切换</strong>，<strong>1 次CPU拷贝和2次DMA拷贝</strong>。</p><p>Sendfile 存在的问题是：用户程序不能在中途对数据进行修改，而只是单纯地完成了一次数据传输过程，它只适用于将数据从文件拷贝到 Socket 套接字上的传输过程。</p><h3 id="Sendfile-DMA-gather-copy实现硬件级的直接拷贝"><a href="#Sendfile-DMA-gather-copy实现硬件级的直接拷贝" class="headerlink" title="Sendfile+DMA gather copy实现硬件级的直接拷贝"></a>Sendfile+DMA gather copy实现硬件级的直接拷贝</h3><p>Linux内核2.4版本，对 Sendfile 系统调用进行了修改，为DMA拷贝引入了<code>gather</code>操作：它将内核空间的读缓冲区中对应的数据描述信息（内存地址、地址偏移量）记录到相应的网络缓冲区（ socket buffer）中，<strong>由 DMA 根据内存地址、地址偏移量将数据批量地从读缓冲区拷贝到网卡设备中。</strong></p><p><img src="/../img/DMAIO3.png" alt="DMAIO3"></p><p>DMA gather copy需要硬件的支持，Sendfile 拷贝方式不再从内核缓冲区的数据拷贝到 Socket 缓冲区，取而代之是<strong>仅仅拷贝缓冲区文件描述符和数据长度。</strong></p><p>这样 DMA 引擎直接利用 gather 操作将页缓存中数据打包发送到网络中即可，本质是和虚拟内存映射类似的思路</p><p>整个拷贝过程会发生<strong>2次上下文切换</strong>、<strong>0次CPU拷贝以及2次 DMA拷贝</strong>。</p><h3 id="Splice实现管道传输"><a href="#Splice实现管道传输" class="headerlink" title="Splice实现管道传输"></a>Splice实现管道传输</h3><p>Linux内核2.6.17版本，引入了 Splice 系统调用。Splice 系统调用可以在内核空间的读缓冲区和网络缓冲区之间建立管道（pipeline），从而避免了两者之间的 CPU 拷贝操作。</p><p>Splice 系统调用不仅不需要硬件支持，还实现了两个文件描述符之间的数据零拷贝。<img src="/../img/DMAIO4.png" alt="DMAIO4"></p><p>整个拷贝过程会发生<strong>2次上下文切换</strong>，<strong>0次CPU拷贝以及2次DMA拷贝</strong></p><table><thead><tr><th>消息队列</th><th>零拷贝方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>RocketMQ</td><td>mmap + write</td><td>适用于小块文件传输，频繁调用时，效率很高</td><td>不能很好的利用DMA方式，会比sendfile多消耗CPU，内存安全性控制复杂，需要避免JVM Crash问题</td></tr><tr><td>Kafka</td><td>sendfile</td><td>可以利用DMA方式，消耗CPU较少，大块文件传输效率高，无内存安全性问题</td><td>小块文件效率低于mmap方式，只能是BIO方式传输，不能使用NIO方式</td></tr></tbody></table><p>无论是传统 I&#x2F;O 拷贝方式还是引入零拷贝的方式，2次DMA拷贝都是少不了的，因为两次 DMA 都是依赖硬件完成的</p><h2 id="netty的零拷贝"><a href="#netty的零拷贝" class="headerlink" title="netty的零拷贝"></a>netty的零拷贝</h2><p>Netty 中也使用了零拷贝技术，但是和操作系统层面上的零拷贝不太一样, Netty 零拷贝是相对于堆内存与堆外内存而言的，它的更多的是偏向于数据操作优化这样的概念。</p><ol><li>Netty接收和发送ByteBuffer采用DirectBuffer，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的JVM的堆内存进行socker读写，那么JVM将会将堆内存拷贝一份到直接内存中，然后在写入socket中。相比堆外直接内存，消息在发送过程中多了一次缓存区的拷贝</li><li>Netty提供CompositeByteBuf组合缓冲区类，可以将多个 ByteBuf合并为一个逻辑上的ByteBufer，避免了各个ByteBufer之间的拷贝，将几个小buffer合并成一个大buffer的繁琐操作。</li><li>Netty提供了ByteBuf的浅层复制操作(slice、 duplicate)，可以将ByteBuf分解为多个共享同一个存储区域的 ByteBuf，避免内存的拷贝</li><li>Netty进行文件传输时，可以调用FileRegion包装的 **transferTo()**方法直接将文件缓冲区的数据发送到目标通道，避免普通的循环读取文件数据和写入通道所导致的内存拷贝问题。</li><li>在将一个byte数组转换为一个ByteBuf对象的场景下，Netty 提供了一系列的包装类，避免了转换过程中的内存拷贝。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程，线程和协程详解</title>
    <link href="/post/%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%8D%8F%E7%A8%8B.html"/>
    <url>/post/%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%8D%8F%E7%A8%8B.html</url>
    
    <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><blockquote><p>an instance of a computer program that is being executed</p><p>进程是程序的一次执行，是一个程序及其数据，运行环境，在处理机上运行时所发生的活动。</p></blockquote><p>与程序不同的是，进程具有动态性和生命周期，是系统进行资源分配和调度的独立单位。</p><p>进程的结构：</p><ol><li>控制块</li><li>数据段</li><li>程序段</li></ol><h1 id="线程的Linux实现"><a href="#线程的Linux实现" class="headerlink" title="线程的Linux实现"></a>线程的Linux实现</h1><p>而在windows中，线程被抽象为一种比进程更轻量级的可以独立处理事件的单元，支持真线程的系统一定要有线程控制块：TCB，操作系统既要进行进程管理，又要进行线程管理，设计层面是比较复杂的。windows上一定会有相关线程操作的系统调用接口。</p><p>而在Linux中却不一样，从内核的角度来看，并没有线程这个概念，Linux把所有的线程都当作进程来处理，内核也并没有定义独特的调度算法和数据结构来实现线程，线程就是一个与父进程共享资源的进程而已，Linux在创建线程时，会直接创建进程并分配task_struct，同时指定共享资源，所以对于内核来说，它就是进程，线程在Linux中是一个实现进程共享资源的机制。</p><p>在 Linux 中每一个进程都由 task_struct 数据结构来定义。task_struct 就是我们通常所说的 PCB，当我们调用 fork()  时，系统会为我们产生一个 task_struct 结构。然后从父进程，那里继承一些数据，并将PCB插入任务队列中，以待进行进程管理。</p><p>对于线程来说，需要在clone()中指定共享资源</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND,<span class="hljs-number">0</span>);<br><span class="hljs-comment">//VM：共享地址空间</span><br><span class="hljs-comment">//FS：共享文件系统信息</span><br><span class="hljs-comment">//FILES:共享打开的文件</span><br><span class="hljs-comment">//SIGHAND：共享阻断信号</span><br></code></pre></td></tr></table></figure><p>而一个普通的fork()就是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">clone(SIGCHLD,<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h2 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h2><p>内核需要经常在后台处理操作，这些任务可以交给内核线程来处理。内核线程就是独立运行在内核空间的标准进程。</p><p>内核线程没有独立的地址空间。其指向地址空间的mm指针设置为null，只存在于内核空间（task_struct结构中的mm指针：指向进程所拥有的内存描述符）</p><p><strong>多线程的优点：并发性提高，占用资源比进程更少。</strong></p><p><strong>多线程缺点：存在大量临界资源，势必会造成各种互斥。编程难度提高，线程的调度和同步需要更多额外的开销。</strong></p><h2 id="线程的通信方式"><a href="#线程的通信方式" class="headerlink" title="线程的通信方式"></a>线程的通信方式</h2><h3 id="管道："><a href="#管道：" class="headerlink" title="管道："></a>管道：</h3><p>分为匿名管道和命名管道，实质是一个缓冲区，管道的作用正如其名，需要通信的两个进程在管道的两端，进程利用管道传递信息。管道对于管道两端的进程而言，就是一个文件，但是这个文件比较特殊，它不属于文件系统并且只存在于内存中。</p><h3 id="信号signal："><a href="#信号signal：" class="headerlink" title="信号signal："></a>信号signal：</h3><p>信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，进程不必通过任何操作来等待信号的到达。信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件。</p><h3 id="信号量Semaphore："><a href="#信号量Semaphore：" class="headerlink" title="信号量Semaphore："></a>信号量Semaphore：</h3><p>信号量实质上就是一个标识可用资源数量的计数器，它的值总是非负整数。而只有0和1两种取值的信号量叫做二进制信号量（或二值信号量），可用用来标识某个资源是否可用。</p><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存:"></a>共享内存:</h3><p>使得多个进程可以可以直接读写同一块内存空间，是针对其他通信机制运行效率较低而设计的。为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列:"></a>消息队列:</h3><p>消息队列是消息的链表，具有特定的格式,存放在内存中并由消息队列标识符标识，并且允许一个或多个进程向它写入与读取消息</p><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字:"></a>套接字:</h3><p>不同客户端的进程间的通信方式</p><h1 id="用户空间和内核空间"><a href="#用户空间和内核空间" class="headerlink" title="用户空间和内核空间"></a>用户空间和内核空间</h1><p>操作系统为了支持多个应用同时运行，需要保证不同进程之间相对独立，一个进程的崩溃不会影响其他进程，恶意进程不能读取其他进程的数据。于是内存空间被划分为两部分，<strong>内核空间和用户空间</strong>，内核空间的代码和数据拥有更高的权限，而用户空间的代码不能访问高级别的空间，因此保护了操作系统自身的内存数据。</p><p><strong>用户态</strong>：指进程运行在用户地址空间中的状态，被执行的代码要受到 CPU 的很多检查。进程只能访问地址空间中规定的页面的虚拟地址。</p><p><strong>内核态</strong>：指进程运行在内核地址空间中的状态，此时 CPU 可以执行任何指令。运行的代码也不受任何的限制，可以自由地访问任何有效地址，也可以直接进行端口的访问。所有系统资源的管理都是在内核态去做的，比如创建一个线程需要分配资源，就需要进入内核态，来完成。</p><h2 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h2><p>在Linux中，用户程序装入系统形成一个进程的实质是系统为用户程序提供一个完整的运行环境</p><p>进程的运行环境是由它的程序代码和程序运行所需要的数据结构以及硬件环境组成的，进程的运行环境主要包括：</p><ol><li>进程空间中的代码和数据、进程堆栈和共享内存区等。</li><li>环境变量：提供进程运行所需的环境信息。</li><li>系统数据：进程空间中的对进程进行管理和控制所需的信息，包括进程任务结构体以及内核堆栈等。</li><li>进程访问设备或者文件的权限。</li><li>硬件寄存器。</li></ol><p>从以上组成情况可知，进程的运行环境是动态变化的，尤其是硬件寄存器的值以及进程控制信息是随着进程的运行而不断变化的。</p><p><strong>在Linux中把系统提供给进程的的处于动态变化的运行环境总和称为进程上下文，系统中的每一个进程都有自己的上下文。</strong></p><p>当前进程因时间片用完或者因等待某个事件而阻塞时，进程调度需要把处理器的使用权从当前进程交给另一个进程，这个过程叫做进程切换。</p><p>此时，被调用进程成为当前进程。在进程切换时系统要把当前进程的上下文保存在指定的内存区域（该进程的任务状态段TSS中），然后把下一个使用处理器运行的进程的上下文设置成当前进程的上下文。当一个进程经过调度再次使用CPU运行时，系统要恢复该进程保存的上下文。所以，<strong>进程的切换也就是上下文切换</strong>。</p><p>在系统内核为用户进程服务时，通常是进程通过系统调用执行内核代码，此时内核为用户进程服务，可以说内核在代替当前进程执行某种服务。所以可以认为，<strong>内核态就是内核运行在进程上下文中的状态，也就是陷入内核态</strong>。</p><p><strong>中断上下文</strong>：硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理。所谓的“中断上下文”，其实也可以看作就是硬<strong>件传递过来的这些参数和内核需要保存的一些其他环境</strong>（主要是当前被打断执行的进程环境）</p><h1 id="从用户态进入内核态：中断"><a href="#从用户态进入内核态：中断" class="headerlink" title="从用户态进入内核态：中断"></a>从用户态进入内核态：中断</h1><p>中断是CPU的一个功能：CPU停下工作后，保留现场，自动的转去执行相应的处理程序，CPU的控制权发生改变，处理完该事件后再返回断点继续执行。<strong>避免了CPU的轮询检查</strong>，而是转换为事件驱动，向CPU发送中断事件，强制让CPU来执行中断处理程序。发生中断，CPU会立即进入<strong>内核态</strong>，针对不同的中断信号，采取不同的处理方式。**中断是CPU从用户态进入核心态的唯一途径(如系统调用)**。</p><h2 id="硬中断"><a href="#硬中断" class="headerlink" title="硬中断"></a>硬中断</h2><p>硬中断时由外部事件引起的，具有<strong>随机性和突发性</strong>，比如键盘，鼠标的输入，磁盘的读写，缺页。硬中断的中断号是<strong>由中断控制器提供的</strong>，硬中断是<strong>可以屏蔽</strong>掉的。</p><p>流程如下</p><ol><li><strong>外设</strong> 将中断请求发送给中断控制器；</li><li><strong>中断控制器</strong> 根据中断优先级，有序地将中断号传递给 CPU；</li><li><strong>CPU</strong> 终止执行当前程序流，将 CPU 所有寄存器的数值保存到栈中；</li><li><strong>CPU</strong> 根据中断号，从<strong>中断向量表</strong>中查找中断处理程序的入口地址，执行中断处理程序；</li><li><strong>CPU</strong> 恢复寄存器中的数值，返回原程序流停止位置继续执行。</li></ol><h2 id="软中断（被动）"><a href="#软中断（被动）" class="headerlink" title="软中断（被动）"></a>软中断（被动）</h2><p>CPU的内部事件或者程序引起的中断，如程序故障，电压故障。</p><h2 id="软中断（主动）"><a href="#软中断（主动）" class="headerlink" title="软中断（主动）"></a>软中断（主动）</h2><p>也称作<strong>系统调用</strong>，用户进程<strong>主动要求</strong>进入内核态。用户进程通过系统调用申请操作系统提供服务。</p><p> 系统调用使用的是一个特别的中断实现的。具体是:调用 int $<strong>0x80</strong>的汇编指令，将产生向量为0x80的编程异常（软中断）</p><p>软中断模拟了硬中断的处理过程：</p><ol><li>无</li><li>无</li><li><strong>CPU</strong> 终止执行当前程序流，将 CPU 所有寄存器的数值保存到栈中；</li><li><strong>CPU</strong> 根据中断向量，从中断向量表中查找中断处理程序的入口地址，执行中断处理程序；</li><li><strong>CPU</strong> 恢复寄存器中的数值，返回原程序流停止位置继续执行。</li></ol><h2 id="一个程序开多少线程合适"><a href="#一个程序开多少线程合适" class="headerlink" title="一个程序开多少线程合适"></a><em>一个程序开多少线程合适</em></h2><h3 id="CPU密集型"><a href="#CPU密集型" class="headerlink" title="CPU密集型"></a>CPU密集型</h3><p>一个完整的请求，IO操作可以在很短的时间内完成，CPU的运算时间占大部分，线程等待时间接近0</p><ol><li>单核CPU：一个CPU对应一个线程，且IO时间短，所以不适合使用多线程。若使用多线程，会造成线程竞争，造成不必要的浪费</li><li>多核：如果是多核CPU，就可以最大化利用CPU的核心数，使用并发编程来提高效率。理论上的线程数量就等于CPU的核数，但是一般会设置为核数+1，这个额外的线程可以保证线程因为缺页中断或者其他原因暂停而不会导致CPU中断工作</li></ol><h3 id="IO密集型"><a href="#IO密集型" class="headerlink" title="IO密集型"></a>IO密集型</h3><p>一个完整请求，除了CPU的运算操作，还有许多IO操作要做，也就是说，IO操作占很大一部分，等待时间较长。</p><p>理论最佳线程数：CPU核心数 * （1&#x2F;CPU利用率），CPU利用率&#x3D;1+（IO耗时&#x2F;CPU耗时）</p><p>如果几乎全是IO耗时，那么就可以说是2N，但是一般也有一个backup，也就是2N+1</p><h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>当使用new关键字创建了一个线程之后，该线程就处于一个新建状态，此时它和其他java对象一样，仅仅被分配了内存，并初始化了成员变量值。没有线程的动态特征，也不会执行线程的执行体</p><h2 id="就绪"><a href="#就绪" class="headerlink" title="就绪"></a>就绪</h2><p>当调用start方法后，该线程处于就绪状态。JVM会为其创建虚拟机栈和PC，处于这个状态表示线程可以运行了，等待被调度执行</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>在就绪状态下，若被OS调度，就会进入运行状态。当时间片用完或者调用线程让步时，回到就绪状态</p><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><ol><li>等待阻塞：线程执行wait方法，JVM会将其放入等待池中，此时线程会释放持有的锁</li><li>同步阻塞：即被synchronized修饰的代码块被其他线程拿到，本线程获取同步锁失败，就会被JVM放入锁池中</li><li>其他阻塞：线程执行sleep或者join方法，或者发出了IO请求。当sleep超时，join等待线程终止或者等待超时，IO完毕，线程就会重新转入就绪状态</li></ol><p>sleep：线程睡眠，使线程转入阻塞状态一定时间</p><p>wait：线程等待，使线程放入等待池，指导其他线程调用notify或者notifyall方法来唤醒，此时线程会尝试获取锁，若成功，转为就绪状态，若失败，则进入锁池等待锁的释放。</p><p>yield：线程让步，暂停当前正在执行的线程对象，回到就绪状态，把执行机会让给优先级相同或者更高的线程</p><p>join：线程加入，等待其他线程终止，在当前进程中调用另一个指定进程的join方法，则当前进程转入阻塞状态，直到另一个进程运行结束，当前进程再由阻塞转为就绪状态</p><p>notify：线程唤醒，唤醒被wait阻塞的进程</p><h2 id="死亡"><a href="#死亡" class="headerlink" title="死亡"></a>死亡</h2><ol><li>run方法执行完成，线程正常结束</li><li>抛出异常</li><li>直接调用stop方法来结束（容易造成死锁）</li></ol><p><img src="/../img/thread.png" alt="thread"></p><h1 id="线程的实现模型"><a href="#线程的实现模型" class="headerlink" title="线程的实现模型"></a>线程的实现模型</h1><p>线程的实现模型主要有 3 种：内核级线程模型、用户级线程模型和两级线程模型（也称混合型线程模型）</p><p>它们之间最大的差异就在于<strong>用户线程</strong>与<strong>内核调度实体</strong>（KSE，Kernel Scheduling Entity）之间的对应关系</p><p>而所谓的内核调度实体 KSE 就是指可以被操作系统内核调度器调度的对象实体</p><p>简单来说 <strong>KSE 就是内核级线程</strong>，是操作系统内核的最小调度单元，也就是我们写代码的时候通俗理解上的线程了</p><h2 id="用户级线程模型"><a href="#用户级线程模型" class="headerlink" title="用户级线程模型"></a>用户级线程模型</h2><p>用户线程与内核线程是多对一（N : 1）的映射模型，多个用户线程一般从属于单个进程并且多线程的调度是由用户自己的线程库来完成，线程的创建、销毁以及多线程之间的协调等操作都是由用户自己的线程库来负责而无须借助系统调用来实现。</p><p>一个进程中所有创建的线程都只和同一个 KSE 在运行时动态绑定，也就是说，操作系统只知道用户进程而对其中的线程是无感知的，内核的所有调度都是基于用户进程。许多语言实现的协程库基本上都属于这种方式（比如 python和c++）。</p><p>由于线程调度是在用户层面完成的，也就是相较于内核调度不需要让 CPU 在用户态和内核态之间切换，这种实现方式相比内核级线程可以做的很轻量级，对系统资源的消耗会小很多，因此上下文切换所花费的代价也会小得多。</p><p>但该模型有个原罪：<strong>并不能做到真正意义上的并发</strong>，假设在某个用户进程上的某个用户线程因为一个阻塞调用（比如 I&#x2F;O 阻塞）而被 CPU 给中断（抢占式调度）了，那么该进程内的所有线程都被阻塞（因为单个用户进程内的<strong>线程自调度是没有 CPU 时钟中断的，从而没有轮转调度</strong>），整个进程被挂起。在用户级线程模型下，一个 CPU 关联运行的是整个用户进程，进程内的子线程绑定到 CPU 执行<strong>是完全由用户进程调度的</strong>，内部线程对 CPU 是不可见的。</p><p>所以很多的协程库会把自己一些阻塞的操作重新封装为完全的<strong>非阻塞</strong>形式，然后在以前要阻塞的点上，<strong>主动让出自己</strong>，并通过某种方式通知或唤醒其他待执行的用户线程在该 KSE上运行，从而避免了内核调度器由于KSE阻塞而做上下文切换，这样整个进程也不会被阻塞了。</p><h2 id="内核级线程模型"><a href="#内核级线程模型" class="headerlink" title="内核级线程模型"></a>内核级线程模型</h2><p>用户线程与内核线程是一对一（1 : 1）的映射模型，也就是每一个用户线程绑定一个实际的内核线程，线程的调度则完全交付给操作系统内核去做，应用程序对线程的创建、终止以及同步都基于内核提供的系统调用来完成，大部分编程语言的线程库(比如 <strong>Java 的 java.lang.Thread</strong>、C++11 的 std::thread 等等)都是对操作系统的线程（内核级线程）的一层封装，<strong>创建出来的每个线程与一个独立的 KSE 静态唯一绑定</strong>，因此其调度完全由操作系统内核调度器去做。</p><p>优势是实现简单，直接借助操作系统内核的线程以及调度器，所以 CPU 可以快速切换调度线程，于是多个线程可以同时运行，因此相较于用户级线程模型它真正做到了并行处理；但它的劣势是，由于直接借助了操作系统内核来创建、销毁和以及多个线程之间的上下文切换和调度，因此资源成本大幅上涨，且对性能影响很大。</p><p><img src="/../img/javaThread.png" alt="javaThread"></p><h2 id="两级线程模型"><a href="#两级线程模型" class="headerlink" title="两级线程模型"></a>两级线程模型</h2><p>两级线程模型充分吸收了前两种线程模型的优点且尽量规避它们的缺点。</p><p>在此模型下，用户线程与内核KSE是多对多（N : M）的映射模型</p><p>区别于用户级线程模型，两级线程模型中的<strong>一个进程可以与多个内核线程 KSE 关联</strong>，也就是说一个进程内的多个线程可以分别绑定一个自己的 KSE，这点和内核级线程模型相似；</p><p>又区别于内核级线程模型，它的<strong>进程里的线程并不与 KSE 唯一绑定</strong>，而是可以多个用户线程映射到同一个 KSE，当某个 KSE 因为其绑定的线程的阻塞操作被内核调度出 CPU 时，其关联的进程中其余用户线程可以重新与其他 KSE 绑定运行。</p><p>所以，两级线程模型既不是用户级线程模型那种完全靠自己调度的也不是内核级线程模型完全靠操作系统调度的，而是中间态（自身调度与系统调度协同工作，Go 语言中的 runtime 调度器就是采用的这种实现方案，实现了 Goroutine 与 KSE 之间的动态关联。</p><p>该模型为何被称为两级？即用户调度器实现用户线程到 KSE 的『调度』，内核调度器实现 KSE 到 CPU 上的『调度』。</p><h1 id="协程的C-实现：C-20-Coroutine-TS"><a href="#协程的C-实现：C-20-Coroutine-TS" class="headerlink" title="协程的C++实现：C++20 Coroutine TS"></a>协程的C++实现：C++20 Coroutine TS</h1><p>Coroutine是一个函数的泛化，它允许函数被挂起，稍后再恢复</p><h3 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h3><blockquote><p>一个普通函数可以被认为有两个操作：<strong>调用</strong>和<strong>返回</strong></p></blockquote><h4 id="调用Call"><a href="#调用Call" class="headerlink" title="调用Call"></a>调用Call</h4><p>当调用一个函数时，<strong>调用</strong>操作会创建一个栈帧，<strong>挂起</strong>调用函数的执行，并将执行转交到被调用函数的开始位置</p><p>这个“挂起”步骤通常包括将当前保存在CPU寄存器中的任何值保存到内存中，以便在函数恢复执行时，这些值可以在需要时恢复。根据函数的调用约定，调用方和被调用方可以协调谁保存这些寄存器值，但您仍然可以将它们视为<strong>调用</strong>操作的一部分。</p><h4 id="返回Return"><a href="#返回Return" class="headerlink" title="返回Return"></a>返回Return</h4><p><strong>返回</strong>操作将返回值传递给调用方，并销毁函数的栈帧，然后在调用函数的位置<strong>恢复</strong>调用方的执行。恢复就是回到调用那个时刻的位置，比如设置寄存器重新指向调用者的栈帧。</p><h3 id="协程与普通函数"><a href="#协程与普通函数" class="headerlink" title="协程与普通函数"></a>协程与普通函数</h3><blockquote><p>而协程泛化了函数的操作且增加了三个额外的操作：挂起，恢复，销毁</p></blockquote><h4 id="协程的栈帧"><a href="#协程的栈帧" class="headerlink" title="协程的栈帧"></a>协程的栈帧</h4><p>协程可以在不销毁栈帧的情况下被挂起，这相当于<strong>打破了一个函数调用在虚拟机栈内的运作规则</strong>（压入-执行-返回-弹出-销毁）</p><p>这意味着我们需要一个额外的数据结构来保存协程的状态，即<strong>堆内存上的协程帧</strong></p><p>协程帧：用于保存操作数，挂起时的恢复点地址，相当于是保存了自身状态的快照</p><h4 id="挂起：Suspend"><a href="#挂起：Suspend" class="headerlink" title="挂起：Suspend"></a>挂起：Suspend</h4><p>挂起操作在函数的当前点挂起协程的执行，并在不破坏栈帧帧的情况下将执行权转交给调用方或恢复调用方。</p><p>C++ Coroutines TS中，这些挂起点是通过<strong>co_await</strong>或<strong>co_yield</strong>关键字来标识的，在挂起协程执行之后，挂起点上的任何对象都仍然是可用的。</p><p><strong>记住，协程的切换不会破坏栈帧，这是协程实现回调的核心</strong></p><p>当挂起时会发生以下操作：</p><ol><li>确保将寄存器中保存的任何值写入协程帧</li><li>将恢复点的地址写入协程帧，以指示在哪个位置挂起，恢复操作就可以知道在哪里恢复协程的执行</li></ol><h4 id="恢复：Resume"><a href="#恢复：Resume" class="headerlink" title="恢复：Resume"></a>恢复：Resume</h4><p>就像普通函数调用一样，这个对resume()的调用将分配一个新的栈帧，并在将执行转交到该函数之前将调用者的返回地址存储在栈帧中。</p><p>但是，它不是将执行转移到函数的开始，而是将执行转移到上次挂起的函数的点。</p><h4 id="调用：Call"><a href="#调用：Call" class="headerlink" title="调用：Call"></a>调用：Call</h4><p>协程所做的第一件事是在堆中分配一个协程帧，并将参数从栈帧复制&#x2F;移动到协程帧，以便参数的生命周期超过第一个挂起点</p><h4 id="销毁：Destroy"><a href="#销毁：Destroy" class="headerlink" title="销毁：Destroy"></a>销毁：Destroy</h4><p><strong>销毁</strong>操作销毁协程帧，而不恢复协程的执行</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>协程常常被认为是轻量级的线程，实际上在C++中，协程不是进程也不是线程，<strong>而是一个特殊的函数</strong>，这个函数可以在某个地方挂起，并且可以重新在挂起处外继续运行。所以说，协程与进程、线程相比并不是一个维度的概念。</p></blockquote><p><strong>协程不是被操作系统内核所管理的，而是完全由程序所控制，也就是在用户态执行。</strong>这样带来的好处是性能大幅度的提升，因为不会像线程切换那样消耗资源。协程的调度也是通过在用户态里创建一个调度器来模拟内核的调度。</p><p>一个线程也可以包含多个协程。一个线程内可以有多个这样的特殊函数在运行，但是有一点必须明确的是，多个线程或者多个进程可以并行，但是<strong>一个线程内的多个协程绝对是串行的</strong>，因为它仍然是一个函数。</p><p>线程切换过程是由“用户态到内核态到用户态”， 而协程的切换过程只有用户态，即没有陷入内核态，因此切换效率高。</p><p>协程本质上是<strong>异步非阻塞</strong>技术，它是将事件回调进行了包装，让程序员看不到里面的事件循环。</p><h1 id="协程的Golang实现：Goroutine-amp-Scheduler"><a href="#协程的Golang实现：Goroutine-amp-Scheduler" class="headerlink" title="协程的Golang实现：Goroutine &amp; Scheduler"></a>协程的Golang实现：Goroutine &amp; Scheduler</h1><p>每一个 OS 线程都有一个固定大小的(一般会是 2MB)栈内存空间，这个栈会用来存储当前正在被调用或挂起(指在调用其它函数时)的函数的内部变量。这个固定大小的栈同时很大又很小。因为 2MB 的栈对于一个小小的 goroutine 来说是很大的内存浪费，而对于一些复杂的任务（如深度嵌套的递归）来说又显得太小。</p><p>因此，Go 语言做了它自己的『线程』。 在 Go 语言中，每一个 goroutine 是一个独立的执行单元，相较于每个 OS 线程固定分配 2M 内存的模式，goroutine 的栈采取了动态扩容方式， 初始时仅为 2KB，随着任务执行按需增长，最大可达 1GB（64 位机器最大是 1G，32 位机器最大是 256M），且完全由 golang 自己的调度器 Go Scheduler 来调度。此外，GC 还会周期性地进行内存回收，收缩栈空间。</p><p>因此，Go 程序可以同时并发成千上万个 goroutine 是得益于它强劲的调度器和高效的内存模型。golang 中的许多标准库的实现也都能见到 goroutine 的身影，比如 net&#x2F;http 这个包，甚至语言本身的组件runtime和GC垃圾回收器都是运行在 goroutine 上的，作者对 goroutine 的厚望可见一斑。</p><h2 id="G-P-M模型概述"><a href="#G-P-M模型概述" class="headerlink" title="G-P-M模型概述"></a>G-P-M模型概述</h2><p>G: 表示 Goroutine，每个Goroutine 对应一个G结构体，G存储Goroutine的运行堆栈、状态以及任务函数，可重用。G 并非执行体，每个 G 需要绑定到 P 才能被调度执行。 </p><p>P: Processor，表示逻辑处理器， 对 G来说，<strong>P相当于CPU 核</strong>，G 只有绑定到 P(在P的 local runq 中)才能被调度。对 M 来说，P 提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等，P 的数量决定了系统内最大可并行的 G 的数量（前提：物理 CPU 核数 &gt;&#x3D; P 的数量），P的数量由用户设置的GOMAXPROCS 决定，但是不论 GOMAXPROCS 设置为多大，P 的数量最大为 256。 </p><p>M: Machine，OS线程抽象，一个M对应一个内核线程，<strong>代表着真正执行计算的资源</strong>，在绑定有效的 P 后，进入 schedule 循环；而 schedule 循环的机制大致是从 Global 队列、P 的 Local 队列以及 wait 队列中获取 G，切换到 G 的执行栈上并执行 G 的函数，调用 goexit 做清理工作并回到 M，如此反复。M 并不保留 G 状态，这是 G 可以跨 M 调度的基础，M 的数量是不定的，由 Go Runtime调整，为了防止创建过多 OS 线程导致系统调度不过来，目前默认最大限制为 10000 个。</p><p>在宏观上说，Goroutine 与 Machine 因为 Processor 的存在，形成了多对多（M:N）的关系。</p><h2 id="G-P-M调度机制"><a href="#G-P-M调度机制" class="headerlink" title="G-P-M调度机制"></a>G-P-M调度机制</h2><p><img src="/../img/GMP-scheduler.png" alt="GMP-scheduler"></p><p>Go 调度器工作时会维护两种用来保存 G 的任务队列：一种是一个 Global 任务队列，一种是每个 P 维护的 Local 任务队列。</p><p>当通过 go关键字创建一个新的 goroutine 的时候，它会优先被放入 P 的本地队列。为了运行 goroutine，M 需要持有（绑定）一个 P<strong>，接着 M 会启动一个 OS 线程，循环从 P 的本地队列里取出一个 goroutine 并执行。</strong></p><p>还有 <strong>work-stealing 调度算法</strong>：当 M 执行完了当前 P 的 Local 队列里的所有 G 后，P 也不会就啥都不干，它会先尝试从 Global 队列寻找 G 来执行，如果 Global 队列为空，它会随机挑选另外一个 P，从它的队列里中拿走一半的 G 到自己的队列中执行。</p><h3 id="用户态阻塞-x2F-唤醒"><a href="#用户态阻塞-x2F-唤醒" class="headerlink" title="用户态阻塞&#x2F;唤醒"></a>用户态阻塞&#x2F;唤醒</h3><p>当 goroutine 因为 channel 操作或者 network I&#x2F;O 而阻塞时（实际上 golang 已经用 netpoller 实现了 goroutine 网络 I&#x2F;O 阻塞不会导致 M 被阻塞，仅阻塞 G，这里仅仅是举个栗子），对应的 G 会被放置到某个 wait 队列(如 channel 的 waitq)，该 G 的状态由 _Gruning 变为 _Gwaitting ，而 M 会跳过该 G 尝试获取并执行下一个 G，如果此时没有 runnable 的 G 供 M 运行，那么 M 将解绑 P，并进入 sleep 状态；当阻塞的 G 被另一端的 G2 唤醒时（比如 channel 的可读&#x2F;写通知），G 被标记为 runnable，尝试加入 G2 所在 P 的 runnext，然后再是 P的Local 队列和 Global 队列。</p><h3 id="系统调用阻塞"><a href="#系统调用阻塞" class="headerlink" title="系统调用阻塞"></a>系统调用阻塞</h3><p>当 G 被阻塞在某个系统调用上时，此时 G 会阻塞在 _Gsyscall 状态，M 也处于 block on syscall 状态，此时的 M 可被抢占调度：<strong>执行该 G 的 M 会与 P 解绑，而 P 则尝试与其它 idle 的 M 绑定，继续执行其它 G</strong>。如果没有其它 idle 的 M，但 P 的 Local 队列中仍然有 G 需要执行，则创建一个新的 M；当系统调用完成后，G 会重新尝试获取一个 idle 的 P 进入它的 Local 队列恢复执行，如果没有 idle 的 P，G 会被标记为 runnable 加入到 Global 队列。</p><h3 id="Goroutine会出现什么问题？"><a href="#Goroutine会出现什么问题？" class="headerlink" title="Goroutine会出现什么问题？"></a><em><strong>Goroutine会出现什么问题？</strong></em></h3><p>即便每个 goroutine 只分配 2KB 的内存，但如果聚少成多，内存暴涨，就会对 GC 造成极大的负担， JVM GC 的 STW（Stop The World）机制，也就是 GC 的时候会挂起用户程序直到垃圾回收完，虽然 Go1.8 之后的 GC 已经去掉了 STW 以及优化成了并行 GC，性能上有了不小的提升，但是，如果太过于频繁地进行 GC，依然会有性能瓶颈； </p><p>runtime 和 GC 也都是 goroutine ，如果 goroutine 规模太大，内存吃紧，runtime 调度和垃圾回收同样会出问题，虽然 G-P-M 模型足够优秀，但是没有内存，Go 调度器就会阻塞 goroutine，结果就是 P 的 Local 队列积压，又导致内存溢出，这就是个死循环…，甚至极有可能程序直接 Crash 掉。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC</title>
    <link href="/post/JUC.html"/>
    <url>/post/JUC.html</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA创建线程的四种方式"><a href="#JAVA创建线程的四种方式" class="headerlink" title="JAVA创建线程的四种方式"></a>JAVA创建线程的四种方式</h1><h2 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h2><ol><li>定义thread类的子类，并重写run方法，该方法的方法体就是线程需要完成的任务，run方法也称为线程执行体。</li><li>创建Thread类的实例，也就是创建了线程对象</li><li>启动线程，即调用线程的start方法</li></ol><h2 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h2><ol><li>定义Runnable接口的实现类，重写run方法，run方法同样是线程执行体</li><li>创建实现类的实例，并用这个实例作为Thread类的target来创建Thread对象，这个Thread对象便是线程对象</li><li>启动线程，调用start方法</li></ol><h2 id="使用Callable和future创建"><a href="#使用Callable和future创建" class="headerlink" title="使用Callable和future创建"></a>使用Callable和future创建</h2><p>future接口是jdk1.5引入的，可以用来接收callable接口里call方法的返回值</p><p>有一个实现类futureTask，实现了future和runnable接口，因此可以作为thread类的target</p><ol><li>创建callable接口的实现类，并实现call方法，然后创建该实现类的实例</li><li>使用futureTask类来包装callable对象</li><li>使用futureTask对象作为thread对象的target创建并启动线程</li><li>使用futureTask对象的get方法来获取子线程执行结束后的返回值</li></ol><p>call方法比run方法更加强大：可以有返回值，可以抛出异常</p><h2 id="使用executor框架"><a href="#使用executor框架" class="headerlink" title="使用executor框架"></a>使用executor框架</h2><p>JDK1.5引入的executor框架最大的优点就是把<strong>任务的提交和执行解耦</strong></p><p>开发者只需描述好要只需的任务，然后提交即可</p><ol><li>创建一个ExecutorService,<code>ExecutorService executorService = Executors.newFixedThreadPool(5);</code></li><li>若有返回值，将写好的runnable实例或者callable实例作为target submit即可，返回值是一个future对象，所以可以使用get方法获取返回值.</li><li>若无返回值，直接使用execute方法即可<code>ExecutorService.execute(Runnable command);</code></li></ol><p>executor框架的内部使用了线程池的机制，<strong>可以作为一个工厂类来创建线程池</strong></p><p><img src="/../img/executor.png" alt="executor"></p><p><img src="/../img/executor1.png" alt="executor1"></p><p>从上图可以看出，应用程序通过Executor框架控制上层的调度；而下层的调度由操作系统内核控制，下层的调度不受应用程序的控制。</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>一种多线程的处理形式，处理过程中可以将任务添加到队列中，然后在创建线程后自动启动这些任务。</p><h3 id="线程池的优势"><a href="#线程池的优势" class="headerlink" title="线程池的优势"></a><em><strong>线程池的优势</strong></em></h3><ol><li>线程和任务分离，线程可被重用，提升复用性</li><li>控制线程并发数量，统一管理，降低服务器压力</li><li>提升系统响应速度，因为线程池内的线程可以被复用，且线程池内有核心线程待命，所以就减少了创建线程和销毁线程的时间。</li></ol><h3 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a><em><strong>为什么要使用线程池</strong></em></h3><p>JAVA线程的创建十分昂贵，需要JVM和OS配合完成大量的工作</p><ol><li>必须为线程堆栈分配和初始化大量的内存块，其中至少包含1MB的栈内存</li><li>JVM的线程模型为1:1模型，即JVM的线程和OS的线程是1:1对应的，需要进行系统调用，以便在OS中创建和注册本地线程</li></ol><p>Java的高并发应用频繁创建和销毁线程的操作是十分低效的，且不符合编程规范的，所以需要使用线程池来独立负责线程的创建维护和分配，以提升性能，减少资源消耗。</p><p>应用场景：网购商品秒杀，云盘文件上传，旅行系统购票等等</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//构造方法:</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize, //核心线程数量</span><br><span class="hljs-params">                              <span class="hljs-type">int</span> maximumPoolSize,//     最大线程数</span><br><span class="hljs-params">                              <span class="hljs-type">long</span> keepAliveTime, //       最大空闲时间</span><br><span class="hljs-params">                              TimeUnit unit,         //        时间单位</span><br><span class="hljs-params">                              BlockingQueue&lt;Runnable&gt; workQueue,   //   任务队列</span><br><span class="hljs-params">                              ThreadFactory threadFactory,    // 线程工厂</span><br><span class="hljs-params">                              RejectedExecutionHandler handler  //  饱和处理机制</span><br><span class="hljs-params">)</span> <br></code></pre></td></tr></table></figure><p>参数解释：</p><ol><li>corePoolSize : 指空闲也不允许被销毁的线程，随时待命存放于线程池中</li><li>maximumPoolSize：指最大线程数，当任务队列满时，需要创建临时进程处理无法进入任务队列的任务。当临时进程空闲时，会被销毁</li><li>keepAliveTime&amp;TimeUnit：最大空闲时间和时间单位，当临时进程空闲时间超过最大空闲时间后，便会被销毁</li><li>BlockingQueue：阻塞队列，当核心线程均不空闲时，任务进入队列等待。队列可以用多种数据结构实现，<strong>永远推荐使用有界队列</strong>，即由数组实现的队列，并设立合理的长度。避免造成等待任务过多消耗系统资源。</li><li>ThreadFactory ：线程工厂，手动命名创建线程的工厂，方便抛出错误后定位相应线程池</li><li>RejectedExecutionHandler：拒绝策略，当任务队列满且所有线程均不空闲时，启用饱和处理机制</li></ol><p><strong>线程池的阻塞队列</strong></p><ol><li><strong>ArrayBlockingQueue</strong>：底层采用数组实现的有界队列，初始化需要指定队列的容量。ArrayBlockingQueue 是如何保证线程安全的呢？它内部是使用了一个重入锁 ReentrantLock，并搭配 notEmpty、notFull 两个条件变量 Condition 来控制并发访问。从队列读取数据时，如果队列为空，那么会阻塞等待，直到队列有数据了才会被唤醒。如果队列已经满了，也同样会进入阻塞状态，直到队列有空闲才会被唤醒。</li><li><strong>LinkedBlockingQueue</strong>：底层采用的数据结构是链表，队列的长度可以是有界或者无界的，初始化不需要指定队列长度，默认是 Integer.MAX_VALUE。LinkedBlockingQueue 内部使用了 takeLock、putLock两个重入锁 ReentrantLock，以及 notEmpty、notFull 两个条件变量 Condition 来控制并发访问。采用**读锁和写锁(锁分离)**的好处是可以避免读写时相互竞争锁的现象，所以相比于 ArrayBlockingQueue，LinkedBlockingQueue 的性能要更好。</li><li><strong>SynchronousQueue</strong>：又称无缓冲队列。比较特别的是 SynchronizedQueue 内部不会存储元素。与 ArrayBlockingQueue、LinkedBlockingQueue 不同，SynchronizedQueue 直接使用 CAS 操作控制线程的安全访问。其中 put 和 take 操作都是阻塞的，每一个 put 操作都必须阻塞等待一个 take 操作，反之亦然。所以 SynchronizedQueue 可以理解为生产者和消费者配对的场景，双方必须互相等待，直至配对成功。在 JDK 的线程池 Executors.newCachedThreadPool 中就存在 SynchronousQueue 的运用，对于新提交的任务，如果有空闲线程，将重复利用空闲线程处理任务，否则将新建线程进行处理。</li><li><strong>PriorityBlockingQueue</strong>：底层最小堆实现的优先级队列，队列中的元素按照优先级进行排列，每次出队都是返回优先级最高的元素。PriorityBlockingQueue 内部是使用了一个 ReentrantLock 以及一个条件变量 Condition notEmpty 来控制并发访问，不需要 notFull 是因为 PriorityBlockingQueue 是无界队列，所以每次 put 都不会发生阻塞。PriorityBlockingQueue 底层的最小堆是采用数组实现的，当元素个数大于等于最大容量时会触发扩容，在扩容时会先释放锁，保证其他元素可以正常出队，然后使用 CAS 操作确保只有一个线程可以执行扩容逻辑。</li></ol><h2 id="如何确定核心线程数，最大线程数，任务队列长度"><a href="#如何确定核心线程数，最大线程数，任务队列长度" class="headerlink" title="如何确定核心线程数，最大线程数，任务队列长度"></a>如何确定核心线程数，最大线程数，任务队列长度</h2><p>核心线程数：IO密集型：CPU数*2；CPU密集型：CPU数+1</p><p>最大线程数：(每秒产生的最大任务数-任务队列长度)*单个任务执行时间</p><p>任务队列长度：核心线程数&#x2F;单个任务执行时间*2</p><h2 id="饱和处理机制有哪些"><a href="#饱和处理机制有哪些" class="headerlink" title="饱和处理机制有哪些"></a>饱和处理机制有哪些</h2><ol><li>AbortPolicy：丢弃任务并抛出异常</li><li>DiscardPolicy：丢弃任务不抛出异常</li><li>DiscardOldestPolicy：丢弃最前面的任务，然后重新提交被拒绝的任务</li><li>CallerRunsPolicy：直接调用线程处理该任务</li></ol><h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>CAS全称为compare and swap，即比较和交换</p><p>这是JDK提供的原子性操作。语义上是两步操作，但是CPU一条指令即可以完成</p><p>汇编指令：lock cmpxchg  </p><p>原子性保证lock：当执行cmpxchg时，其他CPU不允许打断这个操作，lock是硬件级的实现：锁定北桥信号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//unsafe包中的CAS操作，硬件级的原子操作</span><br><span class="hljs-comment">//更新变量值为x，如果当前值为expected</span><br><span class="hljs-comment">//o：对象 offset：偏移量 expected：期望值 x：新值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapObject</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, Object expected, Object x)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapInt</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> expected, <span class="hljs-type">int</span> x)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapLong</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, <span class="hljs-type">long</span> expected, <span class="hljs-type">long</span> x)</span>;<br></code></pre></td></tr></table></figure><p><strong>如果对象中的变量值为expect，则使用新的值update替换expect</strong></p><p><strong>替换成功，返回true；替换失败，即变量值不为expect，返回false；</strong></p><p>特点：非阻塞，即允许多个线程对共享资源进行修改，但是同一时刻只有一个线程可以进行写操作，其他线程并不是被阻塞，而是在不停重试拿到锁。</p><p>在JAVA中若一个线程没有拿到锁被阻塞，就会造成线程的上下文切换，大量线程的重新调度会造成性能的浪费。</p><p>volatile只能保证<strong>有序性和可见性</strong>，不能保证原子性。CAS就保证了<strong>原子性</strong>。</p><p>CAS和volatile两者可以实现无锁并发</p><p>所以自旋锁便是通过CAS来实现的，在获取锁的时候使用while循环不断进行CAS操作，类似于不断旋转，直到操作成功返回<code>true</code>，在释放锁的时候使用CAS将锁的状态从1变成0。</p><img src="../img/CAS.png" alt="CAS" style="zoom: 80%;" /><h4 id="ABA问题："><a href="#ABA问题：" class="headerlink" title="ABA问题："></a>ABA问题：</h4><p>假如线程1使用CAS修改初始值为A的变量X&#x3D;A，那么线程1首先会获取当前变量X的值（A），然后使用CAS操作尝试修改X的值为B，如果使用CAS修改成功了，那么程序运行一定是正常的吗？</p><p>有可能在线程1获取到变量X的值A后，在执行CAS之前，线程2使用了CAS修改了变量X值为B，然后又使用了CAS操作使得变量X值为A，虽然线程A执行了CAS操作时X&#x3D;A，但是这个A已经不是线程1获取到的A了。这就是ABA问题，ABA问题的产生是因为变量的状态值产生了<strong>环形转换</strong>，就是变量值可以从A到B，也可以B到A，如果变量的值只能朝着一个方向转换，例如A到B，B到C，不构成环路，就不会存在这个问题。</p><h4 id="如何解决ABA问题"><a href="#如何解决ABA问题" class="headerlink" title="如何解决ABA问题"></a><em><strong>如何解决ABA问题</strong></em></h4><p><strong>引入原子类：</strong></p><p><strong>AtomicStampedReference</strong> 是通过版本号<strong>（时间戳）</strong>来解决 ABA 问题的，也可以使用版本号（verison）来解决 ABA，即乐观锁每次在执行数据的修改操作时，都带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行 +1 操作，否则执行失败。</p><p><strong>AtomicMarkableReference</strong> 则是将一个 <strong>boolean 值</strong>作是否有更改的标记，本质就是它的版本号只有两个，true 和 false，修改的时候在两个版本号之间来回切换，虽然这样做并不能解决 ABA 的问题，但是会降低 ABA 问题发生的几率。</p><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>即线程本地变量，使公共变量可以在多个线程内进行隔离访问</p><p><code>static ThreadLocal&lt;Object&gt; TL = new ThreadLocal&lt;&gt;();</code></p><p>若线程1对TL设置内容Value1，此时线程2是无法通过get方法拿到Value1的</p><h3 id="常用方法及实现原理"><a href="#常用方法及实现原理" class="headerlink" title="常用方法及实现原理"></a>常用方法及实现原理</h3><p>set (T value)：设置线程本地变量的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-comment">// 获取当前线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">// 获取当前线程的threadLocals字段</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-comment">// 判断线程的threadLocals是否初始化了</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//this就是公共变量TL</span><br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 没有则创建一个ThreadLocalMap对象进行初始化</span><br>        createMap(t, value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每一个thread对象里都会自带一个threadLocals对象，而这个对象就是ThreadLocalMap的实例</p><p>ThreadLocalMap就是一个存储Entry即键值对的数组，初始化时threadLocals会设置为null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p><strong>所以set方法并不是往tl对象里面装内容，而是以tl的引用为K，value为V，生成Entry装入该线程的map中</strong></p><h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><p>ThreadLocalMap实现了map接口，但是和hashmap不同，它没有链表或者红黑树，<strong>它就是一个散列数组</strong></p><p>当发生哈希碰撞的时候，ThreadLocalMap会以<strong>线性探测</strong>的方式：即指针向后不断移动直到找到null或者相同的key为止，这种方式来存储元素。</p><p>ThreadLocalMap的hash值计算：使用<code>斐波那契数的倍数</code> 和<code>(len -1)</code> 按位与：<code>int i = key.threadLocalHashCode &amp; (len - 1);</code></p><p>ThreadLocalMap的扩容：当元素数大于len*2&#x2F;3时，便会启动扩容，同样是2倍扩容</p><p>过期数据的清理：</p><ol><li>探测式清理：从开始位置向后遍历，清除过期元素，将遍历到的过期数据的 <code>Entry</code> 设置为 <code>null</code> ，沿途碰到的未过期的数据则将其 <code>rehash</code> 后重新在 <code>table</code> 中定位，如果定位到的位置有数据则往后遍历找到第一个 <code>Entry=null</code> 的位置存入。接着继续往后检查过期数据，直到遇到空的桶才终止探测。</li><li>启发式清理：从参数i开始向后遍历lg2n个位置，遍历中遇到位置上 <code>key=null</code> 时，从此处同步调用探测时清理方法。</li></ol><p>get()：获取线程本地变量的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 获取ThreadLocal对应保留在Map中的Entry对象</span><br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-comment">// 获取ThreadLocal对象对应的值</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// map还没有初始化时创建map对象，并设置null，同时返回null</span><br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/ThreadLocal.png" alt="ThreadLocal"></p><p>Entry继承了弱引用类，说明这里的每一个Entry都是一个弱引用，弱引用的使用可以避免内存泄漏</p><p><img src="/../img/threadLocal1.png" alt="threadLocal1"></p><p><img src="/../img/ThreadLocal2.png" alt="ThreadLocal2"></p><p>ThreadLocal对象的作用：</p><ol><li>引用作为key来进行查找entry的值</li><li>维护map，ThreadLocalMap的设置删除都是由ThreadLocal来进行的</li></ol><p>在ThreadLocalMap的set&#x2F;getEntry中，会对key进行判断，<strong>如果key为null，那么value也会被设置为null</strong>，这样即使在忘记调用了remove方法，当ThreadLocal被销毁时，对应value的内容也会被清空，避免了内存泄漏。</p><h3 id="为什么ThreadLocal包装的变量可以实现线程隔离？"><a href="#为什么ThreadLocal包装的变量可以实现线程隔离？" class="headerlink" title="为什么ThreadLocal包装的变量可以实现线程隔离？"></a><em>为什么ThreadLocal包装的变量可以实现线程隔离？</em></h3><p>thread对象内不方便手动添加成员变量，所以就使用ThreadLocal来实现成员变量的效果。ThreadLocal对象本身不存储值，而是作为一个key来查找不同线程中的map的value，不同线程<strong>以ThreadLocal的弱引用作为key的Entry里的Value肯定都是不同的</strong>，每一个线程内的map都保存了一份副本各玩儿各的，所以就实现了线程隔离。</p><h2 id="ThreadLocal的应用场景"><a href="#ThreadLocal的应用场景" class="headerlink" title="ThreadLocal的应用场景"></a><em>ThreadLocal的应用场景</em></h2><ol><li>Spring的@Transaction事务声明的注解中就使用ThreadLocal保存了当前的Connection对象，避免在本次调用的不同方法中使用不同的Connection对象。</li><li>依赖于ThreadLocal本身的特性，对于需要进行线程隔离的变量可以使用ThreadLocal进行封装</li></ol><h1 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h1><p>同步锁，保证在同一时刻，被修饰的代码块或方法只有一个线程执行，以达到并发安全的效果</p><p>同步锁是解决并发问题最简单的一种方法，直接给代码块加上此关键字即可</p><p>在JDK1.5之前，Synchronized是一个重量级锁，在以后的版本经过改进后成重量级减小</p><p>synchronized的作用主要有三个：</p><ol><li><strong>原子性</strong>：确保线程<strong>互斥</strong>地访问同步代码；</li><li><strong>可见性</strong>：保证共享变量的修改能够及时可见，其实是通过Java内存模型中的“<strong>对一个变量unlock操作之前，必须要同步到主内存中</strong>；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值” 来保证的；</li><li><strong>有序性</strong>：有效解决重排序问题，即 “一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”；</li></ol><h2 id="底层实现："><a href="#底层实现：" class="headerlink" title="底层实现："></a>底层实现：</h2><p>对象在JVM的内存布局为：对象头+实例数据+对齐填充</p><h3 id="对象头（12字节）"><a href="#对象头（12字节）" class="headerlink" title="对象头（12字节）"></a>对象头（12字节）</h3><p>其中有4字节的class pointer和8字节的MarkWord</p><p>后者是实现锁的关键，MarkWord被设计成一个非固定的数据，它会根据对象的状态复用自身的空间，即会随着程序的运行发生变化。MarkWord的最后三字节分别为：<strong>1bit记录是否为偏向锁</strong>；<strong>2bit记录锁标志位。</strong>当锁标志位变为00时为轻量级锁，01代表未锁定或者可加偏向锁，10时为重量级锁。</p><h3 id="Monitor对象"><a href="#Monitor对象" class="headerlink" title="Monitor对象"></a>Monitor对象</h3><p>如果使用Synchronize修饰了一个对象，则MarkWord就会指向一个唯一的Monitor对象，并将标志位改为10，由操作系统提供</p><p>Monitor中有三个变量，分别是Owner、EntryList和WaitSet</p><p>Owner：当线程抢占到锁后，Owner就会指向该线程</p><p>EntryList：当其他线程以自旋形式抢占Owner超过阈值后，便会进入阻塞状态，放入EntryList，等待被唤醒</p><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><ol><li>thread0执行synchronize代码的时候，synchronized(obj)的obj对象的markword中ptr_to_heavyweight_monitor（指向monitor的指针）会指向一个monitor对象，执行cas操作将monitor的owner设置为thread0。<strong>在字节码中对应monitorenter操作指令</strong></li><li>thread1执行到synchronized代码时,发现obj的markword指向了一个monitor并且owner不为null 并且不为抢锁线程,这时会进入entrylist进行blocked，thread2也一样</li><li>thread0执行完同步代码退出synchronized，把obj markword里的数据还原比如hashcode，这些数据是存在monitor对象中的，然后根据不同的策略去唤醒entrylist的thread1和thread2的blocked线程，两个线程去抢owner。<strong>在字节码中对应monitorexit操作指令</strong></li></ol><h3 id="偏向锁："><a href="#偏向锁：" class="headerlink" title="偏向锁："></a>偏向锁：</h3><p>当一个线程访问加了同步锁的代码块时，<strong>会在对象头中存储当前线程的 ID</strong>，<strong>后续这个线程进入和退出这段加了同步锁的代码块时，不需要再次加锁和释放锁</strong>。而是直接比较对象头里面是否存储了指向当前线程的偏向锁。如果相等表示偏向锁是偏向于当前线程的，就不需要再尝试获得锁了。</p><p>说白了就是消除无竞争情况下的性能消耗，避免一个线程的情况下也去竞争锁，造成浪费资源。</p><p>底层实现原理：</p><ol><li>首先获取锁 对象的 MarkWord，判断是否处于可偏向状态。偏向锁状态位0，锁标志01</li><li>如果是可偏向状态，则通过 CAS 操作，把当前线程的 ID 写入到 MarkWord<br>a) 如果 CAS 成功，那么 MarkWord就会记录当前线程的ID。 表示已经获得了锁对象的偏向锁，接着执行同步代码块<br>b) 如果 CAS 失败，说明有其他线程已经获得了偏向锁，这种情况说明当前锁存在竞争，需要撤销已获得偏向锁的线程，并且把它持有的锁升级为轻量级锁（这个操作需要等到全局安全点，也就是没有线程在执行字节码）才能执行</li><li>如果是已偏向状态，需要检查 MarkWord 中存储的<br>线程ID 是否等于当前线程的 线程ID<br>a) 如果相等，不需要再次获得锁，可直接执行同步代码块<br>b) 如果不相等，说明当前锁偏向于其他线程，需要撤销偏向锁并升级到轻量级锁</li></ol><h3 id="轻量级锁："><a href="#轻量级锁：" class="headerlink" title="轻量级锁："></a>轻量级锁：</h3><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建 一个LockRecord</p><p>然后线程尝试使用CAS将对象头中的MarkWord替换为指向锁记录的指针(即00)，官方称为Displaced Mark Word，谁成功将LockRecord贴上去了，谁就拿到锁了。</p><p>如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p><p>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。</p><p>轻量级锁不进行阻塞，而是使用自旋的方式，自旋虽然提升了响应速度，但是会增大CPU的消耗</p><h3 id="重量级锁："><a href="#重量级锁：" class="headerlink" title="重量级锁："></a>重量级锁：</h3><p>当竞争加剧，比如自旋次数超过某一阈值，就会升级为重量级锁，JDK1.6之前，需要自己进行调优设置自旋阈值，需要参考CPU核数。而以后的版本加入了自适应自旋，由JVM自动控制。</p><p>此时需要向操作系统申请资源，申请mutex，将MarkWord替换为指向mutex的指针，拿到重量级锁</p><p>其他线程进入阻塞队列，等待OS的调度，wait状态的线程不消耗cpu</p><p>阻塞线程需要cpu从用户态转到内核态，代价比较大。而且可能会出现刚阻塞不久，锁就被释放的情况，所以阻塞的方式会降低响应速度</p><p>锁会随着线程的竞争情况逐渐升级，偏向锁 &#x3D;&gt; 轻量级锁 &#x3D;&gt; 重量级锁 。锁可以升级但是不能降级。升级的目的是为了提高获得锁和释放锁的效率。</p><h1 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h1><p>Volatile关键字的作用主要有如下两个：</p><ol><li>线程的可见性：当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。</li><li>顺序一致性：禁止指令重排序</li></ol><p>Volatile和synchronized的区别</p><ol><li>Volatile是轻量级的synchronized，因为它不会引起上下文的切换和调度，所以Volatile性能更好。</li><li>Volatile只能修饰变量，synchronized可以修饰方法，静态方法，代码块，类。</li><li>volatile仅能实现变量的修改可见性，并不能保证原子性，synchronized则可以保证原子性。</li><li>多线程访问volatile不会发生阻塞，而synchronized会发生阻塞。</li><li>volatile是变量在多线程之间的可见性，synchronize是多线程之间访问资源的同步性。</li></ol><h2 id="如何保证线程的可见性"><a href="#如何保证线程的可见性" class="headerlink" title="如何保证线程的可见性"></a>如何保证线程的可见性</h2><h4 id="JAVA的内存模型"><a href="#JAVA的内存模型" class="headerlink" title="JAVA的内存模型"></a>JAVA的内存模型</h4><p>线程之间的共享变量存储在主内存中，而每一个线程都有一个私有的本地内存，local memory存储了该线程读写的共享变量的副本。所以当一个线程在本地内存更新共享变量的副本后，需要重新写入主内存。</p><p>如何将新值刷新到主内存中：</p><p><strong>CPU寄存器-&gt;Cache-&gt;Main memory</strong>，写缓冲区可以避免处理器停顿下来等待写入数据而造成的延迟，并且写缓冲区可以合并多次写，减少对内存总线的占用。</p><p>但是在写入主内存之前，另外一个线程是看不到的，所以就需要volatile关键则来保证可见性</p><p>当线程对volatile修饰的变量进行写操作时，汇编指令会多出一个lock前缀，这就是<strong>内存屏障</strong>，而在多核心环境下，这个前缀会对应两个操作：</p><ol><li>将当前缓存行的数据<strong>立即</strong>写回系统内存</li><li>这个写回内存的操作会使其他cpu里缓存的副本无效化</li></ol><p>这就是缓存一致性协议，每个处理器通过嗅探在总线传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，从而需要重新从系统内存中读取数据。</p><p>所以多核心环境下，每一个线程读取被volatile修饰的变量时，都必须在主内存中读取最新的结果，而不是使用local memory内的数据，这样保证了一个线程修改变量的结果其他线程都是可知的，保证了线程的可见性。</p><h2 id="如何禁止指令重排"><a href="#如何禁止指令重排" class="headerlink" title="如何禁止指令重排"></a>如何禁止指令重排</h2><p>同样依赖于lock前缀，即内存屏障实现</p><p>编译器不会对volatile读与volatile读后面的任意内存操作重排序；</p><p>编译器不会对volatile写与volatile写前面的任意内存操作重排序。</p><p><img src="/../img/volatile1.png" alt="volatile1"></p><p><img src="/../img/volatile2.png" alt="volatile2"></p><p>Unsafe 方法</p><ol><li>**putOrderedXxx()**，使用 StoreStore 屏障，会把最新值更新到主内存，但不会立即失效其它缓存行中的数据，是一种延时更新机制；</li><li>**putXxxVolatile()**，使用 StoreLoad 屏障，会把最新值更新到主内存，同时会把其它缓存行的数据失效，或者说会刷新其它缓存行的数据；</li><li>**putXxx(obj, offset)**，不使用任何屏障，更新对象对应偏移量的值；</li><li>**getXxxVolatile()**，使用 LoadLoad 屏障，会从主内存获取最新值；</li><li>**getXxx(obj, offset)**，不使用任何屏障，读取对象对应偏移量的值；</li></ol><h1 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h1><p>synchronized存在一些问题：</p><ol><li><p>NonfairSync：加入持有锁的线程因为等待长时间IO或者其他原因，其他等待的线程无法响应中断，只能不断等待</p><p><code>公平锁即尽量以请求锁的顺序来获取锁。比如同时有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该锁。</code></p><p><code>非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。</code></p></li><li><p>synchronize是悲观锁，独占性很强，对读和写操作均是独占的</p></li><li><p>使用synchronized关键字无法确认线程是否成功获取到锁</p></li></ol><h2 id="异常是否释放"><a href="#异常是否释放" class="headerlink" title="异常是否释放"></a>异常是否释放</h2><p>synchronized关键字在发生异常时会自动释放占有的锁，因此不会出现死锁；而lock发生异常的时候，必须手动unlock来释放锁，可能会引起死锁。解决方式：try catch包裹代码块，finally中写入unlock</p><h2 id="是否响应中断"><a href="#是否响应中断" class="headerlink" title="是否响应中断"></a>是否响应中断</h2><p>lock可以用interrupt来中断等待，而synchronized只能不断等待锁的释放，不能响应中断</p><h2 id="是否知道获取锁"><a href="#是否知道获取锁" class="headerlink" title="是否知道获取锁"></a>是否知道获取锁</h2><p>lock可以通过trylock来知道有没有获取锁，而synchronized不能</p><h2 id="两者的异同"><a href="#两者的异同" class="headerlink" title="两者的异同"></a>两者的异同</h2><ol><li>在JDK1.5之前lock的性能优于synchronized，以后的版本，在不断优化降低锁的重量级后，两者的性能差距缩小。</li><li>lock是一个接口，而synchronized是一个关键字</li><li>lock可以有多个获取锁的方式，可以不用一直等待。而synchronized只能等待</li><li>Lock适合用于大量线程的同步，且大量线程竞争激烈时，lock的性能更优，lock锁还能使用readwritelock实现读写分离，提高多线程的读操作效率。</li><li>lock可以实现公平锁与非公平锁，synchronized只能实现非公平锁</li></ol><h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p>即AbstractQueuedSynchronizer类，抽象队列同步器，AQS是JUC的基类</p><p>基于 volitile修饰的状态记录量<strong>state</strong>+Node对象构建的双向链表，先进先出，也就是队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//node类携带的信号量</span><br><span class="hljs-comment">//排他锁标识</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">node</span> <span class="hljs-variable">EXCLUSIVE</span> <span class="hljs-operator">=</span>  <span class="hljs-literal">null</span>;<br><span class="hljs-comment">//后继节点需要被唤醒</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><span class="hljs-comment">//该节点已失效</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">//只有上一个节点是的ws为SIGNAL，当前节点才有可能被上一个节点唤醒</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> waitStatus;<br><br></code></pre></td></tr></table></figure><h3 id="加锁（非公平为例）"><a href="#加锁（非公平为例）" class="headerlink" title="加锁（非公平为例）"></a>加锁（非公平为例）</h3><p>当调用lock()时，线程会尝试使用CAS的方式将state从0改变为1，返回true则证明成功拿到锁，将ExclusiveOwnerThread指向当前线程。若为重入，则会增加state的值。</p><p>拿锁失败则会被放入队列。若队列为空，则会建立一个空节点作为哨兵，然后将此节点放在哨兵后。队列中的线程会acquireQueued()，内部由一个死循环实现，自旋地，独占且不可中断的方式获取同步状态，位于第二个节点的线程才有资格抢占锁，抢占后将晋升为头节点，原先的头节点会等待被GC。</p><p>若获取锁失败或无资格获取锁，则会则根据前驱节点的waitStatus决定是否需要挂起线程，若为SIGNAL，则当前节点被安全阻塞。</p><p>若为CANCELLED，则会向前查找到为SIGNAL的节点，并重新设置前驱节点，相当于是剔除了失效节点。</p><p>若为0或者其他状态，通过CAS的方式设置为SIGNAL</p><h3 id="锁的释放"><a href="#锁的释放" class="headerlink" title="锁的释放"></a>锁的释放</h3><p>release(int arg)，先检测state，若state减一后仍不为0，则代表有重入，返回false，等待下一次的释放。</p><p>当state为0时，才会进行unpark()，即释放锁</p><p>unparkSuccessor()，传入head节点，检测到后继节点中第一个waitStatus为-1的节点，并解除挂起状态</p><h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span><br></code></pre></td></tr></table></figure><p>互斥锁，可重入锁，也是可以实现公平锁和非公平锁（默认）的一种锁。内部包含一个AQS对象，并基于AQS实现</p><p>NonfairSync：非公平锁无论是队列里，还是外来线程，都会通过CAS直接尝试获取锁，能抢到锁到直接占有锁，抢不到才会到等待队列的队尾等待。</p><p>fairSync：公平锁则是所有线程并发进入acquire方法，通过hasQueuedPredecessors方法来严格控制队列获取锁的顺序，外来线程无法参与竞争。</p><p><img src="/../img/reentrantLock.png" alt="reentrantLock"></p><p>ReentrantLock内部有三个类</p><p><img src="/../img/reentrantLock1.png" alt="reentrantLock1"></p><h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p>CountDownLatch是一个倒数的计数器阀门，初始化时阀门关闭，指定计数的数量，当数量倒数减到0时阀门打开，被阻塞线程被唤醒</p><p>工作方式：初始值为线程数，当线程完成自己的任务后，计数器的值就减一，当计数器为0时，表示所有线程都已完成任务。然后等待的线程就可以恢复执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//构造函数，需要指定一个等于线程数的int数值</span><br>CountDownLatch(<span class="hljs-type">int</span> count);<br><span class="hljs-comment">//当前线程调用该方法会进入等待状态，直到同步器状态为0时被其他线程唤醒或者被其他线程中断。也即将计数器减为0返回true的线程负责唤醒阻塞的线程。当计数器为0时，调用await()方法将立即返回</span><br>await();<br><span class="hljs-comment">//该方法与await()作用一样，只是添加了等待的时间，如果超过等待时间还没有被唤醒或者被中断，那么阻塞线程将退出阻塞状态;</span><br>await(<span class="hljs-type">long</span> timeout, TimeUnit unit);<br><span class="hljs-comment">//该方法主要是将指定的计数器减1，当计数器已经是0了调用该方法将会被忽略，也就是说计数器的值最小只能是0</span><br>countDown();<br></code></pre></td></tr></table></figure><p>原理：维护一个AQS，将state设置为Count数量，当state为0时，才会唤醒队列中的线程</p><h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a><strong>CyclicBarrier</strong></h1><p>CyclicBarrier是一个可循环的屏障，它允许多个线程在执行完相应的操作后彼此等待共同到达一个point，等所有线程都到达后再继续执行。比如等所有运动员都跨过第一个栅栏后，才允许继续向前。</p><p>工作方式：初始值同样为线程数，当线程完成自己的任务后，计数器的值减一，若state不为0，则自身阻塞，直到state为0，即所有线程都完成任务后，才会从障碍点继续运行。</p><p>CyclicBarrier是可以循环的，每个线程可以调用两次的await()方法，重复利用栅栏的计数器。调用nextGeneration()方法，唤醒所有阻塞线程，并重置count。</p><p>原理：维护ReentryLock的Lock方法和Condition实现</p><p>而计数器阀门则不可以循环，count为0后就不能再使用。</p><h3 id="CyclicBarrier和CountDownLatch区别"><a href="#CyclicBarrier和CountDownLatch区别" class="headerlink" title="CyclicBarrier和CountDownLatch区别"></a>CyclicBarrier和CountDownLatch区别</h3><ol><li>CountDownLatch的await()线程会等待计数器减为0，而执行CyclicBarrier的await()方法会使线程进入阻塞等待其他线程到达障点</li><li>CountDownLatch计数器不能重置，CyclicBarrier可以重置循环利用，可以应对更多的情况，比如程序出错后重置</li><li>CountDownLatch是基于AQS的共享模式实现的，CyclicBarrier是基于ReentrantLock和Condition实现的</li><li>CountDownLatch会阻塞主线程，CyclicBarrier不会阻塞主线程，只会阻塞子线程</li></ol><h1 id="原子类Atomic"><a href="#原子类Atomic" class="headerlink" title="原子类Atomic"></a>原子类Atomic</h1><p><img src="/../img/Atomic%E8%AF%A6%E8%A7%A3.png" alt="Atomic详解"></p><p>基本类型</p><ol><li>AtomicInteger：线程安全的整型</li><li>AtomicBoolean：线程安全的布尔类型</li><li>AtomicLong：线程安全的长整型</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//都是通过CAS操作（unsafe）来实现的</span><br>getAndIncrement() <span class="hljs-comment">// 原子化 i++</span><br>getAndDecrement() <span class="hljs-comment">// 原子化的 i--</span><br>incrementAndGet() <span class="hljs-comment">// 原子化的 ++i</span><br>decrementAndGet() <span class="hljs-comment">// 原子化的 --i</span><br>    <br>getAndAdd(delta) <span class="hljs-comment">// 当前值 +=delta，返回 += 前的值</span><br>addAndGet(delta)<span class="hljs-comment">// 当前值 +=delta，返回 += 后的值</span><br>compareAndSet(expect, update)<span class="hljs-comment">//CAS 操作，返回是否成功</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//this对应着当前对应</span><br>    <span class="hljs-comment">//valueOffset对应着当前属性在对象中的内存偏移地址</span><br>    <span class="hljs-comment">//1代表着增加的数量</span><br>    <span class="hljs-comment">//注意是unsafe方法</span><br>    <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-built_in">this</span>, valueOffset, <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAddInt</span><span class="hljs-params">(Object var1, <span class="hljs-type">long</span> var2, <span class="hljs-type">int</span> var4)</span> &#123;<br>    <span class="hljs-type">int</span> var5;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">//获取在内存中的值</span><br>        var5 = <span class="hljs-built_in">this</span>.getIntVolatile(var1, var2);<br>    &#125; <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));<br>    <span class="hljs-comment">//自旋CAS，var5是希望的旧值，var5+var4是新值，只有当内存中的值等于var5，也就是当前内存中的值等于希望的旧值的时候，才会更新成功，返回true</span><br>    <span class="hljs-keyword">return</span> var5;<br>&#125;<br></code></pre></td></tr></table></figure><p>累加器</p><ol><li><strong>LongAdder</strong>(性能优)</li><li>LongAccumulator</li><li>DoubleAdder</li><li>DoubleAccumulator</li></ol><h2 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h2><p><img src="/../img/longadder.png" alt="longadder"></p><p>在多线程累加的情况下LongAdder拥有比synchronized,AtomicInteger,AtomicLong,LongAccumulator更高的性能</p><p>synchronized肯定是最慢的</p><p><img src="/../img/LongAdder1.png" alt="LongAdder1"></p><p> LongAdder在无竞争的情况，跟AtomicLong一样，对同一个base进行操作</p><p> 当出现竞争关系时则是采用一个数组cells，将一个value拆分进这个数组Cells</p><p>多个线程需要同时对value进行操作时，可以对线程id进行hash得到hash值，再根据hash值映射到这个数组cells的某个下标，再对该下标所对应的值进行自增操作。当所有线程操作完毕，将数组cells的所有值和无竞争值base都加起来作为最终结果。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><h4 id="为什么这么快"><a href="#为什么这么快" class="headerlink" title="为什么这么快"></a><em><strong>为什么这么快</strong></em></h4><p>LongAdder的基本思路就是<strong>分散热点</strong>，将value值分散到一个Cell数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。</p><p>无并发的时候，单线程下直接CAS操作更新base值。有并发的时候，多线程下分段CAS操作更新Cell数组值</p><p>如果要获取真正的long值，只要将各个槽中的变量值累加返回。sum()会将<strong>所有Cell数组中的value和base累加</strong>作为返回值</p><p>核心的思想就是将之前AtomicLong一个value的更新压力分散到多个value中去，从而降级更新热点。</p><h4 id="与AtomicLong的区别"><a href="#与AtomicLong的区别" class="headerlink" title="与AtomicLong的区别"></a><em><strong>与AtomicLong的区别</strong></em></h4><p><strong>原理不同：</strong></p><p>AtomicLong是以CAS的自旋方式来进行加减</p><p>LongAdder则是以CAS+Base+Cell数组分散热点，通过空间换时间分散了热点数据</p><p><strong>场景不同：</strong></p><p>AtomicLong适用于低并发下的全局计算，能保证并发情况下计数的准确性，可允许一些性能损耗，要求高精度时可使用</p><p>LongAdder适用于高并发下的全局计算，当需要在高并发下有较好的性能表现，且对值的精确度要求不高时，可以使用</p><p><strong>各有缺点：</strong></p><p>AtomicLong 高并发后性能急剧下降</p><p>LongAdder 求和后还有计算线程修改结果的话，最后结果不够准确</p><h1 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h1><h2 id="按抽象概念分"><a href="#按抽象概念分" class="headerlink" title="按抽象概念分"></a>按抽象概念分</h2><ol><li>悲观锁：悲观地认为数据大概率会被其他线程操作，所以具有强烈的独占性和排它性，比如synchronized，先加锁再执行代码块</li><li>乐观锁：相反，乐观地认为数据不大会被其他线程操作，所以先执行代码块，遇见线程冲突的情况，再补偿</li><li>自旋锁：自旋锁是乐观锁的一种实现形式，首先需要了解一些概念</li></ol><h2 id="按读写属性分"><a href="#按读写属性分" class="headerlink" title="按读写属性分"></a>按读写属性分</h2><ol><li>排他锁：又称写锁，X锁，只有一个线程能访问代码块，synchronized关键字即是排他锁。写的时候，不允许其他线程读，也不允许其他线程写</li><li>共享锁：又称读锁，S锁，可以有多个线程访问代码块，允许同时读，不允许写，必须等所有锁释放后才可以写</li><li>读写锁：概念同上</li></ol><h2 id="按粒度分"><a href="#按粒度分" class="headerlink" title="按粒度分"></a>按粒度分</h2><ol><li>统一锁：大粒度的锁，防止出现死锁。锁定A线程，等待B线程；锁定B，等待A；若没有很好地同步，就会出现死锁统一锁便是将A和B统一为一个大锁</li><li>分段锁：JDK1.7 ConcurrentHashMap，如果像HashTable那样锁住整张表，性能会很差，使用分段思想，只对某个segment进行锁定，当锁定一段时，不影响其他段的数据插入，提高了效率，缺点，代码实现复杂。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Java基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字典序问题</title>
    <link href="/post/%E5%AD%97%E5%85%B8%E5%BA%8F%E9%97%AE%E9%A2%98.html"/>
    <url>/post/%E5%AD%97%E5%85%B8%E5%BA%8F%E9%97%AE%E9%A2%98.html</url>
    
    <content type="html"><![CDATA[<p><strong>给你一个整数 <code>n</code> ，按字典序返回范围 <code>[1, n]</code> 内所有整数。</strong></p><p><strong>你必须设计一个时间复杂度为 <code>O(n)</code> 且使用 <code>O(1)</code> 额外空间的算法。</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">示例 <span class="hljs-number">1</span>：<br>输入：n = <span class="hljs-number">13</span><br>输出：[<span class="hljs-number">1,10,11,12</span>,<span class="hljs-number">13,2,3,4</span>,<span class="hljs-number">5,6,7,8</span>,<span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><p>思路：字典序的构建可以看成是一支十叉树</p><p>第一层是1位数字，第二层是2位数字，以此类推。</p><p>而十叉树的前序遍历即是字典序的输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">lexicalOrder</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">//从第一层开始</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; cur &lt;= <span class="hljs-number">9</span>; cur++) recursion(cur, n);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">recursion</span><span class="hljs-params">(<span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> limit)</span> &#123;<br>        <span class="hljs-comment">//前序遍历的终止条件</span><br>        <span class="hljs-keyword">if</span> (cur &gt; limit) <span class="hljs-keyword">return</span> ;<br>        ans.add(cur);<br>        <span class="hljs-comment">//进入下一层</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">9</span>; i++) recursion(cur * <span class="hljs-number">10</span> + i, limit);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>给定整数 <code>n</code> 和 <code>k</code>，返回 <code>[1, n]</code> 中字典序第 <code>k</code> 小的数字</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: n = 13, k = 2</span><br><span class="hljs-section">输出: 10</span><br><span class="hljs-section">解释: 字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。</span><br></code></pre></td></tr></table></figure><p>思路：其实按照第一题的思路可以解决，但是如果n十分巨大，全部遍历一遍会造成超时。</p><p>所以无需全部遍历，只需比较该节点下的子节点总数与k的大小即可</p><p>比较节点数与k的大小来判断是否需要进入子树，还是进入兄弟节点的子树</p><p>但是需要解决的问题是，有一些子树的节点不是满的，所以计算nodeCount时需要分情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">//从第一层的第一个节点开始扫描</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br>        k--;<br>        <span class="hljs-comment">//当k==0时，证明找到节点</span><br>        <span class="hljs-keyword">while</span>(k&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> cur;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> cur+<span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nodeCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//统计cur节点下所有子树的节点数</span><br>            <span class="hljs-keyword">while</span>(left&lt;=n)&#123;<br>                nodeCount+=Math.min(right,(<span class="hljs-type">int</span>)(n+<span class="hljs-number">1</span>))-left;<br>                left*=<span class="hljs-number">10</span>;<br>                right*=<span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-comment">//不在cur节点下，进入另一个节点</span><br>            <span class="hljs-keyword">if</span>(nodeCount&lt;=k)&#123;<br>                k-=nodeCount;<br>                cur++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//在cur节点下，进入cur的子树</span><br>                k--;<br>                cur*=<span class="hljs-number">10</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode初见</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微软面试题——24点游戏</title>
    <link href="/post/%E5%BE%AE%E8%BD%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94%E2%80%9424%E7%82%B9%E6%B8%B8%E6%88%8F.html"/>
    <url>/post/%E5%BE%AE%E8%BD%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94%E2%80%9424%E7%82%B9%E6%B8%B8%E6%88%8F.html</url>
    
    <content type="html"><![CDATA[<p><code>给定一个长度为4的整数数组 cards 。你有 4 张卡片，每张卡片上都包含一个范围在 [1,9] 的数字。您应该使用运算符 [&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;] 和括号 &#39;(&#39; 和 &#39;)&#39; 将这些卡片上的数字排列成数学表达式，以获得值24。</code></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: cards = [4, 1, 8, 7]</span><br><span class="hljs-section">输出: true</span><br><span class="hljs-section">解释: (8-4) * (7-1) = 24</span><br></code></pre></td></tr></table></figure><p>显而易见是回溯，但是由于题中给出除法是实数除法，所以必须使用double来进行计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-variable">Target</span> <span class="hljs-operator">=</span> <span class="hljs-number">24</span>;<br>    <span class="hljs-comment">//浮点数误差最小精度</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-variable">standard</span> <span class="hljs-operator">=</span> <span class="hljs-number">1e-6</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">judgePoint24</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cards)</span> &#123;<br>        <span class="hljs-keyword">return</span> backTrack(<span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[]&#123;cards[<span class="hljs-number">0</span>],cards[<span class="hljs-number">1</span>],cards[<span class="hljs-number">2</span>],cards[<span class="hljs-number">3</span>]&#125;);<br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(<span class="hljs-type">double</span>[] nums)</span>&#123;<br>        <span class="hljs-comment">//若最终结果与target的差值小于某一数值，则证明相等</span><br>        <span class="hljs-keyword">if</span>(nums.length ==<span class="hljs-number">1</span> )<span class="hljs-keyword">return</span> Math.abs(nums[<span class="hljs-number">0</span>]-Target)&lt;standard;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>;j&lt;nums.length;j++)&#123;<br>                <span class="hljs-comment">//建立一个数组，存储除选中的两个数以外的所有数和这两个数的运算结果</span><br>                <span class="hljs-type">double</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[nums.length-<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>,index=<span class="hljs-number">0</span>;index&lt;nums.length;index++)&#123;<br>                    <span class="hljs-keyword">if</span>(index!=i&amp;&amp;index!=j) next[k++] = nums[index];<br>                &#125;<br>                <span class="hljs-comment">//决策树选择</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">double</span> num:caculator(nums[i],nums[j]))&#123;<br>                    next[next.length-<span class="hljs-number">1</span>] = num;<br>                    <span class="hljs-keyword">if</span>(backTrack(next)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//存储两个数可以获得的所有运算结果</span><br>    ArrayList&lt;Double&gt; <span class="hljs-title function_">caculator</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span>&#123;<br>        ArrayList&lt;Double&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        list.add(a*b);<br>        list.add(a+b);<br>        list.add(a-b);<br>        list.add(b-a);<br>        <span class="hljs-comment">//若a绝对值小于精度，则可以认为a为零</span><br>        <span class="hljs-keyword">if</span>(!(Math.abs(a)&lt;standard)) list.add(b/a);<br>        <span class="hljs-keyword">if</span>(!(Math.abs(b)&lt;standard)) list.add(a/b);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode初见</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周赛笔记10/16/2022</title>
    <link href="/post/%E5%91%A8%E8%B5%9B%E7%AC%94%E8%AE%B010-16-2022.html"/>
    <url>/post/%E5%91%A8%E8%B5%9B%E7%AC%94%E8%AE%B010-16-2022.html</url>
    
    <content type="html"><![CDATA[<h2 id="6204-与对应负数同时存在的最大正整数"><a href="#6204-与对应负数同时存在的最大正整数" class="headerlink" title="6204. 与对应负数同时存在的最大正整数"></a><a href="https://leetcode.cn/problems/largest-positive-integer-that-exists-with-its-negative/">6204. 与对应负数同时存在的最大正整数</a></h2><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">给你一个 不包含 任何零的整数数组 nums ，找出自身与对应的负数都在数组中存在的最大正整数 k <br>输入：nums = [<span class="hljs-string">-1</span>,2,<span class="hljs-string">-3</span>,3]<br>输出：3<br>解释：3 是数组中唯一一个满足题目要求的 k 。<br></code></pre></td></tr></table></figure><p>一个HashSet+一遍遍历，秒解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxK</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        HashSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n:nums)&#123;<br>            <span class="hljs-keyword">if</span>(set.contains(-n)) res = Math.max(res,Math.abs(n));<br>            set.add(n);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res==Integer.MIN_VALUE?-<span class="hljs-number">1</span>:res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6205-反转之后不同整数的数目"><a href="#6205-反转之后不同整数的数目" class="headerlink" title="6205. 反转之后不同整数的数目"></a><a href="https://leetcode.cn/problems/count-number-of-distinct-integers-after-reverse-operations/">6205. 反转之后不同整数的数目</a></h2><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dns">给你一个由正整数组成的数组nums 。<br>你必须取出数组中的每个整数，反转其中每个数位，并将反转后得到的数字添加到数组的末尾。这一操作只针对 nums 中原有的整数执行。<br>返回结果数组中不同整数的数目。<br>输入：nums = [<span class="hljs-number">1,13,10,12</span>,<span class="hljs-number">31</span>]<br>输出：<span class="hljs-number">6</span><br>解释：反转每个数字后，结果数组是 [<span class="hljs-number">1,13,10,12</span>,<span class="hljs-number">31,1,31,1</span>,<span class="hljs-number">21</span>,<span class="hljs-number">13</span>] 。<br>反转后得到的数字添加到数组的末尾并按斜体加粗表示。注意对于整数 <span class="hljs-number">10</span> ，反转之后会变成 <span class="hljs-number">01</span> ，即 <span class="hljs-number">1</span> 。<br>数组中不同整数的数目为 <span class="hljs-number">6</span>（数字 <span class="hljs-number">1、10、12、13</span>、<span class="hljs-number">21</span> 和 <span class="hljs-number">31</span>）<br></code></pre></td></tr></table></figure><p>同样一个HashSet+一遍遍历，秒解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countDistinctIntegers</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        HashSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)&#123;<br>            <span class="hljs-keyword">if</span>(num==<span class="hljs-number">1</span>) &#123;<br>                set.add(num);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            set.add(num);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(num!=<span class="hljs-number">0</span>)&#123;<br>                n=n*<span class="hljs-number">10</span>+num%<span class="hljs-number">10</span>;<br>                num/=<span class="hljs-number">10</span>;<br>            &#125;<br>            set.add(n);<br>        &#125;<br>        <span class="hljs-keyword">return</span> set.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6219-反转之后的数字和"><a href="#6219-反转之后的数字和" class="headerlink" title="6219. 反转之后的数字和"></a><a href="https://leetcode.cn/problems/sum-of-number-and-its-reverse/">6219. 反转之后的数字和</a></h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入：<span class="hljs-built_in">num</span> = <span class="hljs-number">443</span><br>输出：<span class="hljs-keyword">true</span><br>解释：<span class="hljs-number">172</span> + <span class="hljs-number">271</span> = <span class="hljs-number">443</span> ，所以返回 <span class="hljs-keyword">true</span> 。<br></code></pre></td></tr></table></figure><p>我以为我的方法很笨，但是发现大家都是同样的解法…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sumOfNumberAndReverse</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">if</span>(num==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=num;i++)&#123;<br>            <span class="hljs-keyword">if</span>((i+reverseNum(i))==num) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">reverseNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(num!=<span class="hljs-number">0</span>)&#123;<br>            n=n*<span class="hljs-number">10</span>+num%<span class="hljs-number">10</span>;<br>            num/=<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6207-统计定界子数组的数目"><a href="#6207-统计定界子数组的数目" class="headerlink" title="6207. 统计定界子数组的数目"></a><a href="https://leetcode.cn/problems/count-subarrays-with-fixed-bounds/">6207. 统计定界子数组的数目</a></h2><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pf">给你一个整数数组 nums 和两个整数 <span class="hljs-keyword">min</span>K 以及 <span class="hljs-keyword">max</span>K 。<br>nums 的定界子数组是满足下述条件的一个子数组：<br>子数组中的最小值等于 <span class="hljs-keyword">min</span>K<br>子数组中的最大值等于 <span class="hljs-keyword">max</span>K<br>返回定界子数组的数目。<br>子数组是数组中的一个连续部分<br>输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>], <span class="hljs-keyword">min</span>K = <span class="hljs-number">1</span>, <span class="hljs-keyword">max</span>K = <span class="hljs-number">5</span><br>输出：<span class="hljs-number">2</span><br>解释：定界子数组是 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>] 和 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>] 。<br></code></pre></td></tr></table></figure><p>发呆一小时，没写出来…</p><p>看了好几个解析，写了一个自己的解法，然后有一些自己的理解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countSubarrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> minK, <span class="hljs-type">int</span> maxK)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, minIndex = -<span class="hljs-number">1</span>, maxIndex = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">//定位出现最大最小值的索引</span><br>            <span class="hljs-keyword">if</span> (nums[i] == minK) minIndex = i;<br>            <span class="hljs-keyword">if</span> (nums[i] == maxK) maxIndex = i;<br>            <span class="hljs-comment">//刚进来的数影响了最大值或最小值</span><br>            <span class="hljs-keyword">if</span> (nums[i] &lt; minK || nums[i] &gt; maxK) &#123;<br>                <span class="hljs-comment">//将left定位到刚好不出现越界值的位置</span><br>                left = i + <span class="hljs-number">1</span>;<br>                minIndex = maxIndex = -<span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//当窗口内同时包含最大值和最小值时，更新结果</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (minIndex != -<span class="hljs-number">1</span> &amp;&amp; maxIndex != -<span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Math.min(minIndex, maxIndex);<br>                res += min - left + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode初见</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>子序列数目</title>
    <link href="/post/%E5%AD%90%E5%BA%8F%E5%88%97%E6%95%B0%E7%9B%AE.html"/>
    <url>/post/%E5%AD%90%E5%BA%8F%E5%88%97%E6%95%B0%E7%9B%AE.html</url>
    
    <content type="html"><![CDATA[<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出：<span class="hljs-number">7</span><br>解释：<span class="hljs-number">7</span> 个不同的子序列分别是 <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;ab&quot;</span>, <span class="hljs-string">&quot;ac&quot;</span>, <span class="hljs-string">&quot;bc&quot;</span>, 以及 <span class="hljs-string">&quot;abc&quot;</span>。<br></code></pre></td></tr></table></figure><p>难度：hard</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//状态转移方程真的不好写，所以我不想用动态规划</span><br>    <span class="hljs-comment">//思路：以c结尾的子串数目等于：以c之前的所有字母结尾的子序列数目的总和+1</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">distinctSubseqII</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">char</span>[] arr = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-type">int</span>[] alphaBet  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//求总和</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j:alphaBet)sum=(sum+j)%<span class="hljs-number">1000000007</span>;<br>            <span class="hljs-comment">//+1即加上自身</span><br>            alphaBet[arr[i]-<span class="hljs-string">&#x27;a&#x27;</span>] = (<span class="hljs-type">int</span>)sum+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : alphaBet) res = (res+i)%<span class="hljs-number">1000000007</span>;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode初见</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周赛笔记10/9/2022</title>
    <link href="/post/%E5%91%A8%E8%B5%9B%E7%AC%94%E8%AE%B010-9-2022.html"/>
    <url>/post/%E5%91%A8%E8%B5%9B%E7%AC%94%E8%AE%B010-9-2022.html</url>
    
    <content type="html"><![CDATA[<h2 id="2432-处理用时最长的那个任务的员工"><a href="#2432-处理用时最长的那个任务的员工" class="headerlink" title="2432. 处理用时最长的那个任务的员工"></a><a href="https://leetcode.cn/problems/the-employee-that-worked-on-the-longest-task/">2432. 处理用时最长的那个任务的员工</a></h2><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 10, logs = [[0,3],[2,5],[0,9],[1,15]]<br>输出：1<br>解释：<br>任务<span class="hljs-number"> 0 </span>于时刻<span class="hljs-number"> 0 </span>开始，且在时刻<span class="hljs-number"> 3 </span>结束，共计<span class="hljs-number"> 3 </span>个单位时间。<br>任务<span class="hljs-number"> 1 </span>于时刻<span class="hljs-number"> 3 </span>开始，且在时刻<span class="hljs-number"> 5 </span>结束，共计<span class="hljs-number"> 2 </span>个单位时间。<br>任务<span class="hljs-number"> 2 </span>于时刻<span class="hljs-number"> 5 </span>开始，且在时刻<span class="hljs-number"> 9 </span>结束，共计<span class="hljs-number"> 4 </span>个单位时间。<br>任务<span class="hljs-number"> 3 </span>于时刻<span class="hljs-number"> 9 </span>开始，且在时刻<span class="hljs-number"> 15 </span>结束，共计<span class="hljs-number"> 6 </span>个单位时间。<br>时间最长的任务是任务<span class="hljs-number"> 3 </span>，而 id 为<span class="hljs-number"> 1 </span>的员工是处理此任务的员工，所以返回<span class="hljs-number"> 1 </span>。<br></code></pre></td></tr></table></figure><p>突发奇想，想练习一下sort方法的运用熟练程度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hardestWorker</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] logs)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=logs.length-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">else</span> logs[i][<span class="hljs-number">1</span>]-=logs[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>        &#125;<br>        Arrays.sort(logs,(a,b)-&gt;&#123;<br>            <span class="hljs-keyword">if</span>(b[<span class="hljs-number">1</span>]!=a[<span class="hljs-number">1</span>])<span class="hljs-keyword">return</span> b[<span class="hljs-number">1</span>]-a[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>]-b[<span class="hljs-number">0</span>];<br>        &#125;);<br>        <span class="hljs-keyword">return</span> logs[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2433-找出前缀异或的原始数组"><a href="#2433-找出前缀异或的原始数组" class="headerlink" title="2433. 找出前缀异或的原始数组"></a><a href="https://leetcode.cn/problems/find-the-original-array-of-prefix-xor/">2433. 找出前缀异或的原始数组</a></h2><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：pref = [5,2,0,3,1]<br>输出：[5,7,2,3,2]<br>解释：从数组 [5,7,2,3,2] 可以得到如下结果：<br>- pref[0] = 5<br>- pref[1] =<span class="hljs-number"> 5 </span>^<span class="hljs-number"> 7 </span>= 2<br>- pref[2] =<span class="hljs-number"> 5 </span>^<span class="hljs-number"> 7 </span>^<span class="hljs-number"> 2 </span>= 0<br>- pref[3] =<span class="hljs-number"> 5 </span>^<span class="hljs-number"> 7 </span>^<span class="hljs-number"> 2 </span>^<span class="hljs-number"> 3 </span>= 3<br>- pref[4] =<span class="hljs-number"> 5 </span>^<span class="hljs-number"> 7 </span>^<span class="hljs-number"> 2 </span>^<span class="hljs-number"> 3 </span>^<span class="hljs-number"> 2 </span>= 1<br></code></pre></td></tr></table></figure><p>寻找数学规律即可，只不过确实需要自己写例子推导一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findArray(<span class="hljs-type">int</span>[] pref) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> pref.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> pref;<br>        res[<span class="hljs-number">0</span>] = pref[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,p=<span class="hljs-number">1</span>;i&lt;n-<span class="hljs-number">1</span>&amp;&amp;p&lt;n;i++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>;<br>                res[p++] = pref[i]^pref[j];<br>            &#125;<br>        <span class="hljs-keyword">return</span> res;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2435-矩阵中和能被-K-整除的路径"><a href="#2435-矩阵中和能被-K-整除的路径" class="headerlink" title="2435. 矩阵中和能被 K 整除的路径"></a><a href="https://leetcode.cn/problems/paths-in-matrix-whose-sum-is-divisible-by-k/">2435. 矩阵中和能被 K 整除的路径</a></h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">给你一个下标从 <span class="hljs-number">0</span> 开始的 m x n 整数矩阵 <span class="hljs-attribute">grid</span> 和一个整数 k <br>你从起点 (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) 出发，每一步只能往下或者往右 ，你想要到达终点 (m - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>) 。<br><br>请你返回路径和能被 k 整除的路径数目，由于答案可能很大，返回答案对 <span class="hljs-number">109</span> + <span class="hljs-number">7</span> 取余 的结果。<br></code></pre></td></tr></table></figure><p>我刚开始觉得应该是回溯，因为是图的路径问题，但是有几个用例总是无法通过</p><p>最后看解析才发现需要使用DP，确实有点难，特别是状态转换方程的推导</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfPaths</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-comment">//记忆化搜索</span><br>        <span class="hljs-type">int</span>[][][] c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n][k];<span class="hljs-comment">//记录dp值</span><br>        c[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]%k]++;<span class="hljs-comment">//记录第一个元素dp值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;m; i++)&#123;<span class="hljs-comment">//记录第一列元素dp值</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; l&lt;k; l++)&#123;<br>                c[i][<span class="hljs-number">0</span>][(l+grid[i][<span class="hljs-number">0</span>])%k] += c[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][l];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;n; j++)&#123;<span class="hljs-comment">//记录第一行元素dp值</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; l&lt;k; l++)&#123;<br>                c[<span class="hljs-number">0</span>][j][(l+grid[<span class="hljs-number">0</span>][j])%k] += c[<span class="hljs-number">0</span>][j-<span class="hljs-number">1</span>][l];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;m; i++)&#123;<span class="hljs-comment">//记录其他元素dp值</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;n; j++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; l&lt;k; l++)&#123;<br>                    c[i][j][(l+grid[i][j])%k] += c[i-<span class="hljs-number">1</span>][j][l];<br>                    c[i][j][(l+grid[i][j])%k] += c[i][j-<span class="hljs-number">1</span>][l];<br>                &#125;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; l&lt;k; l++)&#123;<span class="hljs-comment">//避免整数溢出</span><br>                    <span class="hljs-keyword">if</span>(c[i][j][l] &gt;= <span class="hljs-number">1000000007</span>) c[i][j][l] -=<span class="hljs-number">1000000007</span> ;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> c[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode初见</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位运算技巧</title>
    <link href="/post/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7.html"/>
    <url>/post/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7.html</url>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//位运算算法技巧</span><br><span class="hljs-comment">//不用临时变量交换两个数</span><br>a ^= b;<br>b ^= a;<br>a ^= b;<br><span class="hljs-comment">//判断是否异号（同号）</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> ((x ^ y) &lt; <span class="hljs-number">0</span>);<br><span class="hljs-comment">//利用或操作 | 和空格将英文字符转换为小写</span><br>(<span class="hljs-string">&#x27;A&#x27;</span> | <span class="hljs-string">&#x27; &#x27;</span>) = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-comment">//利用与操作 &amp; 和下划线将英文字符转换为大写</span><br>(<span class="hljs-string">&#x27;b&#x27;</span> &amp; <span class="hljs-string">&#x27;_&#x27;</span>) = <span class="hljs-string">&#x27;B&#x27;</span>;<br><span class="hljs-comment">//利用异或操作 ^ 和空格进行英文字符大小写互换</span><br>(<span class="hljs-string">&#x27;D&#x27;</span> ^ <span class="hljs-string">&#x27; &#x27;</span>) = <span class="hljs-string">&#x27;d&#x27;</span>;<br><span class="hljs-comment">//去掉最后一位1</span><br>n &amp; (n-<span class="hljs-number">1</span>);<br><span class="hljs-comment">//异或运算的特殊性质,异或运算满足交换律和结合律</span><br>a ^ a = <span class="hljs-number">0</span>;<br>a ^ <span class="hljs-number">0</span> = a;<br><span class="hljs-comment">//取反码+与运算</span><br>x &amp; ~x = <span class="hljs-number">0</span>;<br>x &amp; ~<span class="hljs-number">0</span> =x;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法归纳</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode题解</title>
    <link href="/post/LeetCode%E9%A2%98%E8%A7%A3.html"/>
    <url>/post/LeetCode%E9%A2%98%E8%A7%A3.html</url>
    
    <content type="html"><![CDATA[<p>记录一些值得多刷的题</p><h1 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h1><h3 id="山谷数组的搜索"><a href="#山谷数组的搜索" class="headerlink" title="山谷数组的搜索"></a>山谷数组的搜索</h3><p>在严格从小到大排序的数组中，索引0-i被翻转，导致最小元素位于数组中间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> findMin(nums);<br>        <span class="hljs-keyword">return</span> binarySearch(nums,<span class="hljs-number">0</span>,pivot-<span class="hljs-number">1</span>,target)==-<span class="hljs-number">1</span>?binarySearch(nums,pivot,nums.length-<span class="hljs-number">1</span>,target):binarySearch(nums,<span class="hljs-number">0</span>,pivot-<span class="hljs-number">1</span>,target);<br>    &#125;<br>    <span class="hljs-comment">//一般二分查找</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end,<span class="hljs-type">int</span> target)</span>&#123;<br>        <span class="hljs-type">int</span> left=start-<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> right=end+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left+<span class="hljs-number">1</span> != right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&lt;=target) left=mid;<br>            <span class="hljs-keyword">else</span> right=mid;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(left==start-<span class="hljs-number">1</span> || nums[left]!=target) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><span class="hljs-comment">//寻找到最低点</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">findMin</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(low&lt;high)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> low+(high-low)/<span class="hljs-number">2</span>;<br><span class="hljs-comment">//如果mid值比右侧的值大，证明最低点在右侧</span><br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[high]) low=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> high=mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> low;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="山峰数组的搜索"><a href="#山峰数组的搜索" class="headerlink" title="山峰数组的搜索"></a>山峰数组的搜索</h3><p>顾名思义，就是最大元素在数组中间的数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peakIndexInMountainArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> left=-<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> right=arr.length;<br>        <span class="hljs-keyword">while</span>(left+<span class="hljs-number">1</span> != right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-comment">//若递减，则山峰必在right左侧</span><br>            <span class="hljs-keyword">if</span>(arr[mid]&gt;arr[mid+<span class="hljs-number">1</span>]) right = mid;<br>            <span class="hljs-keyword">else</span> left=mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="并查集算法"><a href="#并查集算法" class="headerlink" title="并查集算法"></a>并查集算法</h1><p>并查集可以用来干啥：检测于避免环的生成，可用于辅助克鲁斯卡尔算法的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UF</span> &#123;<br>    <span class="hljs-comment">// 连通分量个数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<br>    <span class="hljs-comment">// 存储每个节点的父节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] parent;<br><br>    <span class="hljs-comment">// n 为图中节点的个数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UF</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.count = n;<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            parent[i] = i;<br>        &#125;<br>    &#125;  <br>    <span class="hljs-comment">// 将节点 p 和节点 q 连通</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootP</span> <span class="hljs-operator">=</span> find(p);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootQ</span> <span class="hljs-operator">=</span> find(q);<br>        <br>        <span class="hljs-keyword">if</span> (rootP == rootQ)<br>            <span class="hljs-keyword">return</span>;<br>        <br>        parent[rootQ] = rootP;<br>        <span class="hljs-comment">// 两个连通分量合并成一个连通分量</span><br>        count--;<br>    &#125;<br>    <span class="hljs-comment">// 判断节点 p 和节点 q 是否连通</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">connected</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootP</span> <span class="hljs-operator">=</span> find(p);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootQ</span> <span class="hljs-operator">=</span> find(q);<br>        <span class="hljs-keyword">return</span> rootP == rootQ;<br>    &#125;<br><span class="hljs-comment">//find函数进行路径压缩</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">if</span> (parent[x] != x) &#123;<br>            parent[x] = find(parent[x]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[x];<br>    &#125;<br>    <span class="hljs-comment">// 返回图中的连通分量个数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">count</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><p>永远保证队列是队头最大，队尾最小，加入新元素时会删除比自己小的元素来维护这一顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 单调队列的实现 */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MonotonicQueue</span> &#123;<br>    LinkedList&lt;Integer&gt; maxq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 将小于 n 的元素全部删除</span><br>        <span class="hljs-keyword">while</span> (!maxq.isEmpty() &amp;&amp; maxq.getLast() &lt; n) &#123;<br>            maxq.pollLast();<br>        &#125;<br>        <span class="hljs-comment">// 然后将 n 加入尾部</span><br>        maxq.addLast(n);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> maxq.getFirst();<br>    &#125;<br>    <span class="hljs-comment">//删除队头元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">//判断这个元素是否还存在，没有被之前加入的元素删除</span><br>        <span class="hljs-keyword">if</span> (n == maxq.getFirst()) &#123;<br>            maxq.pollFirst();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="nSum系列问题"><a href="#nSum系列问题" class="headerlink" title="nSum系列问题"></a><code>nSum</code>系列问题</h1><h2 id="2Sum"><a href="#2Sum" class="headerlink" title="2Sum"></a>2Sum</h2><p>给定一个数组和一个目标值，要求输出若干个二元组，这些二元组的和都等于target</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">twoSumTarget</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span>&#123;<br>    Arrays.sort(nums);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> high= nums.length-<span class="hljs-number">1</span>;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>    <span class="hljs-keyword">while</span>(low&lt;high)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[low] + nums[high];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> nums[low] ; <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums[high];<br>        <span class="hljs-comment">//跨过相同的元素</span><br>        <span class="hljs-keyword">if</span>(sum &lt; target) <span class="hljs-keyword">while</span>(low&lt;high &amp;&amp; nums[low]==left) low++;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &gt; target) <span class="hljs-keyword">while</span>(low&lt;high &amp;&amp; nums[high]==right) high--;<br>        <span class="hljs-keyword">else</span>&#123;<br>            List&lt;Integer&gt; ans = Arrays.asList(left,right);<br>            res.add(ans);<br>            <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; nums[low] == left) low++;<br>            <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; nums[high] == right]) high--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3Sum"><a href="#3Sum" class="headerlink" title="3Sum"></a>3Sum</h2><p>其实可以化简为2Sum问题，即对每一个数进行遍历，并解决这一个数的去重问题，其他两个数的去重问题交给另一个方法来解决，4Sum同理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//不断复用twoSum的方法来解决3Sum</span><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">3</span> || nums==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            List&lt;List&lt;Integer&gt;&gt; twoSums = twoSumTarget(nums,i+<span class="hljs-number">1</span>,target-nums[i]);<br>        <span class="hljs-keyword">for</span>(List&lt;Integer&gt; Sums : twoSums)&#123;<br>            List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Sums);<br>            <span class="hljs-comment">//为什么这里不直接对sums进行add操作而要重新new一个，继承关系：ArrayList-&gt;AbstractList-&gt;List-&gt;Collection。此时的ArrayList是静态内部类，直接调用AbstractList类里面的add方法，而直接调用就会抛出错误，并没有重写add(),remove()方法，所以new操作可以重写add(),remove，从而实现相关操作</span><br>            temp.add(nums[i]);<br>            res.add(temp);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(i&lt;n-<span class="hljs-number">1</span>&amp;&amp;nums[i]==nums[i+<span class="hljs-number">1</span>]) i++;<br>    &#125;<br>        <span class="hljs-keyword">return</span> res;<br>  &#125;<br>    List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">twoSumTarget</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> target)</span>&#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> start; <span class="hljs-type">int</span> high= nums.length-<span class="hljs-number">1</span>;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-keyword">while</span>(low&lt;high)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[low] + nums[high];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> nums[low] ; <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums[high];<br>        <span class="hljs-comment">//跨过相同的元素</span><br>            <span class="hljs-keyword">if</span>(sum &lt; target) <span class="hljs-keyword">while</span>(low&lt;high &amp;&amp; nums[low]==left) low++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &gt; target) <span class="hljs-keyword">while</span>(low&lt;high &amp;&amp; nums[high]==right) high--;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//此时的ans由asList生成，是个静态内部类</span><br>                List&lt;Integer&gt; ans = Arrays.asList(left,right);<br>                res.add(ans);<br>                <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; nums[low] == left) low++;<br>                <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; nums[high] == right) high--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="nSum"><a href="#nSum" class="headerlink" title="nSum"></a>nSum</h2><p>统一解法：递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;         <br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">fourSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">return</span> nSumTarget(nums,<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,target);<br>    &#125;<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">nSumTarget</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> start,<span class="hljs-type">int</span> target)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-keyword">if</span>(target==-<span class="hljs-number">294967296</span>||target==<span class="hljs-number">294967296</span>) <span class="hljs-keyword">return</span> res;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">2</span> || len&lt;n) <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">2</span>)&#123;<span class="hljs-comment">//等于2的情况</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> start; <span class="hljs-type">int</span> high= len-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(low&lt;high)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[low] + nums[high];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> nums[low];<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums[high];<br>       <span class="hljs-comment">//跨过相同的元素</span><br>            <span class="hljs-keyword">if</span>(sum &lt; target) <span class="hljs-keyword">while</span>(low&lt;high &amp;&amp; nums[low]==left) low++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &gt; target) <span class="hljs-keyword">while</span>(low&lt;high &amp;&amp; nums[high]==right) high--;<br>            <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//使用new ArrayList可以避免上面的问题</span><br>                res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(left, right)));<br>                <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; nums[low] == left) low++;<br>                <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; nums[high] == right) high--;<br>                    &#125;<br>        &#125;<br>        &#125;<br>    <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//大于2的情况</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start;i&lt;len;i++)&#123;<br>            List&lt;List&lt;Integer&gt;&gt; sub = nSumTarget(nums,n-<span class="hljs-number">1</span>,i+<span class="hljs-number">1</span>,target-nums[i]);<br>        <span class="hljs-keyword">for</span>(List&lt;Integer&gt; Sums : sub)&#123;<br>            Sums.add(nums[i]);<br>            res.add(Sums);&#125;<br>        <span class="hljs-keyword">while</span>(i&lt;len-<span class="hljs-number">1</span>&amp;&amp;nums[i]==nums[i+<span class="hljs-number">1</span>]) i++;<br>    &#125; <br>      &#125;<br>      <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="反转链表系列问题"><a href="#反转链表系列问题" class="headerlink" title="反转链表系列问题"></a>反转链表系列问题</h1><p>链表是一个兼具迭代与递归性质的数据结构</p><h2 id="整个链表反转"><a href="#整个链表反转" class="headerlink" title="整个链表反转"></a>整个链表反转</h2><p>反转整个链表其实就是反转由head到null之间的节点</p><p>迭代实现：由三个指针向前推进实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode a)</span> &#123;<br>    ListNode pre, cur, nxt;<br>    pre = <span class="hljs-literal">null</span>; cur = a; nxt = a;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>        nxt = cur.next;<br>        <span class="hljs-comment">// 逐个结点反转</span><br>        cur.next = pre;<br>        <span class="hljs-comment">// 更新指针位置</span><br>        pre = cur;<br>        cur = nxt;<br>    &#125;<br>    <span class="hljs-comment">// 返回反转后的头结点</span><br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="反转特定范围内的节点"><a href="#反转特定范围内的节点" class="headerlink" title="反转特定范围内的节点"></a>反转特定范围内的节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode a, ListNode b)</span> &#123;<br>    ListNode pre, cur, nxt;<br>    pre = <span class="hljs-literal">null</span>; cur = a; nxt = a;<br>    <span class="hljs-comment">// while 终止的条件改一下就行了</span><br>    <span class="hljs-keyword">while</span> (cur != b) &#123;<br>        nxt = cur.next;<br>        cur.next = pre;<br>        pre = cur;<br>        cur = nxt;<br>    &#125;<br>    <span class="hljs-comment">// 返回反转后的头结点</span><br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="以k个一组反转链表"><a href="#以k个一组反转链表" class="headerlink" title="以k个一组反转链表"></a>以k个一组反转链表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">ListNode <span class="hljs-title function_">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 区间 [a, b) 包含 k 个待反转元素</span><br>    ListNode a, b;<br>    a = b = head;<br>    <span class="hljs-comment">//让b指向第k个节点，若没有k个就直接返回</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        <span class="hljs-comment">// 不足 k 个，不需要反转，base case</span><br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;<br>        b = b.next;<br>    &#125;<br>    <span class="hljs-comment">// 反转前 k 个元素</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">newHead</span> <span class="hljs-operator">=</span> reverse(a, b);<br>    <span class="hljs-comment">// 递归反转后续链表并连接起来</span><br>    a.next = reverseKGroup(b, k);<br>    <span class="hljs-keyword">return</span> newHead;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="归并排序，二叉树的后序遍历"><a href="#归并排序，二叉树的后序遍历" class="headerlink" title="归并排序，二叉树的后序遍历"></a>归并排序，二叉树的后序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Merge</span> &#123;<br>    <span class="hljs-comment">// 用于辅助合并有序数组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] temp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 先给辅助数组开辟内存空间</span><br>        temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        <span class="hljs-comment">// 排序整个数组（原地修改）</span><br>        sort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 定义：将子数组 nums[lo..hi] 进行排序</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> lo, <span class="hljs-type">int</span> hi)</span> &#123;<br>        <span class="hljs-keyword">if</span> (lo == hi) &#123;<br>            <span class="hljs-comment">// 单个元素不用排序</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 这样写是为了防止溢出，效果等同于 (hi + lo) / 2</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> lo + (hi - lo) / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 先对左半部分数组 nums[lo..mid] 排序</span><br>        sort(nums, lo, mid);<br>        <span class="hljs-comment">// 再对右半部分数组 nums[mid+1..hi] 排序</span><br>        sort(nums, mid + <span class="hljs-number">1</span>, hi);<br>        <span class="hljs-comment">// 将两部分有序数组合并成一个有序数组</span><br>        merge(nums, lo, mid, hi);<br>    &#125;<br>    <span class="hljs-comment">// 将 nums[lo..mid] 和 nums[mid+1..hi] 这两个有序数组合并成一个有序数组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> lo, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> hi)</span> &#123;<br>        <span class="hljs-comment">// 先把 nums[lo..hi] 复制到辅助数组中</span><br>        <span class="hljs-comment">// 以便合并后的结果能够直接存入 nums</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> lo; i &lt;= hi; i++) &#123;<br>            temp[i] = nums[i];<br>        &#125;<br>        <span class="hljs-comment">// 数组双指针技巧，合并两个有序数组</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> lo, j = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> lo; p &lt;= hi; p++) &#123;<br>            <span class="hljs-keyword">if</span> (i == mid + <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">// 左半边数组已全部被合并</span><br>                nums[p] = temp[j++];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == hi + <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">// 右半边数组已全部被合并</span><br>                nums[p] = temp[i++];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp[i] &gt; temp[j]) &#123;<br>                nums[p] = temp[j++];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                nums[p] = temp[i++];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="归并排序应用：链表排序"><a href="#归并排序应用：链表排序" class="headerlink" title="归并排序应用：链表排序"></a>归并排序应用：链表排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> divide(head);<br>    &#125;<br>    ListNode <span class="hljs-title function_">divide</span><span class="hljs-params">(ListNode head)</span>&#123;<br>        <span class="hljs-keyword">if</span>(head.next==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;<br>        ListNode slow=head,fast=head,pre=<span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//找到中点</span><br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">null</span>&amp;&amp;fast.next!=<span class="hljs-literal">null</span>)&#123;<br>            pre=slow;<br>            slow=slow.next;<br>            fast=fast.next.next;<br>        &#125;<br>        <span class="hljs-comment">//解链操作</span><br>        pre.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//后序遍历</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">segA</span> <span class="hljs-operator">=</span> divide(head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">segB</span> <span class="hljs-operator">=</span> divide(slow);<br>        <span class="hljs-keyword">return</span> merge(segA,segB);<br><br>    &#125;<br>    <span class="hljs-comment">//合并两个链表</span><br>    ListNode <span class="hljs-title function_">merge</span><span class="hljs-params">(ListNode segA, ListNode segB)</span>&#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span>(segA!=<span class="hljs-literal">null</span> &amp;&amp; segB!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(segA.val&gt;=segB.val)&#123;<br>                cur.next = segB;<br>                cur= cur.next;<br>                segB=segB.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(segB.val&gt;segA.val)&#123;<br>                cur.next = segA;<br>                cur=cur.next;<br>                segA=segA.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(segA != <span class="hljs-literal">null</span>) cur.next = segA;<br>        <span class="hljs-keyword">if</span>(segB != <span class="hljs-literal">null</span>) cur.next = segB;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="快速排序，二叉树的前序遍历"><a href="#快速排序，二叉树的前序遍历" class="headerlink" title="快速排序，二叉树的前序遍历"></a>快速排序，二叉树的前序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Quick</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 为了避免出现耗时的极端情况，先随机打乱</span><br>        shuffle(nums);<br>        <span class="hljs-comment">// 排序整个数组（原地修改）</span><br>        sort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> lo, <span class="hljs-type">int</span> hi)</span> &#123;<br>        <span class="hljs-keyword">if</span> (lo &gt;= hi) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 对 nums[lo..hi] 进行切分</span><br>        <span class="hljs-comment">// 使得 nums[lo..p-1] &lt;= nums[p] &lt; nums[p+1..hi]</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> partition(nums, lo, hi);<br><span class="hljs-comment">//递归</span><br>        sort(nums, lo, p - <span class="hljs-number">1</span>);<br>        sort(nums, p + <span class="hljs-number">1</span>, hi);<br>    &#125;<br><br>    <span class="hljs-comment">// 对 nums[lo..hi] 进行切分</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> lo, <span class="hljs-type">int</span> hi)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> nums[lo];<br>        <span class="hljs-comment">// 关于区间的边界控制需格外小心，稍有不慎就会出错</span><br>        <span class="hljs-comment">// 我这里把 i, j 定义为开区间，同时定义：</span><br>        <span class="hljs-comment">// [lo, i) &lt;= pivot；(j, hi] &gt; pivot</span><br>        <span class="hljs-comment">// 之后都要正确维护这个边界区间的定义</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> lo + <span class="hljs-number">1</span>, j = hi;<br>        <span class="hljs-comment">// 当 i &gt; j 时结束循环，以保证区间 [lo, hi] 都被覆盖</span><br>        <span class="hljs-keyword">while</span> (i &lt;= j) &#123;<br>            <span class="hljs-keyword">while</span> (i &lt; hi &amp;&amp; nums[i] &lt;= pivot) &#123;<br>                i++;<br>                <span class="hljs-comment">// 此 while 结束时恰好 nums[i] &gt; pivot</span><br>            &#125;<br>            <span class="hljs-keyword">while</span> (j &gt; lo &amp;&amp; nums[j] &gt; pivot) &#123;<br>                j--;<br>                <span class="hljs-comment">// 此 while 结束时恰好 nums[j] &lt;= pivot</span><br>            &#125;<br>            <span class="hljs-comment">// 此时 [lo, i) &lt;= pivot &amp;&amp; (j, hi] &gt; pivot</span><br><br>            <span class="hljs-keyword">if</span> (i &gt;= j) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            swap(nums, i, j);<br>        &#125;<br>        <span class="hljs-comment">// 将 pivot 放到合适的位置，即 pivot 左边元素较小，右边元素较大</span><br>        swap(nums, lo, j);<br>        <span class="hljs-keyword">return</span> j;<br>    &#125;<br>    <span class="hljs-comment">// 洗牌算法，将输入的数组随机打乱</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shuffle</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">Random</span> <span class="hljs-variable">rand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 生成 [i, n - 1] 的随机数</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> i + rand.nextInt(n - i);<br>            swap(nums, i, r);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 原地交换数组中的两个元素</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>        nums[i] = nums[j];<br>        nums[j] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="BFS框架"><a href="#BFS框架" class="headerlink" title="BFS框架"></a>BFS框架</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//建立核心数据结构queue</span><br><span class="hljs-comment">//建立记录结果的链表</span><br><span class="hljs-comment">//初始化数据，将起点加入queue</span><br><span class="hljs-comment">//进入while循环</span><br><span class="hljs-comment">//进入for循环，循环次数为当前level的节点数</span><br><span class="hljs-comment">//判断是否到达终点</span><br><span class="hljs-comment">//元素出队列，判断该元素的相邻节点是否被访问过，并将相邻元素加入队列</span><br><span class="hljs-comment">//结束for循环</span><br><span class="hljs-comment">//记录结果</span><br><span class="hljs-comment">//结束while循环</span><br><span class="hljs-comment">//返回结果</span><br><br><br><span class="hljs-comment">// 计算从起点 start 到终点 target 的最近距离</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">BFS</span><span class="hljs-params">(Node start, Node target)</span> &#123;<br>    Queue&lt;Node&gt; q; <span class="hljs-comment">// 核心数据结构</span><br>    Set&lt;Node&gt; visited; <span class="hljs-comment">// 避免走回头路</span><br>    <br>    q.add(start); <span class="hljs-comment">// 将起点加入队列</span><br>    visited.add(start);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">step</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录扩散的步数</span><br><br>    <span class="hljs-keyword">while</span> (q not empty) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> q.size();<br>        <span class="hljs-comment">/* 将当前队列中的所有节点向四周扩散 */</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sz; i++) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> q.poll();<br>            <span class="hljs-comment">/* 划重点：这里判断是否到达终点 */</span><br>            <span class="hljs-keyword">if</span> (cur is target)<br>                <span class="hljs-keyword">return</span> step;<br>            <span class="hljs-comment">/* 将一个节点的未遍历节点加入队列 */</span><br>            <span class="hljs-keyword">for</span> (Node x : cur.adj()) &#123;<br>                <span class="hljs-keyword">if</span> (x not in visited) &#123;<br>                    q.add(x);<br>                    visited.add(x);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/* 划重点：更新步数在这里 */</span><br>        step++;<br>    &#125;<br></code></pre></td></tr></table></figure><p>BFS应用：二叉树的锯齿形遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">zigzagLevelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root ==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br>        Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">//建立核心数据结构</span><br>        q.add(root);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> q.size();<br>            <span class="hljs-comment">//记录当前层的节点</span><br>            LinkedList&lt;Integer&gt; level = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            <span class="hljs-comment">//遍历该层</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> q.poll();<br>                <span class="hljs-comment">//使用flag来调整遍历方向</span><br>                <span class="hljs-keyword">if</span>(flag) level.addLast(node.val);<br>                <span class="hljs-keyword">else</span> level.addFirst(node.val);<br>                <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-literal">null</span>) q.add(node.left);<br>                <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-literal">null</span>) q.add(node.right);<br>            &#125;<br>            flag = !flag;<br>            res.add(level);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode初见</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>划分k个相等子集</title>
    <link href="/post/%E5%88%92%E5%88%86k%E4%B8%AA%E7%9B%B8%E7%AD%89%E5%AD%90%E9%9B%86.html"/>
    <url>/post/%E5%88%92%E5%88%86k%E4%B8%AA%E7%9B%B8%E7%AD%89%E5%AD%90%E9%9B%86.html</url>
    
    <content type="html"><![CDATA[<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入： nums = <span class="hljs-string">[4, 3, 2, 3, 5, 2, 1]</span>, k = <span class="hljs-number">4</span><br>输出： True<br>说明： 有可能将其分成 <span class="hljs-number">4</span> 个子集（<span class="hljs-number">5</span>），（<span class="hljs-number">1</span>,<span class="hljs-number">4</span>），（<span class="hljs-number">2</span>,<span class="hljs-number">3</span>），（<span class="hljs-number">2</span>,<span class="hljs-number">3</span>）等于总和<br></code></pre></td></tr></table></figure><p>桶问题：若可以划分为k个子集，则想象有k个桶，容量均为sum&#x2F;k，如果我们刚好将桶装满，则返回true，否则返回false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartitionKSubsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span>(!isValid(nums,k)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//对数组排序，从后向前搜索</span><br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">if</span>(nums[nums.length-<span class="hljs-number">1</span>]&gt;sum/k) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        sum/=k;<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-comment">//建立桶的数据结构</span><br>        Arrays.fill(arr,sum);<br>        <span class="hljs-keyword">return</span>(backTrack(nums,k,arr,nums.length-<span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> val : nums) sum+=val;<br>        <span class="hljs-keyword">if</span>(sum%k!=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k,<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> cur)</span>&#123;<br>        <span class="hljs-keyword">if</span>(cur&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">// cur走到-1时，说明所有的数全部都放进桶里了。这时一定是true</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>            <span class="hljs-comment">//i遍历每一个桶，判断cur指向的数可以放入哪一个桶</span><br>            <span class="hljs-keyword">if</span>(arr[i]==nums[cur]||arr[i]-nums[cur]&gt;=nums[<span class="hljs-number">0</span>])&#123;<br>                arr[i]-=nums[cur];<br>                <span class="hljs-keyword">if</span>(backTrack(nums,k,arr,cur-<span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                arr[i]+=nums[cur];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode初见</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/post/Redis%E9%9A%8F%E6%83%B3.html"/>
    <url>/post/Redis%E9%9A%8F%E6%83%B3.html</url>
    
    <content type="html"><![CDATA[<h1 id="Redis的数据结构"><a href="#Redis的数据结构" class="headerlink" title="Redis的数据结构"></a>Redis的数据结构</h1><table><thead><tr><th><strong>数据类型</strong></th><th><strong>简单描述</strong></th><th><strong>使用场景</strong></th></tr></thead><tbody><tr><td>String</td><td>string(字符串)是Redis最简单也是使用最广泛的数据结构，它的内部是一个字符数组。String(字符串)是动态字符串，允许修改；它在结构上的实现类似于Java中的ArrayList（默认构造一个大小为10的初始数组），这是冗余分配内存的思想，也称为预分配；这种思想可以减少扩容带来的性能消耗。当string(字符串)的大小达到扩容阈值时，将会对string(字符串)进行扩容，string(字符串)的扩容主要有三种情况：1.长度小于1MB，扩容后为原先的两倍; length &#x3D; length * 2 2.长度大于1MB，扩容后增加1MB; length &#x3D; length + 1MB 3. 字符串的长度最大值为 512MB</td><td>缓存、计数器、分布式锁等。</td></tr><tr><td>List</td><td>Redis的列表相当于Java语言中的LinkedList，它是一个双向链表数据结构，支持前后顺序遍历。链表结构插入和删除操作快，时间复杂度O(1)，查询慢，时间复杂度O(n)。Redis的list(列表)不是一个简单的LinkedList，而是quicklist ——“快速列表”，quicklist是多个ziplist(压缩列表)组成的双向列表；</td><td>链表、异步队列、微博关注人时间轴列表……</td></tr><tr><td>Hash</td><td>Redis的hash(字典)相当于Java语言中的HashMap，hash(字典)的实现与Java中的HashMap（JDK1.7）的结构也是一致的，它的数据结构也是数组+链表组成的二维结构，Redis中的hash(字典)存储的value只能是字符串值，此外扩容与Java中的HashMap也不同。Java中的HashMap在扩容的时候是一次性完成的，而Redis考虑到其核心存取是单线程的性能问题，为了追求高性能，因而采取了渐进式rehash策略。渐进式rehash指的是并非一次性完成，它是多次完成的，因此需要保留旧的hash结构，所以Redis中的hash(字典)会存在新旧两个hash结构，在rehash结束后也就是旧hash的值全部搬迁到新hash之后，新的hash在功能上才会完全替代以前的hash。</td><td>用户信息、Hash 表……</td></tr><tr><td>Set</td><td>Redis的set(集合)相当于Java语言里的HashSet，它内部的键值对是无序的、唯一的。它的内部实现了一个所有value为null的特殊字典。</td><td>去重功能、赞、踩、共同好友……</td></tr><tr><td>Bitmaps</td><td>Bitmaps 称为位图，严格来说它不是一种数据类型。Bitmaps底层就是字符串（key-value）byte数组。我们可以使用普通的get&#x2F;set直接获取和设值位图的内容，也可以通过Redis提供的位图操作getbit&#x2F;setbit等将byte数组看成“位数组”来处理。Bitmaps 的“位数组”每个单元格只能存储0和1，数组的下标在Bitmaps中称为偏移量。Bitmaps设置时key不存在会自动生成一个新的字符串，如果设置的偏移量超出了现有内容的范围，就会自动将位数组进行零扩充</td><td>员工打卡……</td></tr><tr><td>Geospatial</td><td>Geospatial是Redis在3.2版本以后增加的地理位置GEO模块</td><td>微信附近的人，在线点餐“附近的餐馆”……</td></tr><tr><td>HyperLogLog</td><td>HyperLogLog是用来做基数统计的算法，它提供不精确的去重计数方案（这个不精确并不是非常不精确），标准误差是0.81%，对于UV这种统计来说这样的误差范围是被允许的。HyperLogLog的优点在于，输入元素的数量或者体积非常大时，基数计算的存储空间是固定的。在Redis中，每个HyperLogLog键只需要花费12KB内存，就可以计算接近2^64个不同的基数。但是HyperLogLog只能统计基数的大小（也就是数据集的大小，集合的个数），他不能存储元素的本身，不能向set集合那样存储元素本身，也就是说无法返回元素。</td><td>基数统计比如UV等</td></tr></tbody></table><p><img src="/../img/redis.png" alt="redis"></p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>int：存储数字</p><p>raw：长度大于39字节，基于SDS</p><p>embstr：长度小于39字节，基于SDS</p><h2 id="SDS结构模型"><a href="#SDS结构模型" class="headerlink" title="SDS结构模型"></a>SDS结构模型</h2><p>基于C语言，由Redis封装的一种简单高效安全的数据结构</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>SDS的底层实现思路其实十分简单</p><ol><li>无符号变量len：记录字符串的长度</li><li>无符号变量free：记录空闲内存的大小</li><li>char型数组buf：存储字符</li></ol><p>其中：buf尾部会自动追加一个空字符，遵循了c语言原生字符串的规范，并且SDS的指针也不是指向起始位置，而是指向buf，使得SDS可以直接使用一部分库函数。</p><p>SDS取消了字节对齐，使得指针移动一位便可以读取到header里的信息。如果没有取消，这个移动的位数是未知的，就无法兼容C语言的库函数了，指针操作也要麻烦很多。</p><h3 id="数据结构优化："><a href="#数据结构优化：" class="headerlink" title="数据结构优化："></a>数据结构优化：</h3><p>如果一个字符串非常短，但是记录信息的头部却占用了更多的空间，这未免有一些浪费，所以SDS会分为五种类型</p><ol><li>短字符串：小于32，用一个char类型的flag变量来记录长度，低三位存储类型，高三位存储长度</li><li>短字符串：用一字节的char来记录长度，一字节的flag来记录类型</li><li>长字符串：用2字节的short来记录长度，1字节的flag来记录类型</li><li>长字符串：用4字节的int来记录长度</li><li>超长字符串：用8字节的long来记录字符串</li></ol><p>SDS的最大长度：在3.X版本中，因为数据结构中的len属性是由int来修饰的，所以buf的最大长度就是214783647，即512MB</p><p>但是在6.x版本后，长度就更多样了</p><h3 id="SDS相比原生string的优势："><a href="#SDS相比原生string的优势：" class="headerlink" title="SDS相比原生string的优势："></a>SDS相比原生string的优势：</h3><ol><li>O(1)时间复杂度获取字符串的长度：因为C语言原生基本数据类型不记录自身长度，当要计算一个字符串的长度必须遍历整个字符串，直到遇到空字符为止，时间复杂度O(n)，而使用SDS则直接获取len属性即可，时间复杂度为O(1)</li><li>二进制安全：在C语言中，用空字符表示字符串的结束，若字符串本身就包含空字符，那么遇到便会截断，即非二进制安全。与其相对的便是二进制安全，SDS使用len属性来判断字符串是否结束，不会受到空字符影响。</li><li>杜绝缓冲区溢出：在C语言中，在对字符串进行拼接操作时，若没有给字符串分配足够的内存，那么就可能产生缓冲区溢出，把其他数据覆盖掉。而SDS的自动扩容机制杜绝了溢出，<code>sdsMakeRoomFor</code>方法：参数：原字符串，待加入的字符串。若空闲空间大于待拼接字符串的长度，则无需扩容；若拼接后的长度小于1M，则直接扩容至新长度的两倍；若拼接后的长度大于1M，则扩容至新长度+1M；扩容后检查类型，若发生变化，则需要为SDS重新分配内存（header的大小也改变了）</li><li>优化的内存分配策略：预分配：扩容后的SDS不会恰好容下新字符串，而是多分配了一些空间，从而减少修改字符串时带来的内存重分配次数；惰性空间释放机制：当缩短字符串时，不会立刻回收空余的空间，而是仅仅更新len属性，空余空间供将来使用，减少内存分配频率，当然Redis也提供了释放未使用空间的方法<code>sdsRemoveFreeSpace</code></li></ol><h1 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a>List列表</h1><p>Redis 的列表相当于 Java 语言里面的 LinkedList，这意味着List的插入和删除操作非常块，但是索引定位就比较慢了</p><p>List支持先进先出（lpop）先进后出（rpop）</p><p>List有两种实现方式：压缩列表和双向循环链表</p><h4 id="ziplist：节点的数据小于64字节，数据个数小于512个"><a href="#ziplist：节点的数据小于64字节，数据个数小于512个" class="headerlink" title="ziplist：节点的数据小于64字节，数据个数小于512个"></a>ziplist：<strong>节点的数据小于64字节，数据个数小于512个</strong></h4><p>一般的数组都要求每一格的元素大小相同，但是若要存储不同大小的字符串，就需要以最大长度来作为元素大小，会造成一定程度的浪费。而压缩列表就是将元素紧凑，但是会在每个元素的头部追加一个len属性，这样就能很容易计算出下一个元素的内存地址。</p><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>和<code>linkedlist</code>很相似，可以处理数据量较大的情况，每个节点包含value和前驱，后继节点的指针</p><h4 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h4><p>在redis3.2版本之前，使用ziplist和linkedlist作为列表的底层实现，就使用quicklist</p><p>quicklist其实现也是依赖于ziplist和linkedlist来实现的，它是两个结构的结合。</p><p>它将ziplist来进行分段存储，也就是分成一个个的quicklistNode节点来进行存储。<strong>每个quicklistNode指向一个ziplist</strong>，然后quicklistNode之间是通过双向指针来进行连接的。</p><p><img src="/../img/redis1.png" alt="redis1"></p><p>传统链表的缺点：</p><ol><li>每个节点都有自己的前后指针，指针会占用内存，当节点内数据较少时，附加空间成本就太高了</li><li>每个节点单独的进行内存分配，当节点过多，造成的内存碎片太多了。影响内存管理的效率。</li></ol><p>因此，定义了 quicklist, 将 linkedlist 和 ziplist 结合起来，形成一个，将多个 ziplist 通过前后指针互相连接起来的结构，可以在一定程度上缓解上面说到的两个问题。为了进一步节约内存，Reids 还可以对 ziplist 进行压缩存储，应用 LZF 算法压缩，即quicklistLZF结构</p><h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p><strong>节点的数据小于64字节，数据个数小于512个</strong>时由<code>ziplist</code>实现</p><p>其他情况由哈希表实现，和JDK1.7里的hashmap类似，都是<strong>无序键值对集合</strong>，底层是数组+链表</p><p>hash也有两种实现方式，当数据量小的时候，使用压缩列表，当数据量大的时候，使用散列表。</p><p>但是hash只能存储字符串，并且redis为了保证高性能，采用渐进式的rehash方法，即在不断输入的任务以及hash操作中一步步将旧结构里的内容迁移到新结构中</p><h1 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h1><p><strong>无序集合</strong>，存储一组不重复的数据，类似于HashSet，元素无序且唯一</p><p>同样两种实现方法：有序数组inset（只用于处理整数）和散列表。前者是处理较少的数据，后者是处理大量数据。</p><h1 id="ZSET"><a href="#ZSET" class="headerlink" title="ZSET"></a>ZSET</h1><p><strong>有序键值对集合</strong></p><p><strong>节点的数据小于64字节，数据个数小于128个</strong>时由<code>ziplist</code>实现</p><p>其他情况由跳表来实现</p><p>ZSET是一个有序集合，它一方面通过set来保证内部value值的唯一性，另一方面通过value的score（权重）来进行排序。</p><p>这个排序的功能是通过Skip List来实现的</p><p>应用场景：</p><ol><li>存储粉丝列表，value是粉丝的ID，score是关注时间戳，这样可以对粉丝关注进行排序</li><li>存储学生成绩，value使学生的ID，score是学生的成绩，这样可以对学生的成绩排名</li></ol><h2 id="跳表skipList"><a href="#跳表skipList" class="headerlink" title="跳表skipList"></a>跳表skipList</h2><p>跳表是可以实现二分查找的有序链表，常用于redis的有序集合数据结构</p><p>拥有与红黑树相近的查找，删除，插入效率，并且范围查找效率更优越</p><p>原理在于为有序链表建立多级索引，从而实现跳跃查找，</p><p>最底层包含所有元素，第一级索引包含1&#x2F;2的元素，以此类推。</p><p><strong>每个索引包含了一个指针数组</strong>，指向了该索引可以到达的所有节点，数组下标即当前指针所在的层数。</p><p><img src="/../img/3def9bbb70168ee0d6645fc450f2e030.gif" alt="3def9bbb70168ee0d6645fc450f2e030"></p><p><strong>以生成随机数的方式，来为每一个插入的元素设定索引级数</strong>，从而无需重建整个索引，降低了时间复杂度</p><p>索引晋升计算模式：random()是个随机数，产生越高的节点层数，<strong>概率越低</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">randomLevel</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// random()返回一个[0...1)的随机数</span><br>    <span class="hljs-keyword">while</span> (random() &lt; p &amp;&amp; level &lt; MaxLevel)&#123; <br>        level += <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> level;<br>&#125;<br><span class="hljs-comment">//在redis中p为0.25，MaxLevel为64</span><br></code></pre></td></tr></table></figure><p>跳表自身拥有的优势：</p><ol><li>数据天然有序</li><li>插入查询过程类似于二分查找，所以时间复杂度为O(logn)</li><li>与红黑树相比：实现简单，无需变色左旋右旋等操作</li></ol><h1 id="Redis的持久化"><a href="#Redis的持久化" class="headerlink" title="Redis的持久化"></a>Redis的持久化</h1><p>因为redis的数据是在内存里，一旦断电或者宕机，数据便会丢失，所以必须保证数据不会因为故障而丢失</p><h3 id="RDB-redis-database"><a href="#RDB-redis-database" class="headerlink" title="RDB(redis database)"></a>RDB(redis database)</h3><p><strong>快照</strong>，在指定的时间间隔内将内存中的所有数据集快照写入磁盘</p><p>Redis会单独创建fork一个子进程来进行持久化，依靠操作系统的COW机制（写入时复制，在client没有对数据进行写入时，子进程和主进程通过指针共享一个物理页面，当client对数据进行写入修改时，OS才会为页面创建副本，子进程将副本数据写入RDB，而这个过程仍然不影响主进程对数据的修改），fork进程内部的数据便是整个数据库的一个快照。当子进程完成对新RDB文件的写入时，便会拿其替换原来的RDB文件。</p><p><code>fork 的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。 子进程读取数据，然后序列化写到磁盘中。</code></p><p>RDB是对整个内存的数据进行快照，所以只有一个文件，这种方法适合大规模的数据恢复，而且很方便，因为OS只需要fork一个子进程，服务进程无需进行其他的IO操作，最大化保障redis的性能。</p><p>但是RDB也有一些缺点：最后一次快照无法及时写入内存，可能会发生丢失，因为是由fork子进程来完成持久化，相当于克隆了一份内存数据，当数据集较大时，可能会影响整个服务器的性能。</p><h3 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF(Append Only File)"></a>AOF(Append Only File)</h3><p>以日志的形式来记录写操作，<strong>只记录写指令</strong>，恢复时只需从前往后执行一遍即可完成数据恢复的工作。</p><p>记录方式：写后日志：即在数据写入内存后再记录日志，让操作系统先执行命令，只有命令执行成功才能被记录，这种方式排除了错误的指令，并且不会阻塞当前的写操作。</p><p>风险：若写入数据后未来得及记录日志便宕机，就会造成数据丢失。虽然避免了当前命令的阻塞，但是会给下一个操作带来阻塞 的风险，因为AOF日志是在主线程中进行的，写入磁盘时，磁盘的写压力大，可能会造成后序操作的阻塞。</p><p>同步写回：每个操作完成后写回，会影响性能，但是可靠性高</p><p>每秒写回：即每秒进行一次写回，性能适中，但是可能会丢失这一秒内的数据</p><p>操作系统控制的写回：每个写完命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时写回磁盘。性能好，但是宕机时丢失的数据多</p><h1 id="Redis的事务"><a href="#Redis的事务" class="headerlink" title="Redis的事务"></a>Redis的事务</h1><p>redis是不支持回滚的：由程序员自行纠正编程错误，无回滚的方式保证了内部的简单快速</p><p>以MULTI开始一个事务，将多个命令入队，入队后不会立即执行，而是放置在等待执行的队列里，由EXEC触发事务</p><p>所有命令都会被序列化，顺序执行，执行过程中不会被其他客户端的命令打断</p><p>在提交之前所有命令都不会被执行</p><p>不保证原子性：有一条命令失败，其他的命令仍然会进行，没有回滚</p><h3 id="redis和memcached的区别"><a href="#redis和memcached的区别" class="headerlink" title="redis和memcached的区别"></a><em><strong>redis和memcached的区别</strong></em></h3><p>memcached全部存储于内存中，断电后会挂掉；redis具有持久化机制</p><p>Redis具有复杂的数据类型</p><p>Redis自己构建了VM机制，一般的系统调用系统函数，会浪费时间去移动和请求</p><p>redis的value值最大可以达到1gb，memcached只有1mb</p><h1 id="Redis分布式锁——Redission"><a href="#Redis分布式锁——Redission" class="headerlink" title="Redis分布式锁——Redission"></a>Redis分布式锁——Redission</h1><p><img src="/../img/redlock.png" alt="redlock"></p><p>分布式锁是控制分布式系统或不同系统之间共同访问共享资源的一种锁实现，如果不同的系统或同一个系统的不同主机之间共享了某个资源时，往往需要互斥来防止彼此干扰来保证一致性。</p><p>使用场景：多个服务间保证同一时刻同一时间段内同一用户只能有一个请求（防止关键业务出现并发攻击）</p><p>实现分布式锁的主要步骤：</p><ol><li>指定一个 key 作为锁标记，存入 Redis 中，指定一个 <strong>唯一的标识</strong> 作为 value。</li><li>当 key 不存在时才能设置值，确保同一时间只有一个客户端进程获得锁，满足 <strong>互斥性</strong> 特性。</li><li>设置一个过期时间，防止因系统异常导致没能删除这个 key，满足 <strong>防死锁</strong> 特性。</li><li>当处理完业务之后需要清除这个 key 来释放锁，清除 key 时需要校验 value 值，需要满足 <strong>解铃还须系铃人</strong> 。</li></ol><p>Redisson 提供了看门狗，每获得一个锁时，只设置一个很短的过期时间，同时起一个线程在每次快要到超时时间时去刷新锁的过期时间。在释放锁的同时结束这个线程。</p><h2 id="RedLock算法"><a href="#RedLock算法" class="headerlink" title="RedLock算法"></a>RedLock算法</h2><p>Redisson分布式锁，在某些极端情况下仍然是有缺陷的</p><ol><li><p>客户端长时间内阻塞导致锁失效</p><p>客户端 1 得到了锁，因为网络问题或者 GC 等原因导致长时间阻塞，然后业务程序还没执行完锁就过期了，这时候客户端 2 也能正常拿到锁，可能会导致线程安全问题。</p></li><li><p>Redis 服务器时钟漂移</p><p>如果 Redis 服务器的机器时间发生了向前跳跃，就会导致这个 key 过早超时失效，比如说客户端 1 拿到锁后，key 还没有到过期时间，但是 Redis 服务器的时间比客户端快了 2 分钟，导致 key 提前就失效了，这时候，如果客户端 1 还没有释放锁的话，就可能导致多个客户端同时持有同一把锁的情况，同样会造成线程安全的问题。</p></li><li><p>单点实例安全问题</p><p>如果 Redis 是单机模式挂了的话，那所有的客户端都获取不到锁了，假设你是主从模式，但 Redis 的主从同步是异步进行的，如果 Redis 主宕机了，这个时候从机并没有同步到这一把锁，那么机器 B 再次申请的时候就会再次申请到这把锁。</p></li></ol><p>引入红锁算法：</p><ol><li><p>客户端在多个 Redis 实例上申请加锁，必须保证<strong>大多数节点加锁成功</strong>，默认为N&#x2F;2+1个</p><p>解决容错性问题，部分实例异常，剩下的还能加锁成功</p></li><li><p>大多数节点<strong>加锁的总耗时</strong>，要小于锁设置的过期时间。</p><p>多实例操作，可能存在网络延迟、丢包、超时等问题，所以就算是大多数节点加锁成功，如果加锁的累积耗时超过了锁的过期时间，那有些节点上的锁可能也已经失效了，还是没有意义的。客户端会记录每次加锁消耗的时间并求和，加锁总耗时小于锁失效时间，锁才算获取成功。</p></li><li><p>释放锁，要向<strong>全部节点</strong>发起释放锁请求</p><p>如果部分节点加锁成功，但最后由于异常导致大部分节点没加锁成功，就要释放掉所有redis实例，各节点要保持一致</p></li></ol><h1 id="Redis主从"><a href="#Redis主从" class="headerlink" title="Redis主从"></a>Redis主从</h1><p><strong>主从复制</strong>，或者叫主从同步，是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。</p><p>前者称为 **主节点(master)**，后者称为 **从节点(slave)**。且数据的复制是 <strong>单向</strong> 的，只能由主节点到从节点。</p><p>Redis 主从复制支持 <strong>主从同步</strong> 和 <strong>从从同步</strong> 两种，后者是 Redis 后续版本新增的功能，以减轻主节点的同步负担。</p><p><img src="/../img/ae6edf4e4d97e73020f36be0d7aee2df.png" alt="ae6edf4e4d97e73020f36be0d7aee2df"></p><p>主从复制的目的：</p><ul><li><strong>数据冗余：</strong> 主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li><strong>故障恢复：</strong> 当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复 *(实际上是一种服务的冗余)*。</li><li><strong>负载均衡：</strong> 在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务 <em>（即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点）</em>，分担服务器负载。尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。</li><li><strong>高可用基石：</strong> 除了上述作用以外，主从复制还是哨兵和集群能够实施的 <strong>基础</strong>，因此说主从复制<strong>是 Redis 高可用的基础</strong>。</li></ul><h2 id="redis2-7及以前版本"><a href="#redis2-7及以前版本" class="headerlink" title="redis2.7及以前版本"></a>redis2.7及以前版本</h2><p><strong>主从复制依赖于sync</strong></p><p><img src="/../img/redisSYN.png" alt="redisSYN"></p><p>当主服务器接收到sync命令后，会执行bgsave命令</p><p>主服务器主进程fork的子进程会生成一个RDB文件，同时将RDB快照产生后的所有写操作记录在缓冲区中</p><p>bgsave命令执行完成后，主服务器将生成的RDB文件发送给从服务器</p><p>从服务器接收到RDB文件后，首先会清除本身的全部数据，然后载入RDB文件，将自己的数据状态更新成主服务器的RDB文件的数据状态</p><p>主服务器将缓冲区的写命令发送给从服务器，从服务器接收命令，并执行，完成主从复制</p><p><strong>主从同步依赖于命令传播</strong></p><p>当主服务器接收命令导致数据发生变化时，为了维护主从状态一致，主服务器会将导致自己数据状态发生改变的命令传播到从服务器执行，当从服务器也执行了相同的命令之后，主从服务器之间的数据状态将会保持一致。</p><p>sync命令的缺点：</p><ol><li>生成RDB快照文件会占用大量的CPU，磁盘IO资源，令主服务器响应能力下降</li><li>主服务器将生成的RDB文件发送给从服务器，会占用大量网络IO资源</li><li>从服务器接收RDB文件并载入，会导致从服务器阻塞，无法提供服务</li><li>当从服务器掉线再重连后，会产生不一致的问题，而sync无法处理这一情况，只能使用全量同步</li></ol><h2 id="redis2-8-—-redis4-0"><a href="#redis2-8-—-redis4-0" class="headerlink" title="redis2.8 — redis4.0"></a>redis2.8 — redis4.0</h2><p>尽量<strong>减少全量同步的发生，尽可能使用增量同步</strong>，在2.8版本之后使用<strong>psync</strong>命令代替了sync命令来执行同步操作，psync命令同时具备全量同步和增量同步的功能。</p><p>增量同步的实现原理：</p><ol><li><strong>复制偏移量</strong></li><li><strong>复制积压缓冲区</strong></li><li><strong>服务器运行 ID</strong></li></ol><h3 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h3><p>这是主从服务器都会维护的参数</p><p>主服务器向从服务发送数据，传播N个字节的数据，主服务的复制偏移量增加N</p><p>从服务器接收主服务器发送的数据，接收N个字节的数据，从服务器的复制偏移量增加N</p><p><img src="/../img/redisSYN1.png" alt="redisSYN1"></p><p><strong>假设此时A&#x2F;B正常传播，C从服务器断线</strong></p><p><img src="/../img/redisSYN2.png" alt="redisSYN2"></p><p>有了复制偏移量之后，从服务器C断线重连后，主服务器只需要发送从服务器缺少的100字节数据即可</p><h3 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h3><p><img src="/../img/redisSYN3.png" alt="redisSYN3"></p><p>复制积压缓冲区是一个固定长度的队列，默认为1MB大小。</p><p>当主服务器数据状态发生改变，主服务器将数据同步给从服务器的同时会另存一份到复制积压缓冲区中</p><p>复制积压缓冲区为了能和偏移量进行匹配，它<strong>不仅存储了数据内容，还记录了每个字节对应的偏移量：</strong></p><p><img src="/../img/RedisSYN4.png" alt="RedisSYN4"></p><p>所以主服务器可以通过这个缓冲区来知道从服务器缺失了哪些数据</p><p>当从服务器断线重连后，从服务器通过psync命令将自己的复制偏移量（offset）发送给主服务器，主服务器便可通过这个偏移量来判断进行增量传播还是全量同步。</p><ul><li>如果偏移量offset+1的数据仍然在复制积压缓冲区中，那么进行增量同步操作</li><li>反之进行全量同步操作，与sync一致</li></ul><p>可以由用户自定义缓冲区大小：尽可能的使用增量同步，但是缓冲区又不会占用过大的内存</p><h3 id="服务器运行ID"><a href="#服务器运行ID" class="headerlink" title="服务器运行ID"></a>服务器运行ID</h3><p>当<strong>主服务器宕机</strong>后，某台从服务器被选举成为新的主服务器，就通过比较运行ID来区分谁是主服务器</p><ol><li><p>运行ID（run id）是服务器启动时自动生成的40个随机的十六进制字符串，主服务和从服务器均会生成运行ID</p></li><li><p>当从服务器首次同步主服务器的数据时，<strong>主服务器会发送自己的运行ID给从服务器</strong>，从服务器会保存在RDB文件中</p></li><li><p>当从服务器断线重连后，从服务器会向主服务器发送之前保存的主服务器运行ID，如果服务器运行ID匹配，则证明主服务器未发生更改，可以尝试进行增量同步</p></li><li><p>如果服务器运行ID不匹配，则进行全量同步</p></li></ol><h2 id="redis4-0之后"><a href="#redis4-0之后" class="headerlink" title="redis4.0之后"></a>redis4.0之后</h2><p>psync升级为psync2.0</p><p> psync2.0 抛弃了服务器运行ID，采用了replid和replid2来代替，其中replid存储的是当前主服务器的运行ID，replid2保存的是上一个主服务器运行ID</p><p>通过replid和replid2我们可以解决<strong>主服务器切换</strong>时，增量同步的问题：</p><ol><li><p>如果replid等于当前主服务器的运行id，那么判断同步方式增量&#x2F;全量同步</p></li><li><p>如果replid不相等，则判断replid2是否相等（是否同属于上一个主服务器的从服务器），如果相等，仍然可以选择增量&#x2F;全量同步，如果不相等则只能进行全量同步。</p></li></ol><h1 id="Redis哨兵"><a href="#Redis哨兵" class="headerlink" title="Redis哨兵"></a>Redis哨兵</h1><p>Redis Sentinel（哨兵）：由一个或多个Sentinel实例组成的Sentinel系统，它可以监视任意多个主从服务器</p><p>当监视的主服务器宕机时，自动下线主服务器，并且择优选取从服务器升级为新的主服务器。 </p><p><strong>Sentinel本质上就是一个Redis服务器，一个拥有较少命令和部分特殊功能的Redis服务器</strong></p><p><strong>哨兵的职能：</strong></p><ol><li>监控：不断地检查主节点和从节点是否运作正常。周期性地给所有的主从库发送 PING 命令，检测它们是否仍然在线运行，没有在规定时间内响应哨兵的 PING 命令，哨兵就会把它标记为“下线状态”；若主库下线，就会开始自动切换主库的流程。</li><li>通知：当被监控的某个 Redis 服务器出现问题时， 哨兵可以通过 API 向管理员或者其他应用程序发送通知。当推举出新主库时，哨兵会把新主库的连接信息发给其他从库，和新主库建立连接。同时也会将连接信息通知客户端。</li><li>故障转移：当 主节点 不能正常工作时，哨兵会开始故障转移操作<strong>，</strong>它会将失效主节点的其中一个 从节点升级为新的主节点，并让其他从节点改为复制新的主节点。</li><li>配置提供：客户端在初始化时，通过连接哨兵来获得当前 Redis 服务的主节点地址，当试图连接失效的主服务器时，哨兵集群也会向客户端返回新主服务器的地址</li></ol><h3 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h3><p><strong>哨兵进程会使用 PING 命令检测它自己和主、从库的网络连接情况，用来判断实例的状态</strong>。如果哨兵发现主库或从库对 PING 命令的响应超时了，那么，哨兵就会先把它标记为“主观下线”。如果检测的是从库，那么哨兵直接标记为“下线”，因为从库的下线影响一般不太大，集群的对外服务不会间断。</p><p>但是，如果检测的是主库，那么，哨兵还不能简单地把它标记为“主观下线”，因为有可能出现误判。一旦错误启动了主从切换，后续的选主和通知操作都会带来额外的计算和通信开销。误判一般会发生在<strong>集群网络压力较大、网络拥塞，或者是主库本身压力较大</strong>的情况下。</p><p>因为哨兵通常会采用多实例组成的集群模式进行部署，这也被称为<strong>哨兵集群</strong>。引入集群一起来判断，多个哨兵的网络同时不稳定的概率较小，就可以避免单个哨兵误判的情况。</p><p>在判断主库是否下线时，只有大多数（一半以上）的哨兵实例都判断主库已经“主观下线”了，主库才会被标记为<strong>客观下线</strong></p><h3 id="故障转移的步骤"><a href="#故障转移的步骤" class="headerlink" title="故障转移的步骤"></a>故障转移的步骤</h3><ol><li>在Slave中选择数据最新的作为新的Master</li><li>向其他Slave发送新的复制指令，让其他从服务器成为新的Master的Slave</li><li>继续监视旧Master，如果其上线则将旧Master设置为新Master的Slave</li></ol><h1 id="Redis的数据过期淘汰策略"><a href="#Redis的数据过期淘汰策略" class="headerlink" title="Redis的数据过期淘汰策略"></a>Redis的数据过期淘汰策略</h1><p>定期删除策略：启用一个计时器定时监视所有的key，判断key是否过期，过期就删除。这种策略可以保证过期的Key最终都会被删除。缺点：遍历内存中所有的key非常消耗CPU。并且如果key已经过期，但是计时器未被唤起，这段时间内Key仍可以使用</p><p>惰性删除策略：在获取key时，才判断key是否过期，过期即可删除。缺点：若key一直未被使用，那么就算过期了也不会被删除</p><p>定期删除+惰性删除：结合两者的特性，每次选取部分key扫描，减轻了CPU的负担。</p><p>内存淘汰机制：</p><ol><li>volatile-lru：从已设置过期时间的数据集中选取最少使用的数据淘汰</li><li>volatile-ttl：从已设置过期时间的数据集中选取将要过期的数据淘汰</li><li>volatile-random：随机选取数据淘汰</li><li>allkeys-lru：当内存不足以容纳新数据时，移除最少使用的Key</li><li>allkeys-random：从数据集中任意选择数据淘汰</li><li>no-eviction：禁止淘汰数据，满了就拒绝写入</li></ol><h1 id="Redis缓存穿透"><a href="#Redis缓存穿透" class="headerlink" title="Redis缓存穿透"></a>Redis缓存穿透</h1><p>缓存穿透是指查询一个根本不存在的数据，缓存层和持久层都不会命中，请求都会压到数据库，从而压垮数据库。</p><p>比如用户一个不存在的用户id获取用户信息</p><p>在日常工作中出于容错的考虑，如果从持久层查不到数据则不写入缓存层，缓存穿透将导致不存在的数据每次请求都要到持久层去查询，失去了缓存保护后端持久的意义。</p><h3 id="缓存穿透解决方案："><a href="#缓存穿透解决方案：" class="headerlink" title="缓存穿透解决方案："></a>缓存穿透解决方案：</h3><ol><li><strong>对空值缓存</strong>：如果一个查询返回的数据为空（不管数据是否存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟。</li><li><strong>设置可访问的白名单</strong>：使用bitmaps；类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmaps里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问</li><li><strong>采用布隆过滤器</strong>：用布隆过滤器当缓存的索引，只有在布隆过滤器中，才去查询缓存，如果不在布隆器中，则直接返回。</li></ol><p><img src="/../img/filter.png" alt="filter"></p><p>布隆过滤器是一种概率型数据结构，它可以告诉你某种东西<strong>一定不存在或者可能存在</strong>，当布隆过滤器说，某种东西存在时，这种东西可能不存在；当布隆过滤器说，某种东西不存在时，那么这种东西一定不存在。 常用于解决一个元素是否在某个集合中的业务场景，但是判断某种东西是否存在时，可能会被误判。</p><p>向布隆过滤器中添加key时，会使用多个hash函数对key进行hash并取模获得一个位置，每个hash函数都会算得一个不同的位置，把数组的这几个位置都置为1。</p><p>向布隆过滤器询问key是否存在时，计算散列值，看看位数组中这几个位置是否都为1，只要有一个位为0，那么说明布隆过滤器中这个<strong>key一定不存在</strong>。</p><p>如果这几个位置都是1，只是<strong>极有可能存在</strong>，因为这些位被置为1可能是因为其他的key存在所致。如果这个位数组比较稀疏，判断正确的概率就会很大，如果这个位数组比较拥挤，判断正确的概率就会降低。</p><h1 id="Redis缓存击穿"><a href="#Redis缓存击穿" class="headerlink" title="Redis缓存击穿"></a>Redis缓存击穿</h1><p>缓存击穿是指缓存中没有但数据库中有的数据，这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。比如微博热搜的一个突发事件，如果没有把这个词条作为热点词存储到缓存中或者缓存时间到期，那么用户访问这个词时，就会通过缓存，直接访问数据库，引起数据库压力瞬间增大。</p><p>它和缓存穿透的区别在于：<strong>缓存击穿是指缓存中没有但数据库中有的数据</strong>，由于并发用户特别多，同时读缓存没读到数据，同时数据库取数据引起数据库压力瞬间增大，造成过大压力。<strong>缓存穿透是指缓存和数据库中都没有的数据</strong>，而用户不断发起请求。</p><h3 id="缓存击穿解决方案："><a href="#缓存击穿解决方案：" class="headerlink" title="缓存击穿解决方案："></a>缓存击穿解决方案：</h3><ol><li><strong>预先设置热门数据</strong>：在redis高峰访问前，把一些热门数据提前存入redis中，监控哪些数据是热门数据，实时调整key的过期时长</li><li><strong>使用分布式锁</strong>：</li></ol><h1 id="Redis缓存雪崩"><a href="#Redis缓存雪崩" class="headerlink" title="Redis缓存雪崩"></a>Redis缓存雪崩</h1><p><strong>情况一</strong>：当数据保存在缓存中，并且设置了过期时间。如果在某一个时刻，大量数据同时过期，此时，再访问这些数据的话，就会发生缓存缺失，应用就会把请求发送给数据库，从数据库中读取数据。如果应用的并发请求量很大，从而导致数据库压力激增</p><h3 id="情况一解决方案"><a href="#情况一解决方案" class="headerlink" title="情况一解决方案"></a>情况一解决方案</h3><ol><li>避免给大量的数据设置相同的过期时间，可以使用一个较小的随机数来作为波动值（随机增加 1~3 分钟），这样一来，不同数据的过期时间有所差别，但差别又不会太大，既避免了大量数据同时过期，同时也保证了这些数据基本在相近的时间失效，仍然能满足业务需求。</li><li>服务降级：对于优先级不同的数据采用不同的应对措施来降低数据库压力。当业务应用访问非核心数据（例如电商商品属性）时，暂时停止从缓存中查询这些数据，而是直接返回预定义信息、空值或是错误信息；当业务应用访问核心数据（例如电商商品库存）时，仍然允许查询缓存，如果缓存缺失，也可以继续通过数据库读取。</li></ol><p><strong>情况二</strong>：Redis 缓存实例发生故障宕机，无法处理请求，导致大量请求同时积压到持久层，从而发生缓存雪崩。</p><h3 id="情况二解决方案"><a href="#情况二解决方案" class="headerlink" title="情况二解决方案"></a>情况二解决方案</h3><ol><li>服务熔断：暂停业务应用对缓存系统的接口访问。业务应用调用缓存接口时，缓存客户端并不把请求发给 Redis 缓存实例，而是直接返回，等到 Redis 缓存实例重新恢复服务后，再允许应用请求发送到缓存系统。避免引发连锁的数据库雪崩。但是这种方法对业务应用的影响大，因为暂停了访问</li><li>请求限流：不暂停，而是限制访问量，在业务系统的请求入口前端控制每秒进入系统的请求数，避免过多的请求被发送到数据库。</li><li>事前预防：构建 Redis 缓存高可靠集群。如果 Redis 缓存的主节点故障宕机了，从节点还可以切换成为主节点，继续提供缓存服务，避免了由于缓存实例宕机而导致的缓存雪崩问题。</li></ol><h1 id="Redis网络模型"><a href="#Redis网络模型" class="headerlink" title="Redis网络模型"></a>Redis网络模型</h1><h2 id="Redis为何选择单线程，其性能瓶颈究竟在哪里"><a href="#Redis为何选择单线程，其性能瓶颈究竟在哪里" class="headerlink" title="Redis为何选择单线程，其性能瓶颈究竟在哪里"></a><em>Redis为何选择单线程，其性能瓶颈究竟在哪里</em></h2><blockquote><p>Redis 官方的对于此的回答是：</p><p>对于一个 DB 来说，CPU 通常不会是瓶颈，因为大多数请求<strong>不是 CPU 密集型</strong>的，<strong>而是 I&#x2F;O 密集型</strong>。</p><p>具体到 Redis 的话，如果不考虑 RDB&#x2F;AOF 等持久化，Redis 是完全的纯内存操作，执行速度是非常快的，因此这部分操作通常不会是性能瓶颈，Redis <strong>真正的性能瓶颈在于网络 I&#x2F;O</strong>，也就是客户端和服务端之间的网络传输延迟，因此 Redis 选择了单线程的 I&#x2F;O 多路复用来实现它的核心网络模型。</p></blockquote><ol><li>避免过多的上下文切换开销：上下文的切换涉及程序计数器、堆栈指针和程序状态字等一系列的<strong>寄存器置换</strong>、程序堆栈重置，如果是进程内的多线程切换还OK，因为单一进程内多线程共享进程地址空间，线程上下文切换代价比较小。如果是跨进程调度，则需要切换掉整个进程地址空间，开销就会很大，而单线程则可以规避进程内频繁的线程切换开销，因为程序始终运行在进程中单个线程内，没有多线程切换的场景。</li><li>避免同步机制的开销：如果 Redis 选择多线程模型，又因为 Redis 是一个数据库，那么势必涉及到底层数据同步的问题，则必然会引入同步锁，而Redis 不仅仅提供了简单的 key-value 数据结构，还有 list、set 和 hash 等等数据结构，不同数据结构的加锁粒度又不尽相同，如果引入多线程，同步锁的竞争和锁释放会增加程序复杂度，还会降低性能。</li><li>简单可维护：Redis 选择单线程可以说是多方博弈之后的一种权衡：在保证足够的性能表现之下，使用单线程保持代码的简单和可维护性。</li></ol><p>Redis 最初选择的是单线程网络模型，因为CPU通常不会成为性能瓶颈。瓶颈往往是<strong>内存</strong>和<strong>网络</strong>，因此单线程足够了。然而随着互联网的飞速发展，互联网业务系统所要处理的线上流量越来越大，Redis 的单线程模式会导致系统消耗很多 CPU 时间在网络 I&#x2F;O 上从而降低吞吐量，<strong>所以Redis 的网络 I&#x2F;O 瓶颈就越来越明显</strong>。要提升 Redis 的性能有两个方向：优化网络 I&#x2F;O 模块，提高机器内存读写的速度。前者依赖IO模型的设计优化，后者则依赖于硬件的发展。</p><h2 id="Redis到底是不是单线程的？"><a href="#Redis到底是不是单线程的？" class="headerlink" title="Redis到底是不是单线程的？"></a><em>Redis到底是不是单线程的？</em></h2><p>其实Redis 早在4.0就已经引入了多线程。</p><h4 id="Redis4-0"><a href="#Redis4-0" class="headerlink" title="Redis4.0"></a>Redis4.0</h4><p><strong>引入多线程处理异步任务</strong></p><p>Redis 的 <code>DEL</code> 命令是用来删除掉一个或多个 key 储存的值，它是一个阻塞的命令，删除的 key 里的值最多几十上百个对象时，可以很快完成，阻塞不明显。但是如果你要删的是一个超大的键值对，里面有几百万个对象，那么这条命令可能会阻塞至少好几秒，又因为事件循环是单线程的，所以会阻塞后面的其他事件，导致吞吐量下降。于是，在 Redis4.0 之后增加了一些的非阻塞命令如 <code>UNLINK</code>。</p><p><code>UNLINK</code> 命令其实就是 <code>DEL</code> 的异步版本，它不会同步删除数据，而是把 key 从 keyspace 中暂时移除掉，然后将任务添加到一个异步队列，由<strong>后台线程</strong>去删除，不过如果用 <code>UNLINK</code> 去删除一个很小的 key，用异步的方式去做反而开销更大。所以它会先<strong>计算一个开销</strong>，只有当这个值大于 64 才会使用异步的方式去删除 key，对于基本的数据类型如 List、Set、Hash 这些，开销就是其中存储的对象数量。</p><h4 id="Redis6-0"><a href="#Redis6-0" class="headerlink" title="Redis6.0"></a>Redis6.0</h4><p><strong>正式在网络模型中实现 I&#x2F;O 多线程</strong></p><p>见下文详解</p><h2 id="为什么redis这么快"><a href="#为什么redis这么快" class="headerlink" title="为什么redis这么快"></a><em><strong>为什么redis这么快</strong></em></h2><ol><li>完全基于内存，所以IO效率高</li><li>纯C语言实现</li><li>单线程模型（引入IO多线程）</li><li>合理高效的数据结构</li><li>IO多路复用处理客户端socket连接</li></ol><h2 id="单线程事件循环模型（v1-0到v6-0）"><a href="#单线程事件循环模型（v1-0到v6-0）" class="headerlink" title="单线程事件循环模型（v1.0到v6.0）"></a>单线程事件循环模型（v1.0到v6.0）</h2><p><img src="/../img/redisIO.png" alt="redisIO"></p><p>从 Redis 的 v1.0 到 v6.0 版本之前，Redis 的核心网络模型一直是一个典型的单 Reactor 模型：</p><p>利用 epoll&#x2F;select&#x2F;kqueue等多路复用技术，在单线程的事件循环中不断去处理事件（客户端请求），最后回写响应数据到客户端</p><p><strong>client</strong>：客户端对象，Redis 是典型的 CS 架构（Client &lt;—&gt; Server），客户端通过 <strong>socket</strong> 与服务端建立网络通道然后发送请求命令，服务端执行请求的命令并回复。<strong>Redis</strong> 使用结构体 <strong>client</strong> 存储客户端的所有相关信息以及进行数据的收发。因为是NIO，所以面向缓冲区，client对象内包括但不限于<code>读入缓冲区 -- querybuf</code>，<code>写出缓冲区 -- buf</code>，<code>写出数据链表 -- reply</code></p><p><strong>aeApiPoll</strong>：I&#x2F;O 多路复用 API，是基于 epoll_wait&#x2F;select&#x2F;kevent 等系统调用的封装，监听等待读写事件触发，然后处理，它是事件循环（Event Loop）中的核心函数，是事件驱动得以运行的基础。</p><p><strong>acceptTcpHandler</strong>：连接应答处理器，底层使用系统调用 <code>accept</code> 接受来自客户端的新连接，并为新连接注册绑定命令读取处理器，以备后续处理新的客户端 TCP 连接；</p><p><strong>readQueryFromClient</strong>：命令读取处理器，解析并执行客户端的请求命令。</p><p><strong>beforeSleep</strong>：事件循环中进入 aeApiPoll 等待事件到来之前会执行的函数，其中包含一些日常的任务，比如把 <code>client-&gt;buf</code> 或者 <code>client-&gt;reply</code> （后面会解释为什么这里需要两个缓冲区）中的响应写回到客户端，持久化 AOF 缓冲区的数据到磁盘等，相对应的还有一个 afterSleep 函数，在 aeApiPoll 之后执行。</p><p><strong>sendReplyToClient</strong>：命令回复处理器，当一次事件循环之后写出缓冲区中还有数据残留，则这个处理器会被注册绑定到相应的连接上，等连接触发写就绪事件时，它会将写出缓冲区剩余的数据回写到客户端。</p><p><strong>Redis 内部实现了一个高性能的事件库 — AE，基于 epoll&#x2F;select&#x2F;kqueue&#x2F;evport 四种事件驱动技术，实现 Linux&#x2F;MacOS&#x2F;FreeBSD&#x2F;Solaris 多平台的高性能事件循环模型。Redis 的核心网络模型正式构筑在 AE 之上，包括 I&#x2F;O 多路复用、各类处理器的注册绑定，都是基于此才得以运行。</strong></p><p>以下便是单线程事件循环模型的全过程：</p><ol><li>Redis 服务器启动，开启主线程事件循环（Event Loop），注册 <code>acceptTcpHandler</code> 连接应答处理器到用户配置的监听端口对应的文件描述符，等待新连接到来；</li><li>客户端和服务端建立网络连接；</li><li><code>acceptTcpHandler</code> 被调用，主线程将 <code>readQueryFromClient</code> 命令读取处理器绑定到新连接对应的文件描述符上，并初始化一个 <code>client</code> 对象绑定这个客户端连接；</li><li>客户端发送请求命令，触发读就绪事件，主线程调用 <code>readQueryFromClient</code>将从 socket 读取到的命令存入 <code>client-&gt;querybuf</code> 读入缓冲区；</li><li>接着调用 <code>processInputBuffer</code>，在其中使用 <code>processInlineBuffer</code> 或者 <code>processMultibulkBuffer</code> 解析命令，最后调用 <code>processCommand</code> 执行命令；</li><li>根据请求命令的类型（SET, GET, DEL, EXEC 等），分配相应的命令执行器去执行，最后调用 <code>addReply</code> 函数族将响应数据写入到对应 <code>client</code> 的写出缓冲区：<code>client-&gt;buf</code> 是首选的写出缓冲区，固定大小 16KB，一般来说可以缓冲足够多的响应数据，但是如果客户端在时间窗口内需要响应的数据非常大，那么则会自动切换到 <code>client-&gt;reply</code> 链表上去，使用链表理论上能够保存无限大的数据（受限于机器的物理内存），最后把 <code>client</code> 添加进一个 LIFO 队列 <code>clients_pending_write</code>；</li><li>在事件循环（Event Loop）中，主线程执行 <code>beforeSleep</code> –&gt; <code>handleClientsWithPendingWrites</code>，遍历 <code>clients_pending_write</code> 队列，调用 <code>writeToClient</code> 把 <code>client</code> 的写出缓冲区里的数据回写到客户端，如果写出缓冲区还有数据遗留，则注册 <code>sendReplyToClient</code> 命令回复处理器到该连接的写就绪事件，等待客户端可写时在事件循环中再继续回写残余的响应数据。</li></ol><p>总结概括：</p><p><strong>主线程承包了连接的处理，命令的解析以及数据的收发。使用命令读取处理器监听文件描述符，当读事件发生时，主线程便会到已经读取到数据的缓冲区进行处理，并写入数据到写缓冲区，写完成后便会将client对象添加到就绪队列中。使用事件循环将队列中的数据写回客户端。</strong></p><p><img src="/../img/redisIO1.png" alt="redisIO1"></p><p><strong>其实就是很典型的单reactor模型</strong></p><p>Redis 的核心网络模型在 6.0 版本之前，一直是单 Reactor 模式，虽然在 4.0 版本中引入了多线程，但是那个更像是针对特定场景（删除超大 key 值等）而打的补丁，并不能被视作核心网络模型的多线程。</p><h2 id="Redis-多线程网络模型（v6-0之后）"><a href="#Redis-多线程网络模型（v6-0之后）" class="headerlink" title="Redis 多线程网络模型（v6.0之后）"></a>Redis 多线程网络模型（v6.0之后）</h2><p>前文说到，要提升 Redis 的性能有两个方向：优化网络 I&#x2F;O 模块，提高机器内存读写的速度。后者由于硬件的限制，暂时无解。</p><p>网络 I&#x2F;O 的优化又可以分为两个方向：零拷贝技术或者 DPDK 技术，利用多核优势。</p><p>零拷贝具有局限性，无法完全适配 Redis 这一类复杂的网络 I&#x2F;O 场景，因此，利用多核优势成为了优化网络 I&#x2F;O 性价比最高的方案。</p><p><img src="/../img/RedisIO2.png" alt="RedisIO2"></p><ol><li>Redis 服务器启动，开启主线程事件循环（Event Loop），注册 <code>acceptTcpHandler</code> 连接应答处理器到用户配置的监听端口对应的文件描述符，等待新连接到来；</li><li>客户端和服务端建立网络连接；</li><li><code>acceptTcpHandler</code> 被调用，主线程将 <code>readQueryFromClient</code> 命令读取处理器绑定到新连接对应的文件描述符上，并初始化一个 <code>client</code> 绑定这个客户端连接；</li><li>客户端发送请求命令，触发读就绪事件，服务端主线程不会通过 socket 去读取客户端的请求命令，而是先将 <code>client</code> 放入一个 LIFO 队列 <code>clients_pending_read</code>；</li><li>在事件循环（Event Loop）中，主线程执行 <code>beforeSleep</code> –&gt;<code>handleClientsWithPendingReadsUsingThreads</code>，利用 Round-Robin 轮询策略，把 <code>clients_pending_read</code>队列中的<strong>连接均匀地分配给 I&#x2F;O 线程各自的本地 FIFO 任务队列</strong> <code>io_threads_list[id]</code> 和主线程自己，I&#x2F;O 线程通过 socket 读取客户端的请求命令，存入 <code>client-&gt;querybuf</code> 并解析第一个命令，<strong>但不执行命令</strong>，主线程忙轮询，等待所有 I&#x2F;O 线程完成读取任务；</li><li>主线程和所有 I&#x2F;O 线程都完成了读取任务，主线程结束忙轮询，遍历 <code>clients_pending_read</code> 队列，<strong>执行所有客户端连接的请求命令</strong>，先调用 <code>processCommandAndResetClient</code> 执行第一条已经解析好的命令，然后调用 <code>processInputBuffer</code> 解析并执行客户端连接的所有命令，在其中使用 <code>processInlineBuffer</code> 或者 <code>processMultibulkBuffer</code> 根据 Redis 协议解析命令，最后调用 <code>processCommand</code> 执行命令；</li><li>根据请求命令的类型（SET, GET, DEL, EXEC 等），分配相应的命令执行器去执行，最后调用 <code>addReply</code> 函数族将响应数据写入到对应 <code>client</code> 的写出缓冲区：<code>client-&gt;buf</code>  <code>client-&gt;reply</code> ，和单线程模型一样，最后把 <code>client</code> 添加进一个 LIFO 队列 <code>clients_pending_write</code>；</li><li>在事件循环（Event Loop）中，主线程执行 <code>beforeSleep</code> –&gt; <code>handleClientsWithPendingWritesUsingThreads</code>，利用 Round-Robin 轮询策略，把 <code>clients_pending_write</code> 队列中的连接均匀地分配给 I&#x2F;O 线程各自的本地 FIFO 任务队列 <code>io_threads_list[id]</code> 和主线程自己，I&#x2F;O 线程通过调用 <code>writeToClient</code> 把 <code>client</code> 的写出缓冲区里的数据回写到客户端，主线程忙轮询，等待所有 I&#x2F;O 线程完成写出任务；</li><li>主线程和所有 I&#x2F;O 线程都完成了写出任务， 主线程结束忙轮询，遍历 <code>clients_pending_write</code> 队列，如果 <code>client</code> 的写出缓冲区还有数据遗留，则注册 <code>sendReplyToClient</code> 到该连接的写就绪事件，等待客户端可写时在事件循环中再继续回写残余的响应数据。</li></ol><p><strong>总结：大部分逻辑和之前的单线程模型是一致的，变动的地方仅仅是把读取客户端请求命令和回写响应数据的逻辑异步化，主线程使用轮询将client对象分配给不同的IO线程，每个IO线程自带一个队列，由IO线程完成请求的读取和数据的写回。需要注意的是：I&#x2F;O 线程仅仅是读取和解析客户端命令而不会真正去执行命令，客户端命令的执行最终还是要在主线程上完成。</strong></p><h3 id="既然是多线程，那么有同步锁吗"><a href="#既然是多线程，那么有同步锁吗" class="headerlink" title="既然是多线程，那么有同步锁吗"></a><em><strong>既然是多线程，那么有同步锁吗</strong></em></h3><p>Redis 的多线程模式下，是没有对数据进行锁保护的，事实上 Redis 的多线程模型是全程无锁（Lock-free）的。</p><p>这是通过原子操作+交错访问来实现的，主线程和 I&#x2F;O 线程之间共享的变量有三个：<code>io_threads_pending</code> 计数器、<code>io_threads_op</code> I&#x2F;O 标识符和 <code>io_threads_list</code> 线程本地任务队列。</p><p><code>io_threads_pending</code> 是原子变量，不需要加锁保护，<code>io_threads_op</code> 和 <code>io_threads_list</code> 这两个变量则是通过<strong>控制主线程和 I&#x2F;O 线程交错访问</strong>来规避共享数据竞争问题：I&#x2F;O 线程启动之后会通过<strong>忙轮询</strong>和锁休眠等待主线程的信号，在这之前它不会去访问自己的本地任务队列 <code>io_threads_list[id]</code>，</p><p>而主线程会在分配完所有任务到各个 I&#x2F;O 线程的本地队列之后才去唤醒 I&#x2F;O 线程开始工作</p><p>并且主线程之后在 I&#x2F;O 线程运行期间只会访问自己的本地任务队列 <code>io_threads_list[0]</code> 而不会再去访问 I&#x2F;O 线程的本地队列，这也就保证了主线程永远会在 I&#x2F;O 线程之前访问 <code>io_threads_list</code> 并且之后不再访问，保证了交错访问。</p><p><code>io_threads_op</code> 同理，主线程会在唤醒 I&#x2F;O 线程之前先设置好 <code>io_threads_op</code> 的值，并且在 I&#x2F;O 线程运行期间不会再去访问这个变量。</p><h3 id="Redis的多线程网络模型和标准的多reactor模式有什么区别？"><a href="#Redis的多线程网络模型和标准的多reactor模式有什么区别？" class="headerlink" title="Redis的多线程网络模型和标准的多reactor模式有什么区别？"></a><em><strong>Redis的多线程网络模型和标准的多reactor模式有什么区别？</strong></em></h3><p>在标准的 Multi-Reactors&#x2F;Master-Workers 模式下，Workers 会完成 <code>网络读 -&gt; 数据解析 -&gt; 命令执行 -&gt; 网络写</code> 整套流程，而Master 只负责分派任务。</p><p>而在 Redis 的多线程方案中，I&#x2F;O 线程任务仅仅是通过 socket 读取客户端请求命令并解析，没有真正去执行命令，所有<strong>客户端命令最后还需要回到主线程去执行</strong>，因此对多核的利用率并不算高，而且每次主线程都必须在分配完任务之后忙轮询等待所有 I&#x2F;O 线程完成任务之后才能继续执行其他逻辑。</p><p><img src="/../img/RedisIO3.png" alt="RedisIO3"></p><h3 id="为什么Redis要使用这种不寻常的线程模型？"><a href="#为什么Redis要使用这种不寻常的线程模型？" class="headerlink" title="为什么Redis要使用这种不寻常的线程模型？"></a><em><strong>为什么Redis要使用这种不寻常的线程模型？</strong></em></h3><p>即便是多线程，但是也仅仅是针对于网络IO，命令的执行还是只有一个主线程。Redis 之所以如此设计它的多线程网络模型，主要的原因是为了保持兼容性，因为以前 Redis 是单线程的，所有的客户端命令都是在单线程的事件循环里执行的，也因此 <strong>Redis 里所有的数据结构都是非线程安全的</strong>，现在引入多线程，如果按照标准的 Multi-Reactors&#x2F;Master-Workers 模式来实现，则所有内置的数据结构都必须重构成线程安全的，这个工作量无疑是巨大且麻烦的。所以Redis 目前的多线程方案更像是一个折中的选择：既保持了原系统的兼容性，又能利用多核提升 I&#x2F;O 性能。</p><h3 id="总结：Redis为其多线程网络模型做了哪些优化？"><a href="#总结：Redis为其多线程网络模型做了哪些优化？" class="headerlink" title="总结：Redis为其多线程网络模型做了哪些优化？"></a><em><strong>总结：Redis为其多线程网络模型做了哪些优化？</strong></em></h3><ul><li>使用 I&#x2F;O 线程实现网络 I&#x2F;O 多线程化，I&#x2F;O 线程只负责网络 I&#x2F;O 和命令解析，不执行客户端命令</li><li>利用原子操作+交错访问实现无锁的多线程模型</li><li>隔离主进程和其他子进程，让多线程网络模型能发挥最大的性能。Redis 通过设置 CPU 亲和性，可以将主进程和子进程绑定到不同的核隔离开来，使之互不干扰</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数据库基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>子集排列问题sucks</title>
    <link href="/post/%E5%AD%90%E9%9B%86%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98sucks.html"/>
    <url>/post/%E5%AD%90%E9%9B%86%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98sucks.html</url>
    
    <content type="html"><![CDATA[<h1 id="回溯算法解决所有子集排列问题"><a href="#回溯算法解决所有子集排列问题" class="headerlink" title="回溯算法解决所有子集排列问题"></a>回溯算法解决所有子集排列问题</h1><p>形式一：元素无重复，且不可复选，即nums中所有元素均唯一，且最多使用一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 组合/子集问题回溯算法框架 */</span><br><span class="hljs-comment">//使用start参数来避免复选</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>    <span class="hljs-comment">// 回溯算法标准框架</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">// 做选择</span><br>        track.addLast(nums[i]);<br>        <span class="hljs-comment">// 注意参数</span><br>        backtrack(nums, i + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 撤销选择</span><br>        track.removeLast();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/* 排列问题回溯算法框架 */</span><br><span class="hljs-comment">//使用used数组来记录已选过的元素，避免复选</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">// 剪枝逻辑</span><br>        <span class="hljs-keyword">if</span> (used[i]) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 做选择</span><br>        used[i] = <span class="hljs-literal">true</span>;<br>        track.addLast(nums[i]);<br><br>        backtrack(nums);<br>        <span class="hljs-comment">// 撤销选择</span><br>        track.removeLast();<br>        used[i] = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>形式二：元素有重复，但是不可以复选，即nums中存在重复的元素，但是每个元素只能使用一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(nums);<br><span class="hljs-comment">//为数组排序，使得相同的元素排在一起</span><br><span class="hljs-comment">/* 组合/子集问题回溯算法框架 */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>    <span class="hljs-comment">// 回溯算法标准框架</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">// 剪枝逻辑，跳过值相同的相邻树枝</span><br>        <span class="hljs-keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 做选择</span><br>        track.addLast(nums[i]);<br>        <span class="hljs-comment">// 注意参数</span><br>        backtrack(nums, i + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 撤销选择</span><br>        track.removeLast();<br>    &#125;<br>&#125;<br><br><br>Arrays.sort(nums);<br><span class="hljs-comment">/* 排列问题回溯算法框架 */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">// 剪枝逻辑</span><br>        <span class="hljs-keyword">if</span> (used[i]) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 剪枝逻辑，固定相同的元素在排列中的相对位置，若i-1未被选择，那么i也不能选，相当于固定了顺序</span><br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 做选择</span><br>        used[i] = <span class="hljs-literal">true</span>;<br>        track.addLast(nums[i]);<br><br>        backtrack(nums);<br>        <span class="hljs-comment">// 撤销选择</span><br>        track.removeLast();<br>        used[i] = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>形式三：元素无重复，但是可以复选</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 组合/子集问题回溯算法框架 */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>    <span class="hljs-comment">// 回溯算法标准框架</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">// 做选择</span><br>        track.addLast(nums[i]);<br>        <span class="hljs-comment">// 注意参数</span><br>        backtrack(nums, i);<br>        <span class="hljs-comment">// 撤销选择</span><br>        track.removeLast();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/* 排列问题回溯算法框架 */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">// 做选择</span><br>        track.addLast(nums[i]);<br>        backtrack(nums);<br>        <span class="hljs-comment">// 撤销选择</span><br>        track.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法归纳</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM相关知识</title>
    <link href="/post/JVM%E5%9F%BA%E7%A1%80.html"/>
    <url>/post/JVM%E5%9F%BA%E7%A1%80.html</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA内存区域讲解"><a href="#JAVA内存区域讲解" class="headerlink" title="JAVA内存区域讲解"></a>JAVA内存区域讲解</h1><p>运行时数据区域分为两部分：线程共享和线程私有</p><h2 id="线程共享区域："><a href="#线程共享区域：" class="headerlink" title="线程共享区域："></a>线程共享区域：</h2><ol><li><p>堆：是虚拟机内存的最大的一块，此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存，注意是“几乎”，JDK1.7之后，当方法中的对象引用没有被返回或者未被外部使用，就会直接在栈上分配内存。同时，堆也是垃圾收集器管理的主要区域，所以也被称为GC堆。</p></li><li><p>JDK1.8之前还有永久代实现的方法区，方法区是运行时数据区域的一个逻辑区域，在不同虚拟上方法区的实现是不同的，当虚拟机要使用一个类时，它需要读取并解析class文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的类信息，<strong>字段信息，方法信息，常量，静态变量</strong>，即时编译器编译后的代码缓存。</p><p>方法区有两种具体实现：永久代permanent gen和元空间metaspace。前者拥有一个由本身JVM设置的大小上限，无法调整，而在8版本之后，转而使用元空间，后者使用的是计算机的直接内存，溢出的概率更小。</p><p>方法区内比较常见的有静态变量和字符串常量池，后者是为了减少string类的内存消耗而专门开辟的，可以避免字符串的重复创建。方法区是一个公共且抽象的概念，在不同虚拟机上可以有不同的实现。</p><p><img src="/../img/MethodArea.png" alt="MethodArea"></p><p><img src="/../img/MethodArea1.png" alt="MethodArea1"></p></li></ol><p><img src="/../img/MethodArea2.png" alt="MethodArea2"></p><h2 id="线程私有区域："><a href="#线程私有区域：" class="headerlink" title="线程私有区域："></a>线程私有区域：</h2><ol><li>虚拟机栈：由一个个栈帧组成，栈帧内包含：<strong>局部变量表</strong>（八大原始类型，对象引用），<strong>操作数栈</strong>（作为方法调用的中转站，存放中间计算结果，实现CPU的寄存器的功能），<strong>动态链接</strong>（当一个方法需要调用其他方法时，动态链接就是未来将符号引用转换为调用方法的直接引用），<strong>方法返回地址</strong>。方法调用的数据通过栈进行传递，每一个方法没调用时都会有一个对应的栈帧被压入，每一个方法调用结束后，都会有一个栈帧被弹出。当函数调用陷入无限循环，或者压栈太多，导致线程请求的栈的深度超过JAVA虚拟机栈的最大深度时，就会抛出,stackoverflow。栈帧的弹出：return语句，异常抛出，随方法的调用而创建，随方法的结束而销毁，所以无论方法是否正常完成还是异常完成，都可以视为方法结束。</li><li>本地方法栈：和虚拟机栈十分相似，但是本地方法是由c++编写的，所以这个栈是为native方法服务的，同样也会创建栈帧，同样也会抛出栈溢出的错误。</li><li>程序计数器PC：一块较小的内存空间，就是一个计数器，可以看作是当前线程执行的字节码的行号指示器，字节码解释器通过改变PC的值来选取下一条要执行的字节码指令，从而实现循环，跳转，异常处理等功能。每个线程都需要一个独立的PC，PC也是唯一一个不会出现outofmemory的内存区域。执行native方法时PC为空。</li></ol><h2 id="JAVA堆GC详解"><a href="#JAVA堆GC详解" class="headerlink" title="JAVA堆GC详解"></a>JAVA堆GC详解</h2><p>堆分为三部分：新生代，老年代，永久代（JDK8移除，功能由元空间代替实现）</p><h3 id="新生代Young-Gen"><a href="#新生代Young-Gen" class="headerlink" title="新生代Young Gen"></a>新生代Young Gen</h3><p>新生代用来存放新生的对象，一般占据1&#x2F;3。新生代中存放着大量刚刚创建的对象，但是大部分对象的存活时间都很短，所以会进行频繁的GC。新生代又分为三个部分Eden，SurvivorFrom，SurvivorTo 。这三个部分默认为8：1：1</p><p>为什么要分配为8：1：1</p><p>因为大部分对象都是朝生夕死，所以Eden区就设置大一些，存活区就设置小一些</p><p><strong>Eden区：</strong>Java新创建的对象绝大部分会分配在Eden区（如果对象太大，则直接分配到老年代）。当Eden区内存不够的时候，就会触发MinorGC（新生代采用的是<strong>复制算法</strong>），对新生代进行一次垃圾回收。</p><p><strong>SurvivorFrom区和SurvivorTo区：</strong>在GC开始的时候，对象只会存在于Eden区和名为From的Survivor区，To区是空的，一次MinorGc过后，Eden区和SurvivorFrom区存活的对象会移动到SurvivorTo区中，然后会清空Eden区和SurvivorFrom区，并对存活的对象的年龄+1，如果对象的年龄达到15，则直接分配到老年代。MinorGC完成后，SurvivorFrom区和SurvivorTo区的功能进行互换。下一次MinorGC时，会把SurvivorTo区和Eden区存活的对象放入SurvivorFrom区中，并计算对象存活的年龄。</p><h3 id="老年代Old-Gen"><a href="#老年代Old-Gen" class="headerlink" title="老年代Old Gen"></a>老年代Old Gen</h3><p>老年代用于存放生命周期较长的内存对象，老年代比较稳定，不会频繁的进行MajorGC。</p><p>而在MaiorGC之前才会先进行一次MinorGc，使得新生的对象进入老年代而导致空间不够才会触发。当无法找到足够大的连续空间分配给新创建的较大对象也会提前触发一次MajorGC进行垃圾回收腾出空间。</p><p>在老年代中，MajorGC采用了标记—清除算法：首先扫描一次所有老年代里的对象，标记出存活的对象，然后回收没有标记的对象。MajorGC的耗时比较长。因为要扫描再回收。MajorGC会产生内存碎片，当老年代也没有内存分配给新来的对象的时候，就会抛出OOM（Out of Memory）异常。</p><h3 id="永久代Permanent-Gen（方法区）"><a href="#永久代Permanent-Gen（方法区）" class="headerlink" title="永久代Permanent Gen（方法区）"></a>永久代Permanent Gen（方法区）</h3><p>永久代中包含了虚拟机中可以通过反射获取到的数据，比如Class对象和Method对象。JVM用于描述应用程序中用到的类和方法的元数据，如类的层级信息(包名，父类名，修饰符，接口)，方法的编译信息（参数，返回值，修饰符）及字节码，常量，静态变量就存储在永久代中，如果有类不再需要使用，空间会被释放留给其他类，full GC会进行永久代的回收</p><p>不同的java虚拟机之间可能会进行类共享，因此又分为只读区和读写区</p><p>永久代是有大小上限的，默认为64M，在堆内存中划出一块连续的空间分配给永久代</p><h3 id="元空间Meta-Space"><a href="#元空间Meta-Space" class="headerlink" title="元空间Meta Space"></a>元空间Meta Space</h3><p>JDK8开始，永久代被彻底删除，替换为元空间，JVM忽略了permsize这个参数，也就是没有outOfMemoryError异常。</p><p>字符串常量池和静态变量也转移到了堆内存，因为字符串在永久代中容易造成性能问题</p><p>元空间使用本地内存来存储类的元数据，所以不再归JVM管理</p><p>为什么要抛弃永久代：</p><ol><li>永久代的大小在启动时就会固定好，很难进行调优修改</li><li>元空间使用堆外内存，不由JVM管理，由OS来管理，所以可以不暂停GC的情况下释放类数据</li><li>元空间的每个类加载器都有专门的存储空间</li><li>充分利用了java语言规范的好处：类及相关的元数据的生命周期与类加载器一致</li><li>省略了GC的扫描和压缩的时间</li><li>元空间里面对象的位置是固定的，无需堆内存内GC时将对象不断移动</li><li>元空间只进行线性分配，指针碰撞+OS本地内存&#x3D;大小上限提升，分配内存更迅捷</li></ol><h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><p>堆内有大量的对象，所以需要GC来不断处理，以保证堆内存空间的合理使用</p><p>并行（Parallel）：多个GC线程并行工作，用户线程等待</p><p>并发（Concurrent）：用户线程和垃圾GC线程同时进行</p><p>如何判断一个对象能否被删除</p><p>被虚拟机栈，本地方法栈，静态变量，字符串常量引用的对象，不能被GC</p><p>若可以被删除：打上标记</p><ol><li>标记清理算法：扫描一遍全部对象，删除带标记的对象，容易产生内存碎片</li><li>标记整理算法：扫描一遍全部对象，删除带标记的对象，清理后需要紧凑，不断移动对象，代价比较大</li><li>复制算法：分为1区和2区，无需删除的对象被紧凑复制到2区，然后清空1区，需要两倍的内存</li><li>分代算法：核心是同时发挥“标记整理”和“复制”的优点，让他们分别去处理最适合自己的情况。分代就是为对象设置年龄，在新生代就触发新生代GC也叫minorGC，在老年代就触发老年代GC，也叫major GC，当方法区空间不足时会触发全局GC，也叫full GC</li></ol><img src="../img/GC.png" alt="GC" style="zoom:150%;" /><h2 id="新生代的GC"><a href="#新生代的GC" class="headerlink" title="新生代的GC"></a>新生代的GC</h2><p>垃圾回收器：（全部都是复制算法，参考上文）</p><ol><li>Serial：最基本，历史最悠久的收集器。单线程，简单，适合于单CPU环境，没有线程交互的开销，所以可以全力进行垃圾回收。需要Stop The World，但是效率不高</li><li>ParNew：其实就是多线程版的Serial，适合于多CPU环境，同样需要Stop The World</li><li>Parallel Scavenge：吞吐量优先收集器，同样是并行的。PS自带GC自适应调节策略：动态设置Eden和存活区的比例，新生代的大小，晋升老年代的对象年龄。虚拟机会根据运行状态信息来动态调整以获取最优的吞吐量和响应时间。</li></ol><h2 id="老年代的GC"><a href="#老年代的GC" class="headerlink" title="老年代的GC"></a>老年代的GC</h2><ol><li>CMS：回收停顿时间优先收集器，基于标记清除算法混合标记整理，并发（Concurrent），低停顿。</li><li>Serial Old：老年代版本Serial，标记整理</li><li>Parallel Old：老年代版本的Parallel，标记整理</li></ol><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>低停顿的第一次尝试</p><ol><li>初始标记：单线程+Stop The World，只扫描和GC root直接关联的对象</li><li>并发标记：并发，进行GC root tracing，在初始标记的基础上继续向下追溯标记，标记出所有存活对象，用户线程可并发</li><li>重新标记：Stop The World，修正并发标记期间因为用户线程的运行而造成的标记变动</li><li>并发清除：并发清除垃圾</li></ol><p>并发标记和并发清除是可以和用户线程同时进行的，另外两个阶段需要Stop The World</p><p>特点：</p><ol><li><strong>对CPU资源非常敏感</strong>：在并发阶段，虽然是并发，但是由于会占用一部分的处理器资源，从而会影响用户线程的性能。CMS默认的回收线程数是（CPU核心数+3）&#x2F;4，所以如果当CPU核心数小于4个，用户线程受到的影响就会非常大。CMS曾经提供过解决方法，就是在并发标记，并发清除的阶段让回收线程和用户线程交替进行从而减少影响。但是效果有限，在JDK9后就被彻底弃用了。</li><li>无法在一次GC流程中处理浮动垃圾：由于具有并发性，用户线程常常会在GC时产生新的垃圾对象，所以无法一次清除。所以需要为老年代设置阈值，JDK1.5是68%，JDK6是92%，当碎片过多时会直接触发GC进行整理。所以会出现一些极端情况，在一次GC还未结束时，老年代使用了91%的空间，且用户线程仍然在不断创建新对象，老年代已经无法容纳，此时会出现并发失败。虚拟机不得不冻结所有的用户线程，转而使用serial收集器来GC，此时效率就大大降低了。</li><li>容易产生空间碎片：因为使用的是标记清除，所以会产生空间碎片，在JDK9之前，设定在因为碎片过多而产生FULL GC时进行碎片整理，即对碎片有一定容忍度。</li></ol><h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>一款面向服务端应用的垃圾收集器，抛弃了传统的分代思想</p><p>步骤：</p><ol><li>初始标记：单线程+Stop The World，只扫描和GC root直接关联的对象</li><li>并发标记：并发，进行GC root tracing，可达性分析，在初始标记的基础上继续向下追溯标记，标记出所有存活对象，用户线程可并发</li><li>重新标记：Stop The World，修正并发标记期间因为用户线程的运行而造成的标记变动</li><li>筛选回收：根据region的回收价值和用户期望的停顿时间来进行回收（stop the world）</li></ol><p>特点：</p><ol><li>以region代替分代思想：G1可以独自管理整个堆</li><li>可预测的停顿：G1能够建立可预测的停顿时间模型，能让使用者明确指定在一个时间段内，消耗在GC上的时间不超过N毫秒，原理：复制算法优先处理垃圾多的区域，可控</li><li>整体看是标记整理，region之间看是标记复制，不会产生碎片</li></ol><p>C1和CMS的区别：</p><ol><li>管理区域：C1可以管理整个堆，且会将堆分为若干个region来管理，region中可以划分新生代和老年代，且新生代和老年代的大小可以动态调整</li><li>G1收集器可预测垃圾回收的停顿时间（建立可预测的停顿时间模型），这个是G1的优势</li><li>最后一个阶段，CMS是并发的，而C1不是</li><li>G1产生的内存占用比CMS更高</li></ol><p><em><strong>G1如何实现可预测的停顿时间模型？</strong></em></p><p>将region作为GC的最小单元，每次GC时都会跟踪每个region里垃圾堆积的价值，比如回收的代价，以及回收该region需要的时间，等因素进行综合评估。评估后会维护一个优先级列表，每次会优先处理回收价值最高的region。从而将GC效率最大化。</p><h2 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h2><p>CMS算法的基础是通过可达性分析找到存活的对象，然后给存活的对象打个标记，最终在清理的时候，如果一个对象没有任何标记，就表示这个对象不可达，需要被清理，标记算法就是使用的三色标记。</p><p>并发标记阶段是从<strong>GC Root直接关联</strong>的对象开始枚举的过程</p><h4 id="GC-Root"><a href="#GC-Root" class="headerlink" title="GC Root"></a><strong>GC Root</strong></h4><ol><li>虚拟机栈（栈帧中的局部变量表）中引用的对象</li><li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li></ol><p>对象的三个状态：</p><ol><li>白色：这个对象还没有被访问过，在初始阶段，所有对象都是白色，所有都枚举完仍是白色的对象将会被当做垃圾对象被清理</li><li>灰色：这个对象已经被访问过，但是这个对象所直接引用的对象中，至少还有一个没有被访问到，表示这个对象正在枚举中</li><li>黑色：对象和它所直接引用的所有对象都被访问过。这里只要访问过就行，比如A只引用了B，B引用了C、D，那么只要A和B都被访问过，A就是黑色，即使B所引用的C或D还没有被访问到，此时B就是灰色。</li></ol><p>大致流程：</p><ol><li>首先我们从GC Roots开始枚举，它们所有的直接引用变为灰色，自己变为黑色。可以想象有一个队列用于存储灰色对象，会把这些灰色对象放到这个队列中</li><li>然后从队列中取出一个灰色对象进行分析：将这个对象所有的直接引用变为灰色，放入队列中，然后这个对象变为黑色；如果取出的这个灰色对象没有直接引用，那么直接变成黑色</li><li>继续从队列中取出一个灰色对象进行分析，分析步骤和第二步相同，一直重复直到灰色队列为空</li><li>分析完成后仍然是白色的对象就是不可达的对象，可以作为垃圾被清理</li><li>最后重置标记状态</li></ol><p>可能出现的两种问题</p><ol><li>一个本应该是垃圾的对象被视为了非垃圾</li><li>一个本应该不是垃圾的对象被视为了垃圾</li></ol><p>解决方式</p><ol><li>增量更新：站在新增引用的对象的角度来解决问题，在增加引用前添加一个写屏障，在屏障中记录新的引用。然后将引用关系中的黑色对象重新设置为灰色，在重新标记阶段再扫描一次，CMS</li><li>原始快照：站在减少引用的对象的角度来解决问题，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。G1使用，效率更高，但是会产生更多的浮动垃圾，只能等待下次GC</li></ol><p>这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索</p><h2 id="垃圾收集器如何选择"><a href="#垃圾收集器如何选择" class="headerlink" title="垃圾收集器如何选择"></a>垃圾收集器如何选择</h2><p>Client模式下的虚拟机：Serial</p><p>注重高吞吐量以及CPU资源敏感：Parallel Scavenge +Parallel Old</p><p>最小化Stop The World时间：G1或者ParNew+CMS</p><h1 id="类文件结构解析"><a href="#类文件结构解析" class="headerlink" title="类文件结构解析"></a>类文件结构解析</h1><p>字节码：.class扩展名</p><ol><li>魔数：magic number：每个class文件的头4个字节被称为魔数（CAFEBABE）唯一作用便是确定这个文件是否为一个能被虚拟机接收的class文件</li><li>class文件版本号：小版本号+大版本号。高版本的JVM可以执行低版本的class文件</li><li>常量池：常量池计数器+常量池数据区。计数器从1开始，若有某些指向常量池的索引值需要表达“不引用常量池中的项目”这一含义，则可以将索引值设为0。常量池数据区中主要存储两大常量：<strong>字面量：即文本字符串，或者被final修饰的常量等</strong>。<strong>符号引用：package，接口的全名，方法名称或描述符，字段名称或描述符等等</strong>。与c不同的是，java在编译时，不会有连接这一步骤，而是会在虚拟机加载class文件时进行动态连接，虚拟机在进行类加载时，将会从常量池中获得对应的符号引用，在类创建时或运行时解析，并翻译到具体的内存地址中。常量池中的每一项都是一个表。常量池可以看作是class文件里的资源仓库，占用空间最大。</li><li>访问标志：用于识别类或者接口的访问信息，比如class是类还是接口，public还是abstract，是否被final修饰等</li><li>索引集合：当前类，父类，接口索引集合</li><li>字段表集合：描述接口或类中声明的变量，不包括方法内声明的局部变量。字段计数器+字段表数据区</li><li>方法表集合：方法计数器+方法数据区</li></ol><h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载主要完成下面三件事情</p><ol><li>通过全类名获取定义此类的二进制字节流</li><li>将字节流代表的静态数据结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的class对象，作为方法区数据的访问入口</li></ol><h3 id="连接——验证"><a href="#连接——验证" class="headerlink" title="连接——验证"></a>连接——验证</h3><ol><li>文件格式验证：是否符合class文件格式的规范（CAFEBABE），主次版本号是否在虚拟机的处理范围内，常量池中的的常量是否都可以支持</li><li>元数据验证：对字节码的信息进行语义分析，保证描述的信息符合java的语言规范，比如这个类是否有父类，这个类是否继承了不被允许继承的类</li><li>字节码验证：这是最为复杂的一个阶段，通过数据流和控制流的分析，确定程序语义是合法，符合逻辑的，比如确保任意时刻操作数栈都能配合工作</li><li>符号引用验证：确保解析动作能正确执行</li></ol><h3 id="连接——准备"><a href="#连接——准备" class="headerlink" title="连接——准备"></a>连接——准备</h3><p>这个阶段会正式为变量分配内存并设置初始变量，仅包括类变量,static</p><h3 id="连接——解析"><a href="#连接——解析" class="headerlink" title="连接——解析"></a>连接——解析</h3><p>将常量池里的符号引用替换为直接引用，主要针对，接口，字段，类方法。符号引用就是用一组符号来描述目标，可以是任何字面量；直接引用就是直接指向目标的指针，偏移量</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>这是类加载的最后一步，执行初始化方法<clinit>，在这一步，JVM才真正开始执行类中定义的java程序代码</p><h3 id="JAVA的类加载器"><a href="#JAVA的类加载器" class="headerlink" title="JAVA的类加载器"></a>JAVA的类加载器</h3><ol><li>Bootstrap类加载器：即引导类加载器，由C++语言实现，无父类。主要加载的是JVM自身需要的类，是虚拟机自身的一部分，<strong>它负责<JAVA_HOME>&#x2F;lib路径下的核心类库</strong>或-Xbootclasspath参数指定的路径下的jar包加载到内存中，虚拟机按照文件名识别jar包，处于安全考虑，启动类加载器只加载包名为java,javax,sun等开头的jar包，即使将不符合要求的jar包丢入lib目录下也没法被识别。</li><li>Extention类加载器：即扩展类加载器，是指sun公司实现的ExtClassLoader类，由Java语言实现，父类加载器为null，是Launcher中的静态内部类，它<strong>负责加载<JAVA_HOME>&#x2F;lib&#x2F;ext目录</strong>或者由系统变量-Djava.ext.dir指定位路径中的类库，开发者可以直接使用标准扩展类加载器。</li><li>Application类加载器：即应用程序加载器，是指sun公司实现的appClassLoader，父类加载器为扩展类加载器。<strong>它负责加载class-path指定路径下的库类</strong>，也就是我们经常用到的classpath，一般情况下该类加载是程序中默认的类加载器。</li><li>Custom自定义类加载器：负责加载用户自定义路径下的类包，父类加载器为应用程序加载器</li></ol><p>类加载器的三大特征：</p><ol><li>委托性：即双亲委派机制，当类A被加载时，首先会委托给父类加载器。引导类加载器会在lib目录下查找是否存在，找到便加载，未找到便回到扩展类加载器。扩展类加载器会在&#x2F;lib&#x2F;ext目录下查找，找到便加载，未找到便回到应用程序加载器。应用程序加载器会在classPath路径下查找，找到则加载，未找到则抛出ClassNotFoundException异常</li><li>可见性：父类加载器加载的类可以被子类观察到，但是子类加载的类对父类不可见</li><li>一个类只可以被加载一次</li></ol><p>双亲委派机制：</p><img src="../img/classLoader.png" alt="classLoader" style="zoom: 67%;" /><h1 id="HOTSPOT虚拟机对象创建的过程"><a href="#HOTSPOT虚拟机对象创建的过程" class="headerlink" title="HOTSPOT虚拟机对象创建的过程"></a>HOTSPOT虚拟机对象创建的过程</h1><h4 id="类加载检测"><a href="#类加载检测" class="headerlink" title="类加载检测"></a>类加载检测</h4><p>虚拟机遇到new指令时，首先检查这条指令的参数是否能在常量池中定位到这个类的引用，检查这个符号引用代表的类是否已经被加载过，解析，或初始化。若没有，则先执行相应的类加载过程。</p><h4 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h4><p>为新对象分配内存，所需内存大小在类加载完成后就可以确定，分配内存的任务等同于将一块确定大小的内存从堆中划分出来。</p><ol><li>指针碰撞：堆内存规整，将用过的内存和没用过的内存整合到两边，中间有一个分界指针，只需要将指针移动相应大小即可完成分配。</li><li>空闲列表：堆内存不规整，虚拟机会维护一个列表，列表中会记录哪些内存块是可用的，寻找到一块满足大小的内存分配后，更新列表。</li></ol><h4 id="初始化零值"><a href="#初始化零值" class="headerlink" title="初始化零值"></a>初始化零值</h4><p>当内存分配后，需要将分配到的内存空间都初始化为0值，这一步保证了对象的字段在java代码中可以不赋值就能直接被使用，程序能访问这些字段的数据类型对应的0值</p><h4 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h4><p>这个对象是哪个类的实例，对象的HashCode，如何才能找到类的元数据信息，等信息处理后放入对象头中、</p><h4 id="执行init方法"><a href="#执行init方法" class="headerlink" title="执行init方法"></a>执行init方法</h4><p>在虚拟机的视角来看，对象的创建已经完成，但是对于java程序来说，对象创建才刚刚开始，在init之前所有的字段都是零值，init之后便会将对象按照程序员的意愿进行初始化，一个真正可用的对象才算真正创建。</p><h1 id="HotSpot的oop-klass模型"><a href="#HotSpot的oop-klass模型" class="headerlink" title="HotSpot的oop-klass模型"></a>HotSpot的oop-klass模型</h1><p>我们平时写的java类编译成.class文件，JVM加载.class文件，那么加载.class文件之后在JVM中就是oop-klass（C++）模型形式存在的</p><p>JVM内部基于oop-klass模型描述一个java类以及其实例</p><p>java类元信息用<strong>klass</strong>描述，对象用<strong>oop</strong>来描述</p><p><img src="/../img/OOP.png" alt="OOP"></p><p>jvm在加载class时，会创建instanceKlass，表示其元数据，包括常量池、字段、方法等，存放在<strong>方法区</strong></p><p>在new一个对象时，jvm创建instanceOopDesc，来表示这个对象，存放在<strong>堆区</strong></p><p>其引用，存放在<strong>栈区</strong>；</p><p>在JVM中，Hotspot并没有将Java对象直接映射成C++对象，而是实现了Java的对象模型（oop-klass）</p><p>因为C++的对象里含有虚表，这个虚表实现了C++对象的多态，而JVM不希望每个对象中都包含一份虚函数表</p><p>所以就把对象模型拆成 klass 和 oop，其中 oop 中不含有任何虚函数，而 klass 就含有虚函数表</p><h1 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h1><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>一般创建对象时如Object obj&#x3D;new Object()，obj指向堆内的instanceOOP，这个指向就是最常见的强引用</p><p>只要强引用存在，垃圾收集器就不会回收被引用的对象。</p><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>使用SoftReference类包装创建的对象如SoftReference<Object> softRef &#x3D; new SoftReference&lt;&gt;(obj)</p><p>此时softRef会以强引用指向堆内的SR对象实例，然后SR会以软引用的方式再指向Object实例</p><p>当要发生内存溢出时，软引用对象会被回收，无论是否被引用。</p><p>对<strong>适合作为缓存</strong>的对象实例添加软引用，内存够的适合拿来即用，内存不够的时候就被回收，避免OOM</p><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>和软引用类似，使用weakRefence类来进行包装</p><p>不过必要性再次降低，当GC时，无论内存是否够用，都会被回收</p><p><strong>解决Map或者ThreadLocal的内存泄露问题</strong></p><h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>使用PhantomReference来包装，PhantomReference<Object> pr &#x3D; new PhantomReference&lt;&gt;(obj,QUEUE);</p><p>这个队列就是引用队列ReferenceQueue，虚引用<strong>必须指定相应的引用队列</strong></p><p>虚引用也称作幽灵引用，虚引用并不会影响对象的生命周期，虚引用的特点就是可以充当信号量：</p><p>即当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到引用队列中，可以通过判断queue里面是不是有对象来判断你的对象是不是要被回收了</p><p><strong>这个特性可以用于管理操作系统的本地内存</strong>：</p><p>一些网络编程框架如基于NIO的netty，会使用操作系统的本地内存块作为buffer来接收管道传输的数据，</p><p>通常会在JVM里创建指向这个内存块的指针来进行管理，<strong>而GC的范围仅限于JVM</strong></p><p>所以就需要进行通知：当这个指针被回收时-&gt;虚引用进入队列-&gt;检测到队列里有虚引用-&gt;回收指针以及指向的OS内存块</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA的字符串</title>
    <link href="/post/Java%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.html"/>
    <url>/post/Java%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.html</url>
    
    <content type="html"><![CDATA[<h1 id="String-amp-StringBuilder"><a href="#String-amp-StringBuilder" class="headerlink" title="String&amp;StringBuilder"></a><code>String&amp;StringBuilder</code></h1><p><code>String</code>的底层数据结构是数组char value[]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br><span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;<br><span class="hljs-comment">/** The value is used for character storage. */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];<br><span class="hljs-comment">/** Cache the hash code for the string */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> hash; <span class="hljs-comment">// Default to 0</span><br><span class="hljs-comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">6849794470754667710L</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>String的类用于存放字符串的方法都用了final来修饰，也就是创建后均不可以被改变，当我们进行一个字符串相连的操作时，便会创建出新的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str_1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;ab&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">str_2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;ab&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">str_3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br><br><br>System.out.println(str_1 == str_2); <span class="hljs-comment">//false</span><br>System.out.println(str_1 == str_2.intern());<span class="hljs-comment">//false</span><br>System.out.println(str_1.intern() == str_2.intern());<span class="hljs-comment">//true</span><br>System.out.println(str_1 == str_3);<span class="hljs-comment">//false</span><br>System.out.println(str_1.intern() == str_3);<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>结论：</p><ol><li>&#x3D;&#x3D; ， 在引用类型中是对比的地址，比如str1和str2，两个new出来的对象置于堆内存中，地址肯定不同；但是如果是基础类型如str3，就是对比值；当然也有equal方法，这是对比的是哈希值</li><li>intern()，这是一个本地方法，底层由c++实现，它的作用是将值推进常量池</li><li><code>String str_3 = &quot;ab&quot;</code>这种赋值方法JVM做了优化，不会创建对象，直接将值放进常量池</li></ol><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a><code>StringBuilder</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//初始化，同样是数组</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-number">16</span>);<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">StringBuilder</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">super</span>(<span class="hljs-number">16</span>);<br>&#125;<br>AbstractStringBuilder(<span class="hljs-type">int</span> capacity) &#123;<br>value = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[capacity];<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//添加元素</span><br>stringBuilder.append(<span class="hljs-string">&quot;a&quot;</span>);<br><br><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title function_">append</span><span class="hljs-params">(String str)</span> &#123;<br><span class="hljs-keyword">if</span> (str == <span class="hljs-literal">null</span>)<br><span class="hljs-keyword">return</span> appendNull();<br><span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> str.length();<br>ensureCapacityInternal(count + len);<br>str.getChars(<span class="hljs-number">0</span>, len, value, count);<br>count += len;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minimumCapacity)</span> &#123;<br><span class="hljs-comment">// overflow-conscious code</span><br><span class="hljs-keyword">if</span> (minimumCapacity - value.length &gt; <span class="hljs-number">0</span>)<br>expandCapacity(minimumCapacity);<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">expandCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minimumCapacity)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> value.length * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (newCapacity - minimumCapacity &lt; <span class="hljs-number">0</span>) newCapacity = minimumCapacity;<br><span class="hljs-keyword">if</span> (newCapacity &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (minimumCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();<br>newCapacity = Integer.MAX_VALUE;<br>&#125;<br>value = Arrays.copyOf(value, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="对字符串的各种操作方法"><a href="#对字符串的各种操作方法" class="headerlink" title="对字符串的各种操作方法"></a>对字符串的各种操作方法</h1><p>字符串类</p><p>String：不可修改</p><p>当使用字符串的相加操作时，不会删掉原字符串，而是在常量池里面新建一个新的String，储存修改后的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">equals();<br><span class="hljs-comment">//boolean比较两个字符串是否相等</span><br>compareTo();<br><span class="hljs-comment">//基于每个字符进行Unicode值比较，若完全相等，返回0；小于参数，返回负数；大于参数，返回正数</span><br>contains();<br><span class="hljs-comment">//boolean若包含某个字符，返回true</span><br>indexOf();<br><span class="hljs-comment">//返回字符第一次出现的索引，未找到则返回-1、</span><br>startsWith(); endsWith();<br><span class="hljs-comment">//boolean测试字符串是否以参数为前缀开头;是否以参数为后缀结尾</span><br>replaceAll(String regex,String replacement);<br><span class="hljs-comment">//将字符串中的所有的regex替换为replacement</span><br>split(String regex);<br>String[] arr = str.split(<span class="hljs-string">&quot;,&quot;</span>);<br><span class="hljs-comment">//每个字符以regex分割并返回一个string型数组</span><br>substring();<br><span class="hljs-comment">//可以接收两个参数，返回这个索引截取的子串</span><br>trim();<br><span class="hljs-comment">//删除前置和后置的所有空格</span><br>toUpperCase();toLowerCase();<br><span class="hljs-comment">//大小写转换</span><br>join(<span class="hljs-string">&quot;mark&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">//为一系列字符串添加分割符并拼成一个新的字符串</span><br></code></pre></td></tr></table></figure><p>StringBuilder：可以修改，可以在常量池里原地修改字符串</p><p>StringBuffer：可以修改，且线程安全，基本与StringBuilder相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">append();<br><span class="hljs-comment">//字符串连接</span><br>toString();<br><span class="hljs-comment">//返回一个与构建器相同的String</span><br>setCharAt(<span class="hljs-type">int</span> i, <span class="hljs-type">char</span> c);<br><span class="hljs-comment">//把某个位置的字符置为C</span><br>insert(<span class="hljs-type">int</span> offset, String str/<span class="hljs-type">char</span> c);<br><span class="hljs-comment">//在指定位置之前插入字符串或字符</span><br>delete(<span class="hljs-type">int</span> startIndex,<span class="hljs-type">int</span> endIndex);<br><span class="hljs-comment">//删除指定范围内的字符串</span><br><br><br>deleteCharAt (<span class="hljs-type">int</span> index);<br><span class="hljs-comment">//删除某个字符</span><br>replace(<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end,String str);<br><span class="hljs-comment">//在指定范围内用str替换</span><br> reverse();<br><span class="hljs-comment">//字符串反转</span><br>substring(<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end);<br><span class="hljs-comment">//返回子串</span><br></code></pre></td></tr></table></figure><p>如何将ArrayList转换为数组？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>list.add(i);<br>&#125;<br><span class="hljs-comment">//toArray()会返回一个object数组，所以在对元素进行获取时需要进行类型转换</span><br>Object[] o = list.toArray();<br><span class="hljs-keyword">for</span> (Object value : o) &#123;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) value;<br>System.out.println(num);<br> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java数据结构</title>
    <link href="/post/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"/>
    <url>/post/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html</url>
    
    <content type="html"><![CDATA[<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a><code>ArrayList</code></h1><p><code>ArrayList</code>即数组列表，是基于数组实现的，这个数组可以插入任何元素，只不过这个数组是可以按需扩容，可以进行数据拷贝的</p><h2 id="ArrayList的构造"><a href="#ArrayList的构造" class="headerlink" title="ArrayList的构造"></a><code>ArrayList</code>的构造</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-comment">//默认初始化容量</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size; <br><span class="hljs-comment">//size指elementData中实际有多少元素</span><br><span class="hljs-keyword">transient</span> Object[] elementData;<br><span class="hljs-comment">//element.length指集合容量</span><br><span class="hljs-comment">//transient关键字只能修饰变量，不可修饰方法和类，该变量被序列化后将无法被访问</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> <span class="hljs-variable">modCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//记录对list操作的次数</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//无参构造</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>&#125;<br><span class="hljs-comment">//当使用无参构造时，给elementData数组赋值了一个空数组，这个空数组知道当无参构造时，第一次添加元素后如何扩容。构造时赋予空数组，而当第一次添加元素时，容量便会扩充到10</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//有参构造</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>        <span class="hljs-comment">//参数大于零且合法，便初始化一个数组便赋值给elementData</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//参数为零，便将空数组赋值给elementData</span><br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//参数不合法，提示错误</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                  initialCapacity);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用指定collection来构造</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>    elementData = c.toArray();<br>    <span class="hljs-comment">//将collection c转化为数组并赋值给elementData</span><br>    <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;、<br>        <span class="hljs-comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br>        <span class="hljs-keyword">if</span> (elementData.getClass() != Object[].class)<br>            <span class="hljs-comment">//若elementData的数组类型不是object，就做一次转换</span><br>        elementData = Arrays.copyOf(elementData, size, Object[].class);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// replace with empty array.</span><br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ArrayList的相关操作"><a href="#ArrayList的相关操作" class="headerlink" title="ArrayList的相关操作"></a><code>ArrayList</code>的相关操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//add 操作</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    <span class="hljs-comment">//对size进行自增操作，即成功添加新元素</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">//当使用无参构造时，添加一个元素时会将容量设置为默认10，并进行扩容</span><br>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);<br>    &#125;<br>    ensureExplicitCapacity(minCapacity);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">//确认是否需要扩容：即size+1是否会超出容量</span><br>    modCount++;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">//扩容，使用grow方法</span><br>        grow(minCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//grow操作，当添加元素发现容量不足或无参构造第一次添加元素时，需要扩容</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//将容量扩充至原大小的1.5倍，但是这个大小可能有大有小，所以需要if语句来进行判断</span><br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        newCapacity = minCapacity;<br>    <span class="hljs-comment">//扩容后的容量还是很小，不满足需要的容量，则直接将需要的容量赋值给newCapacity</span><br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">//扩容后的容量太大了，就改变扩容方式</span><br>        newCapacity = hugeCapacity(minCapacity);<br>    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>    <span class="hljs-comment">//将原数组的大小扩充至newCapacity</span><br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br><br><span class="hljs-comment">//当扩大1.5倍后超出了最大范围，那么就干脆将大小设为最大范围</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();<br>    <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?<br>        Integer.MAX_VALUE :<br>        MAX_ARRAY_SIZE;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_ARRAY_SIZE</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//remove操作</span><br><span class="hljs-comment">//输入索引</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">//检测这个元素是否处于数组的最后一个位置</span><br>    rangeCheck(index);<br>    modCount++;<br>    <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> elementData(index);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">//若index不在最后一位，则将index+1开始向后的所有元素向前移动一位，相当于删除了index位置的元素</span><br>        System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index, numMoved);<br>    <span class="hljs-comment">//将最后一位赋值为null</span><br>    elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br><span class="hljs-comment">//参数直接为指定元素</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>            <span class="hljs-keyword">if</span> (elementData[index] == <span class="hljs-literal">null</span>) &#123;<br>                fastRemove(index);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>            <span class="hljs-keyword">if</span> (o.equals(elementData[index])) &#123;<br>                fastRemove(index);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fastRemove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    modCount++;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>        System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,numMoved);<br>    elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//get操作</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    rangeCheck(index);<br>    <span class="hljs-keyword">return</span> elementData(index);<br>&#125;<br><span class="hljs-comment">//由于arraylist的底层基于数组，获取元素就很简单，直接调用数组访问即可</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//迭代器</span><br><span class="hljs-comment">//由上述源码可知，在进行remove的时候，size是时刻动态变化的，所以不能对arrayList进行for循环遍历来remove元素，这样容易造成结果不准确甚至数组下标越界</span><br><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Itr</span>();<br>&#125;<br><span class="hljs-comment">//当创建迭代器时 list.iterator();会直接返回一个Itr对象</span><br><br><br><span class="hljs-comment">//ArrayList的内部类Itr实现了Iterator接口，该类有三个方法</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;       <span class="hljs-comment">// index of next element to return，下一个要访问的元素</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">lastRet</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// index of last element returned; -1 if no such</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">expectedModCount</span> <span class="hljs-operator">=</span> modCount;<span class="hljs-comment">//代表对ArrayList修改次数的期望值，初始为modCount</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> cursor != size;<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//判断expectedModCount是否和modCount相等</span><br>        checkForComodification();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> cursor;<br>        <span class="hljs-comment">//判断是否越界</span><br>        <span class="hljs-keyword">if</span> (i &gt;= size)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>        Object[] elementData = ArrayList.<span class="hljs-built_in">this</span>.elementData;<br>        <span class="hljs-keyword">if</span> (i &gt;= elementData.length)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>        cursor = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];<span class="hljs-comment">//lastRet和cursor都自增1，并返回自增后的lastRet</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//</span><br>        <span class="hljs-keyword">if</span> (lastRet &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>        checkForComodification();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            ArrayList.<span class="hljs-built_in">this</span>.remove(lastRet);<br>            <span class="hljs-comment">//调用ArrayList的remove方法并将两个游标向前移动一位</span><br>            cursor = lastRet;<br>            lastRet = -<span class="hljs-number">1</span>;<br>            expectedModCount = modCount;<br>        &#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkForComodification</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//如果要对ArrayList进行遍历操作，就要使用迭代器，且在remove之前必须hasnext和next</span><br></code></pre></td></tr></table></figure><p>如何将ArrayList转换为普通数组？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Object[] o = list.toArray();<br></code></pre></td></tr></table></figure><h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a><code>LinkedList</code></h1><p><code>linkedlist</code>与<code>arraylist</code>不同，后者基于一个被维护的数组来实现动态调整大小，而前者则是一个双向链表</p><p>链表的优势：当插入和删除比较频繁的时候，链表相较于数组能有更高的效率(通常情况下，也有特殊情况，比如<code>arraylist</code>的中间插入效率就要高一些)，但是查找效率却不高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//内部类node的源码</span><br><span class="hljs-comment">//一个对象对应一个节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>       <span class="hljs-comment">//元素的引用</span><br>       <span class="hljs-comment">//如果为null,表示没有存储任何元素，如果不为null,表示存储了某种类型的元素</span><br>       E item;<br>       <span class="hljs-comment">//下一个节点的引用</span><br>       <span class="hljs-comment">//引用代表了对象的十六进制地址值,所以也可以注释为:下一个节点在内存中的地址</span><br>       <span class="hljs-comment">//如果为null,可能是空链表，也可能是尾节点</span><br>       Node&lt;E&gt; next;<br>       Node&lt;E&gt; prev;<br>       Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>          <span class="hljs-comment">//元素的引用初始化</span><br>          <span class="hljs-built_in">this</span>.item = element;<br>          <span class="hljs-comment">//上一个节点的引用初始化</span><br>          <span class="hljs-built_in">this</span>.next = next;<br>          <span class="hljs-comment">//下一个节点的引用初始化</span><br>          <span class="hljs-built_in">this</span>.prev = prev;<br>       &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//变量</span><br><span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//元素数量</span><br><span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br><span class="hljs-comment">//首节点的固定引用，必须先创建首节点，才能创建下一个节点</span><br><span class="hljs-keyword">transient</span> Node&lt;E&gt; first;<br><span class="hljs-comment">//尾节点的固定引用</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//头插</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">linkFirst</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">//再创建一个指针f指向首节点</span><br><span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-comment">//前指针为空，后指针指向f</span><br><span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(<span class="hljs-literal">null</span>, e, f);<br>    <span class="hljs-comment">//将first首指针指向newnode，代表newnode成为新的首元素</span><br>first = newNode;<br>    <span class="hljs-comment">//若f指向的元素为空，证明加入newnode前链表为空，那么newnode既是首元素，也是尾元素</span><br><span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>) last = newNode;<br>    <span class="hljs-comment">//若不为空，将前指针指向newnode，形成双向链表</span><br><span class="hljs-keyword">else</span> f.prev = newNode;<br>size++; modCount++;<br>&#125;<br><span class="hljs-comment">//linkedlist的头插效率非常高，因为arraylist的头插需要进行大量的移位，元素复制的操作，还可能需要进行扩容，而链表只需调整指针的指向即可</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//尾插</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">linkLast</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">//与头插大同小异</span><br><span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-comment">//最后一个节点的next为null</span><br><span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(l, e, <span class="hljs-literal">null</span>);<br>last = newNode;<br><span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>) first = newNode;<br><span class="hljs-keyword">else</span> l.next = newNode;<br>size++; modCount++;<br>&#125;<br><span class="hljs-comment">//出乎意料地是，linkedlist的尾插效率却比arraylist要低，因为arraylist无需进行移位拷贝操作，而linkedlist则需要创建对象，后者要耗时许多</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//中间插入</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>    <span class="hljs-comment">//输入索引和元素，检查索引范围是否合法</span><br>checkPositionIndex(index);<br>    <span class="hljs-comment">//若索引为size则进行尾插</span><br><span class="hljs-keyword">if</span> (index == size) linkLast(element);<br>    <span class="hljs-comment">//不是，则进行中间插入</span><br><span class="hljs-keyword">else</span> inkBefore(element, node(index));<br>&#125;<br>Node&lt;E&gt; <span class="hljs-title function_">node</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br><span class="hljs-comment">// assert isElementIndex(index);</span><br>    <span class="hljs-comment">//size&gt;&gt;1：size的一半，判断元素在左半区间，还是右半区间</span><br><span class="hljs-keyword">if</span> (index &lt; (size &gt;&gt; <span class="hljs-number">1</span>)) &#123;<br>        <span class="hljs-comment">//在左半区间，操纵first指针找到index元素</span><br>Node&lt;E&gt; x = first;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++)<br>x = x.next;<br><span class="hljs-keyword">return</span> x;&#125; <br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//在右半区间，操纵last指针找到index元素</span><br>Node&lt;E&gt; x = last;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size - <span class="hljs-number">1</span>; i &gt; index; i--)<br>x = x.prev;<br><span class="hljs-keyword">return</span> x;&#125;<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">linkBefore</span><span class="hljs-params">(E e, Node&lt;E&gt; succ)</span> &#123;<br><span class="hljs-comment">// assert succ != null;</span><br>    <span class="hljs-comment">//在index所指的元素之前插入新元素</span><br><span class="hljs-keyword">final</span> Node&lt;E&gt; pred = succ.prev;<br><span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(pred, e, succ);<br>succ.prev = newNode;<br><span class="hljs-keyword">if</span> (pred == <span class="hljs-literal">null</span>) first = newNode;<br><span class="hljs-keyword">else</span> pred.next = newNode;<br>size++; modCount++;<br>&#125;<br><span class="hljs-comment">//在数据量较大的时候，中间插入相比arrayList仍然会消耗较多的时间，所以CRUD效率不是绝对的可以分高下，需要根据应用场景和数据量等来综合考量</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//删除节点</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br><span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-literal">null</span>; x = x.next) &#123;<br><span class="hljs-keyword">if</span> (x.item == <span class="hljs-literal">null</span>) &#123;<br>unlink(x);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-literal">null</span>; x = x.next) &#123;<br>    <span class="hljs-keyword">if</span> (o.equals(x.item)) &#123;<br>unlink(x);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">//解链操作，即将这个元素从链表中移除</span><br>E <span class="hljs-title function_">unlink</span><span class="hljs-params">(Node&lt;E&gt; x)</span> &#123;<br><span class="hljs-comment">// assert x != null;</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">E</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> x.item;<br><span class="hljs-keyword">final</span> Node&lt;E&gt; next = x.next;<br><span class="hljs-keyword">final</span> Node&lt;E&gt; prev = x.prev;<br>    <span class="hljs-comment">//若上个结点为空，则直接将首指针指向next</span><br><span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) first = next; <br>    <span class="hljs-comment">//断掉x的prev指针</span><br>    <span class="hljs-keyword">else</span> &#123;prev.next = next;x.prev = <span class="hljs-literal">null</span>;&#125;<br>    <span class="hljs-comment">//若下一个结点为空，则直接将尾结点指向prev</span><br><span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>) last = prev;<br>    <span class="hljs-comment">//断掉x的next指针</span><br>    <span class="hljs-keyword">else</span> &#123;next.prev = prev;x.next = <span class="hljs-literal">null</span>;&#125;<br>x.item = <span class="hljs-literal">null</span>;<br>size--;<br>modCount++;<br><span class="hljs-keyword">return</span> element;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
