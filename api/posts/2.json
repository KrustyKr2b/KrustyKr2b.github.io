{"total":29,"pageSize":12,"pageCount":3,"data":[{"title":"MySQL","uid":"838ae74e3a76757d637de803a615bfd9","slug":"mySQL","date":"2022-10-25T14:02:31.000Z","updated":"2022-11-26T07:08:33.861Z","comments":true,"path":"api/articles/mySQL.json","cover":[],"text":"MySQL关系型数据库，插件式的存储引擎，这种架构可以根据业务的需求和实际需要选择合适的存储引擎。 客户端通过协议与服务器连接，发送查询语句，先检查缓存是否命中，若命中直接返回，否则进行语句解析 预处理，检查语句是否有语法错误，查询优化（是否会使用索引扫描），生成查询计划，启动查...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"14 mins."},"categories":[],"tags":[{"name":"数据库基础","slug":"数据库基础","count":2,"path":"api/tags/数据库基础.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"netty项目记录","uid":"cd132b199d60085bc82ceffbffeca6fd","slug":"netty项目记录——react线程模型简述","date":"2022-10-22T09:16:43.000Z","updated":"2022-11-15T12:38:14.159Z","comments":true,"path":"api/articles/netty项目记录——react线程模型简述.json","cover":null,"text":"如何编写并启动一个服务端？ public void run() throws Exception&#123; //指定bossGroup，也就是负责处理连接请求的线程 EventLoopGroup bossGroup = new NioEventLoopGroup(1); //指...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"netty","slug":"netty","count":3,"path":"api/tags/netty.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"netty基础","uid":"f81fcbbeae7dcf45a5335b1888cb075e","slug":"netty基础知识","date":"2022-10-22T08:35:26.000Z","updated":"2022-11-24T12:42:57.070Z","comments":true,"path":"api/articles/netty基础知识.json","cover":[],"text":"为什么我们不用Java NIO？原生的Java NIO编程，对编程能力要求比较高，需要处理连接异常、网络闪断、拆包粘包、网络拥塞、长短连接等各种各样的网络通讯细节问题，这是一件非常困难且耗时的事情。并且，原生Java NIO还有一个臭名昭著的Epoll Bug，它会导致Selec...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"netty","slug":"netty","count":3,"path":"api/tags/netty.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"进程，线程和协程详解","uid":"27f3741f94599209904dbbf8d63cd0fd","slug":"进程，线程，协程","date":"2022-10-20T08:53:01.000Z","updated":"2022-11-30T12:20:10.397Z","comments":true,"path":"api/articles/进程，线程，协程.json","cover":[],"text":"进程 an instance of a computer program that is being executed 进程是程序的一次执行，是一个程序及其数据，运行环境，在处理机上运行时所发生的活动。 与程序不同的是，进程具有动态性和生命周期，是系统进行资源分配和调度的独立单位...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":7,"path":"api/tags/Java基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"JUC","uid":"696c711dc425c21ecfe6691bc40887b7","slug":"JUC","date":"2022-10-20T06:09:39.000Z","updated":"2022-11-23T06:09:11.230Z","comments":true,"path":"api/articles/JUC.json","cover":[],"text":"JAVA创建线程的四种方式继承Thread类 定义thread类的子类，并重写run方法，该方法的方法体就是线程需要完成的任务，run方法也称为线程执行体。 创建Thread类的实例，也就是创建了线程对象 启动线程，即调用线程的start方法 实现Runnable接口 定义Run...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":7,"path":"api/tags/Java基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"字典序问题","uid":"db91e78c8da8e89de1c0960e4a35ed33","slug":"字典序问题","date":"2022-10-19T05:30:33.000Z","updated":"2022-10-19T06:21:05.815Z","comments":true,"path":"api/articles/字典序问题.json","cover":null,"text":"给你一个整数 n ，按字典序返回范围 [1, n] 内所有整数。 你必须设计一个时间复杂度为 O(n) 且使用 O(1) 额外空间的算法。 示例 1： 输入：n &#x3D; 13 输出：[1,10,11,12,13,2,3,4,5,6,7,8,9] 思路：字典序的构建可以看成是...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"LeetCode初见","slug":"LeetCode初见","count":10,"path":"api/tags/LeetCode初见.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"微软面试题——24点游戏","uid":"8420d36b5907c1ed250973ab1271d588","slug":"微软面试题——24点游戏","date":"2022-10-16T11:58:26.000Z","updated":"2022-10-16T12:04:42.945Z","comments":true,"path":"api/articles/微软面试题——24点游戏.json","cover":null,"text":"给定一个长度为4的整数数组 cards 。你有 4 张卡片，每张卡片上都包含一个范围在 [1,9] 的数字。您应该使用运算符 [&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;] 和括号 &#39;(&#39; 和 &#39;)...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"LeetCode初见","slug":"LeetCode初见","count":10,"path":"api/tags/LeetCode初见.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"周赛笔记10/16/2022","uid":"12f7852204c389ace8749b92fea05496","slug":"周赛笔记10-16-2022","date":"2022-10-16T08:06:31.000Z","updated":"2022-10-16T08:16:09.162Z","comments":true,"path":"api/articles/周赛笔记10-16-2022.json","cover":null,"text":"6204. 与对应负数同时存在的最大正整数给你一个 不包含 任何零的整数数组 nums ，找出自身与对应的负数都在数组中存在的最大正整数 k 输入：nums &#x3D; [-1,2,-3,3] 输出：3 解释：3 是数组中唯一一个满足题目要求的 k 。 一个HashSet+一遍...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"LeetCode初见","slug":"LeetCode初见","count":10,"path":"api/tags/LeetCode初见.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"子序列数目","uid":"22f311f06a9cae50742dc4cb95ef15a1","slug":"子序列数目","date":"2022-10-14T14:28:37.000Z","updated":"2022-10-14T14:34:26.115Z","comments":true,"path":"api/articles/子序列数目.json","cover":null,"text":"输入：s &#x3D; &quot;abc&quot; 输出：7 解释：7 个不同的子序列分别是 &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;ab&quot;, &quot;ac&quot;, &quot;bc&quot;...","link":"","photos":[],"count_time":{"symbolsCount":762,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"LeetCode初见","slug":"LeetCode初见","count":10,"path":"api/tags/LeetCode初见.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"周赛笔记10/9/2022","uid":"412f186990736c43d33166b6535da85e","slug":"周赛笔记10-9-2022","date":"2022-10-09T05:25:50.000Z","updated":"2022-10-13T05:40:02.677Z","comments":true,"path":"api/articles/周赛笔记10-9-2022.json","cover":null,"text":"2432. 处理用时最长的那个任务的员工输入：n &#x3D; 10, logs &#x3D; [[0,3],[2,5],[0,9],[1,15]] 输出：1 解释： 任务 0 于时刻 0 开始，且在时刻 3 结束，共计 3 个单位时间。 任务 1 于时刻 3 开始，且在时刻 5...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"LeetCode初见","slug":"LeetCode初见","count":10,"path":"api/tags/LeetCode初见.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"位运算技巧","uid":"bdd0b34d75b797c3e041acb9ccf9384c","slug":"位运算技巧","date":"2022-10-02T04:59:51.000Z","updated":"2022-10-13T13:40:14.411Z","comments":true,"path":"api/articles/位运算技巧.json","cover":null,"text":"//位运算算法技巧 //不用临时变量交换两个数 a ^= b; b ^= a; a ^= b; //判断是否异号（同号） boolean f = ((x ^ y) &lt; 0); //利用或操作 | 和空格将英文字符转换为小写 ('A' | ' ') = 'a'; //利用与操...","link":"","photos":[],"count_time":{"symbolsCount":346,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"算法归纳","slug":"算法归纳","count":2,"path":"api/tags/算法归纳.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"划分k个相等子集","uid":"8a33ad4dd9e973b50a7c9fd8c1c572f8","slug":"划分k个相等子集","date":"2022-09-27T13:57:25.000Z","updated":"2022-10-13T14:07:20.667Z","comments":true,"path":"api/articles/划分k个相等子集.json","cover":null,"text":"输入： nums &#x3D; [4, 3, 2, 3, 5, 2, 1], k &#x3D; 4 输出： True 说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和 桶问题：若可以划分为k个子集，则想象有k个桶，容量均为sum&#x2F;k，...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"LeetCode初见","slug":"LeetCode初见","count":10,"path":"api/tags/LeetCode初见.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}]}