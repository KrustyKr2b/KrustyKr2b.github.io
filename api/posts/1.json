{"total":27,"pageSize":12,"pageCount":3,"data":[{"title":"NIO select poll和epoll","uid":"2a1374b017f253762c103f23513f4420","slug":"NIO-select-poll和epoll","date":"2022-11-02T05:45:40.000Z","updated":"2022-11-03T11:49:56.794Z","comments":true,"path":"api/articles/NIO-select-poll和epoll.json","cover":[],"text":"用户空间和内核空间操作系统为了支持多个应用同时运行，需要保证不同进程之间相对独立，一个进程的崩溃不会影响其他进程，恶意进程不能读取其他进程的数据。于是内存空间被划分为两部分，内核空间和用户空间，内核空间的代码和数据拥有更高的权限，而用户空间的代码不能访问高级别的空间，因此保护了操...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"网络编程基础知识","slug":"网络编程基础知识","count":1,"path":"api/tags/网络编程基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"洪水淹没算法","uid":"52c15247d71045907737fa627f8aa035","slug":"洪水淹没算法","date":"2022-10-31T06:51:29.000Z","updated":"2022-10-31T11:10:18.126Z","comments":true,"path":"api/articles/洪水淹没算法.json","cover":[],"text":"695. 岛屿的最大面积 输入：grid &#x3D; [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0]...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"LeetCode初见","slug":"LeetCode初见","count":8,"path":"api/tags/LeetCode初见.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"计算机网络","uid":"293c17b4d2a4292133cc4d1ffd7f8725","slug":"计算机网络","date":"2022-10-31T06:51:13.000Z","updated":"2022-11-07T13:00:05.237Z","comments":true,"path":"api/articles/计算机网络.json","cover":[],"text":"计算机网络的分层模型OSI七层模型 应用层：计算机上的网络应用，传输应用报文，如HTTP，SMTP 表示层：用于处理交换信息的表示格式（处理语法和处理语义），格式变换，数据加密解密，数据压缩等功能 会话层：向表示层建立连接，并传输有序的数据，也就是建立同步SYN 运输层：负责两个...","link":"","photos":[],"count_time":{"symbolsCount":"9k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","count":1,"path":"api/tags/计算机基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"HashMap","uid":"a7e90bf30b292f0f6e0827bd156cab5e","slug":"HashMap","date":"2022-10-30T14:05:57.000Z","updated":"2022-11-07T12:35:33.722Z","comments":true,"path":"api/articles/HashMap.json","cover":null,"text":"HashCodeHashCode()，在未被重写前，即object类中，是一个Native方法，默认返回对象在堆中的地址，是一个独特值，可以看作是对象的身份ID 而在String类中，HashCode被重写 public int hashCode() &#123; int h =...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":12,"path":"api/tags/Java基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"买股票问题","uid":"6841591cdd97dd7e1d719dfd22576c72","slug":"买股票问题","date":"2022-10-30T13:19:55.000Z","updated":"2022-10-30T13:38:02.967Z","comments":true,"path":"api/articles/买股票问题.json","cover":null,"text":"121. 买卖股票的最佳时机你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。 输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"LeetCode初见","slug":"LeetCode初见","count":8,"path":"api/tags/LeetCode初见.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"每日一问10/30/2022","uid":"e4749bfd7c607c28b7704998d562cc90","slug":"每日一问10-30-2022","date":"2022-10-30T05:35:42.000Z","updated":"2022-10-31T06:17:07.497Z","comments":true,"path":"api/articles/每日一问10-30-2022.json","cover":null,"text":"Object类中有哪些方法答： equals()：未被重写前，由&#x3D;&#x3D;来实现，比较引用数据类型的引用地址是否相同 HashCode()：本地方法，未被重写前返回对象在堆上的唯一地址值，可以看作是对象的身份ID clone()：实现了cloneable接口才可以调...","link":"","photos":[],"count_time":{"symbolsCount":739,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":12,"path":"api/tags/Java基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"mySQL","uid":"de0127f4fce15732bd481675d6959d45","slug":"mySQL","date":"2022-10-25T14:02:31.000Z","updated":"2022-10-27T09:32:18.031Z","comments":true,"path":"api/articles/mySQL.json","cover":[],"text":"MYSQL关系型数据库，插件式的存储引擎，这种架构可以根据业务的需求和实际需要选择合适的存储引擎。 客户端通过协议与服务器连接，发送查询语句，先检查缓存是否命中，若命中直接返回，否则进行语句解析 预处理，检查语句是否有语法错误，查询优化（是否会使用索引扫描），生成查询计划，启动查...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"数据库基础","slug":"数据库基础","count":2,"path":"api/tags/数据库基础.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"netty——reactor线程模型简述","uid":"0bdbdbbdfc4f649a26dfdf23cf4f1d34","slug":"netty项目记录——react线程模型简述","date":"2022-10-22T09:16:43.000Z","updated":"2022-10-23T09:26:13.439Z","comments":true,"path":"api/articles/netty项目记录——react线程模型简述.json","cover":[],"text":"BIOBlock IO:同步阻塞IO，一般传统的JDK内置的Socket编程就是BIO。其底层流程是： 创建socket接口，号为x 使用bind函数将接口号与端口号进行绑定 进行listen监听事件或者是read读事件，且会一直阻塞在该命令，直到有客户端连接或者发送数据 缺点：...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"netty高并发项目","slug":"netty高并发项目","count":1,"path":"api/tags/netty高并发项目.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"进程，线程和协程","uid":"a81dd39014b037511fb6ceaf21738564","slug":"协程","date":"2022-10-20T08:53:01.000Z","updated":"2022-11-07T06:58:45.068Z","comments":true,"path":"api/articles/协程.json","cover":[],"text":"线程的Linux实现windows操作系统的内核提供了专门支持线程的机制，而在windows中，线程也被抽象为一种轻量级的进程 而在Linux中却不一样，从内核的角度来看，并没有线程这个概念，Linux把所有的线程都当作进程来处理，内核也并没有定义独特的调度算法和数据结构来实现线...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":12,"path":"api/tags/Java基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"synchronized,volatile与lock","uid":"2b0f61f6bf7b985f1f4587a53651bb18","slug":"synchronized-volatile与lock","date":"2022-10-20T06:09:39.000Z","updated":"2022-10-31T06:16:33.398Z","comments":true,"path":"api/articles/synchronized-volatile与lock.json","cover":[],"text":"Synchronized同步锁，保证在同一时刻，被修饰的代码块或方法只有一个线程执行，以达到并发安全的效果 同步锁是解决并发问题最简单的一种方法，直接给代码块加上此关键字即可 在JDK1.5之前，Synchronized是一个重量级锁，在以后的版本经过改进后成重量级减小 sync...","link":"","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":12,"path":"api/tags/Java基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"一篇关于锁的文章","uid":"a213144f9a961ec1d4584b73bef34320","slug":"一篇关于锁的文章","date":"2022-10-19T08:28:53.000Z","updated":"2022-10-31T06:17:36.262Z","comments":true,"path":"api/articles/一篇关于锁的文章.json","cover":[],"text":"面试官：解释一下什么是乐观锁，悲观锁，自旋锁，读写锁，排它锁，共享锁，统一锁，分段锁 这种问题虽然庞大复杂，但是千万不要被干沉默，能说清楚就是P5往上 按抽象概念分悲观锁悲观地认为数据大概率会被其他线程操作，所以具有强烈的独占性和排它性 比如synchronized，先加锁再执行...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":12,"path":"api/tags/Java基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"字典序问题","uid":"db91e78c8da8e89de1c0960e4a35ed33","slug":"字典序问题","date":"2022-10-19T05:30:33.000Z","updated":"2022-10-19T06:21:05.815Z","comments":true,"path":"api/articles/字典序问题.json","cover":null,"text":"给你一个整数 n ，按字典序返回范围 [1, n] 内所有整数。 你必须设计一个时间复杂度为 O(n) 且使用 O(1) 额外空间的算法。 示例 1： 输入：n &#x3D; 13 输出：[1,10,11,12,13,2,3,4,5,6,7,8,9] 思路：字典序的构建可以看成是...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"LeetCode初见","slug":"LeetCode初见","count":8,"path":"api/tags/LeetCode初见.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}]}