{"total":22,"pageSize":12,"pageCount":2,"data":[{"title":"Spring","uid":"946249c65165e1a3d66f50e0cb6e89e7","slug":"Spring","date":"2022-10-26T13:17:18.000Z","updated":"2022-10-26T13:17:44.333Z","comments":true,"path":"api/articles/Spring.json","cover":null,"text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"面试突击","slug":"面试突击","count":8,"path":"api/tags/面试突击.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"mySQL","uid":"de0127f4fce15732bd481675d6959d45","slug":"mySQL","date":"2022-10-25T14:02:31.000Z","updated":"2022-10-27T09:32:18.031Z","comments":true,"path":"api/articles/mySQL.json","cover":[],"text":"MYSQL关系型数据库，插件式的存储引擎，这种架构可以根据业务的需求和实际需要选择合适的存储引擎。 客户端通过协议与服务器连接，发送查询语句，先检查缓存是否命中，若命中直接返回，否则进行语句解析 预处理，检查语句是否有语法错误，查询优化（是否会使用索引扫描），生成查询计划，启动查...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"数据库基础","slug":"数据库基础","count":2,"path":"api/tags/数据库基础.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"netty——reactor线程模型简述","uid":"0bdbdbbdfc4f649a26dfdf23cf4f1d34","slug":"netty项目记录——react线程模型简述","date":"2022-10-22T09:16:43.000Z","updated":"2022-10-23T09:26:13.439Z","comments":true,"path":"api/articles/netty项目记录——react线程模型简述.json","cover":[],"text":"BIOBlock IO:同步阻塞IO，一般传统的JDK内置的Socket编程就是BIO。其底层流程是： 创建socket接口，号为x 使用bind函数将接口号与端口号进行绑定 进行listen监听事件或者是read读事件，且会一直阻塞在该命令，直到有客户端连接或者发送数据 缺点：...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"netty高并发项目","slug":"netty高并发项目","count":1,"path":"api/tags/netty高并发项目.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"线程和协程","uid":"911607c17b916d6cafeabb37f57539b9","slug":"协程","date":"2022-10-20T08:53:01.000Z","updated":"2022-10-25T14:00:01.012Z","comments":true,"path":"api/articles/协程.json","cover":[],"text":"一个程序开多少线程合适CPU密集型一个完整的请求，IO操作可以在很短的时间内完成，CPU的运算时间占大部分，线程等待时间接近0 单核CPU：一个CPU对应一个线程，且IO时间短，所以不适合使用多线程。若使用多线程，会造成线程竞争，造成不必要的浪费 多核：如果是多核CPU，就可以最...","link":"","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"面试突击","slug":"面试突击","count":8,"path":"api/tags/面试突击.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"synchronized,volatile与lock","uid":"2b0f61f6bf7b985f1f4587a53651bb18","slug":"synchronized-volatile与lock","date":"2022-10-20T06:09:39.000Z","updated":"2022-10-23T09:25:26.481Z","comments":true,"path":"api/articles/synchronized-volatile与lock.json","cover":[],"text":"Synchronized同步锁，保证在同一时刻，被修饰的代码块或方法只有一个线程执行，以达到并发安全的效果 同步锁是解决并发问题最简单的一种方法，直接给代码块加上此关键字即可 在JDK1.5之前，Synchronized是一个重量级锁，在以后的版本经过改进后成重量级减小 sync...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"面试突击","slug":"面试突击","count":8,"path":"api/tags/面试突击.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"一篇关于锁的文章","uid":"a213144f9a961ec1d4584b73bef34320","slug":"一篇关于锁的文章","date":"2022-10-19T08:28:53.000Z","updated":"2022-10-23T09:10:58.278Z","comments":true,"path":"api/articles/一篇关于锁的文章.json","cover":[],"text":"面试官：解释一下什么是乐观锁，悲观锁，自旋锁，读写锁，排它锁，共享锁，统一锁，分段锁 这种问题虽然庞大复杂，但是千万不要被干沉默，能说清楚就是P5往上 按抽象概念分悲观锁悲观地认为数据大概率会被其他线程操作，所以具有强烈的独占性和排它性 比如synchronized，先加锁再执行...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"面试突击","slug":"面试突击","count":8,"path":"api/tags/面试突击.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"字典序问题","uid":"db91e78c8da8e89de1c0960e4a35ed33","slug":"字典序问题","date":"2022-10-19T05:30:33.000Z","updated":"2022-10-19T06:21:05.815Z","comments":true,"path":"api/articles/字典序问题.json","cover":null,"text":"给你一个整数 n ，按字典序返回范围 [1, n] 内所有整数。 你必须设计一个时间复杂度为 O(n) 且使用 O(1) 额外空间的算法。 示例 1： 输入：n &#x3D; 13 输出：[1,10,11,12,13,2,3,4,5,6,7,8,9] 思路：字典序的构建可以看成是...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"LeetCode初见","slug":"LeetCode初见","count":6,"path":"api/tags/LeetCode初见.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"线程池","uid":"d1863bbf8aa3ec7bc32e4a0f3476163f","slug":"线程池","date":"2022-10-18T12:33:43.000Z","updated":"2022-10-20T09:20:51.227Z","comments":true,"path":"api/articles/线程池.json","cover":null,"text":"何为线程池：一种多线程的处理形式，处理过程中可以将任务添加到队列中，然后在创建线程后自动启动这些任务。 线程池的优势： 线程和任务分离，线程可被重用，提升复用性 控制线程并发数量，统一管理，降低服务器压力 提升系统响应速度，因为线程池内的线程可以被复用，且线程池内有核心线程待命，...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"面试突击","slug":"面试突击","count":8,"path":"api/tags/面试突击.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"每日一问10/17/2022","uid":"626084d3a58b4f97f22000ce81567720","slug":"每日一问10-17-2022","date":"2022-10-17T13:16:32.000Z","updated":"2022-10-18T14:02:21.366Z","comments":true,"path":"api/articles/每日一问10-17-2022.json","cover":[],"text":"Q1:String,StringBuilder,StringBuffer的区别答： String的底层是一个由final修饰的char型数组，String是静态只读的，当改变变量的值时，其实只是改变了引用对象的指向，指向了新创建的字符串，而原字符串仍存在于字符串常量池。 Stri...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"面试突击","slug":"面试突击","count":8,"path":"api/tags/面试突击.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"微软面试题——24点游戏","uid":"8420d36b5907c1ed250973ab1271d588","slug":"微软面试题——24点游戏","date":"2022-10-16T11:58:26.000Z","updated":"2022-10-16T12:04:42.945Z","comments":true,"path":"api/articles/微软面试题——24点游戏.json","cover":null,"text":"给定一个长度为4的整数数组 cards 。你有 4 张卡片，每张卡片上都包含一个范围在 [1,9] 的数字。您应该使用运算符 [&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;] 和括号 &#39;(&#39; 和 &#39;)...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"LeetCode初见","slug":"LeetCode初见","count":6,"path":"api/tags/LeetCode初见.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"周赛笔记10/16/2022","uid":"12f7852204c389ace8749b92fea05496","slug":"周赛笔记10-16-2022","date":"2022-10-16T08:06:31.000Z","updated":"2022-10-16T08:16:09.162Z","comments":true,"path":"api/articles/周赛笔记10-16-2022.json","cover":null,"text":"6204. 与对应负数同时存在的最大正整数给你一个 不包含 任何零的整数数组 nums ，找出自身与对应的负数都在数组中存在的最大正整数 k 输入：nums &#x3D; [-1,2,-3,3] 输出：3 解释：3 是数组中唯一一个满足题目要求的 k 。 一个HashSet+一遍...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"LeetCode初见","slug":"LeetCode初见","count":6,"path":"api/tags/LeetCode初见.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"子序列数目","uid":"22f311f06a9cae50742dc4cb95ef15a1","slug":"子序列数目","date":"2022-10-14T14:28:37.000Z","updated":"2022-10-14T14:34:26.115Z","comments":true,"path":"api/articles/子序列数目.json","cover":null,"text":"输入：s &#x3D; &quot;abc&quot; 输出：7 解释：7 个不同的子序列分别是 &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;ab&quot;, &quot;ac&quot;, &quot;bc&quot;...","link":"","photos":[],"count_time":{"symbolsCount":762,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"LeetCode初见","slug":"LeetCode初见","count":6,"path":"api/tags/LeetCode初见.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}]}