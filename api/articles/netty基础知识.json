{"title":"netty基础","uid":"f81fcbbeae7dcf45a5335b1888cb075e","slug":"netty基础知识","date":"2022-10-22T08:35:26.000Z","updated":"2022-11-23T06:15:28.673Z","comments":true,"path":"api/articles/netty基础知识.json","keywords":null,"cover":[],"content":"<h2 id=\"Netty和Tomcat有什么区别？\"><a href=\"#Netty和Tomcat有什么区别？\" class=\"headerlink\" title=\"Netty和Tomcat有什么区别？\"></a><em><strong>Netty和Tomcat有什么区别？</strong></em></h2><p>Netty是一个基于NIO的异步网络通信框架，性能高，<strong>封装了原生NIO</strong>，降低了编码复杂度。</p>\n<p>Tomcat是一个Web服务器，是一个Servlet容器，内部只运行Servlet程序并处理HTTP请求。</p>\n<p>Netty封装的是IO模型，用于处理网络数据的传输，不关心具体的协议，其定制性更高</p>\n<h1 id=\"reactor线程模型\"><a href=\"#reactor线程模型\" class=\"headerlink\" title=\"reactor线程模型\"></a>reactor线程模型</h1><p>reactor就是IO多路复用（NIO）+线程池的结合优化版</p>\n<p>reactor线程模型：主要有四个角色</p>\n<ol>\n<li>Reactor：把IO事件分配给对应的handler处理，就是IO多路复用的select实现，即轮询监听</li>\n<li>Acceptor：处理客户端连接事件，创建Handler对象</li>\n<li>Handler：将自身与事件绑定，执行非阻塞读、写任务，负责channel的读入，业务处理完成后，负责将结果写出channel</li>\n<li>worker：用来处理handler传来的业务的线程</li>\n</ol>\n<p>其中1，2，3存放于主线程中，也称为bossGroup</p>\n<p>4存放于从线程，也就是线程池中，也称为workerGroup</p>\n<h2 id=\"单reactor-多线程\"><a href=\"#单reactor-多线程\" class=\"headerlink\" title=\"单reactor-多线程\"></a>单reactor-多线程</h2><p><img src=\"/../img/reactor3.png\" alt=\"reactor3\"></p>\n<h2 id=\"主从reactor-多线程\"><a href=\"#主从reactor-多线程\" class=\"headerlink\" title=\"主从reactor-多线程\"></a>主从reactor-多线程</h2><p>这种模型下是把Reactor线程拆分了mainReactor和subReactor两个部分</p>\n<p>mainReactor只处理连接事件，读写事件交给subReactor来处理。业务逻辑还是由线程池来处理</p>\n<p><img src=\"/../img/reactor4.png\" alt=\"reactor4\"></p>\n<h2 id=\"什么是零拷贝\"><a href=\"#什么是零拷贝\" class=\"headerlink\" title=\"什么是零拷贝\"></a><em><strong>什么是零拷贝</strong></em></h2><p>应用程序把内核中的一块数据转移到内核中的另一个区域去时，不需要经过先复制到用户空间，再转移到目标内核区域，而是实现直接转移，系统调用transferTo()</p>\n<h3 id=\"Netty的线程模型是怎么样的\"><a href=\"#Netty的线程模型是怎么样的\" class=\"headerlink\" title=\"Netty的线程模型是怎么样的\"></a><em><strong>Netty的线程模型是怎么样的</strong></em></h3><p>Netty同时支持Reactor单线程模型，多线程模型，主从多线程模型，用户可以配置参数在这三种模型之间切换</p>\n<p>服务端启动时，通常会创建两个NioEventLoopGroup实例，对应两个独立的Reactor线程池，bossGroup负责处理客户端的连接请求，workerGroup负责处理IO相关的操作，执行任务等。用户可以根据ServerBootstrap启动类选择参数配置线程模型。</p>\n<h3 id=\"Netty为什么高性能？\"><a href=\"#Netty为什么高性能？\" class=\"headerlink\" title=\"Netty为什么高性能？\"></a><em><strong>Netty为什么高性能？</strong></em></h3><ol>\n<li>NIO模型，用最少的资源完成最多的任务</li>\n<li>内存零拷贝，减少不必要的拷贝造成资源浪费，实现更高效率的传输</li>\n<li>串行化处理读写：消息的处理尽可能在同一个线程内完成，避免切换线程的花销，避免多线程竞争和同步锁。调整NIO线程池的线程参数，可以同时启动多个串行化的线程，相比于多线程竞争机制性能更优。</li>\n<li>支持protobuf：<code>protobuf</code> (protocol buffer) 是谷歌内部的混合语言数据标准。通过将结构化的数据进行序列化(串行化)，用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。是一个高性能的编解码框架，序列化数据后数据更小，传输速度更快，安全性也更高，netty可以直接在handler内添加protobuf编码解码器。</li>\n<li>内存池设计，申请的内存可以重用</li>\n</ol>\n<h2 id=\"粘包\"><a href=\"#粘包\" class=\"headerlink\" title=\"粘包\"></a>粘包</h2><p>现象：发送abc和def，结果接收到abcdef</p>\n<p>原因：</p>\n<ol>\n<li>应用层：接收方的bytebuf设置太大（默认1024）</li>\n<li>TCP滑动窗口足够大，且接收方处理不及时</li>\n<li>TCP的Nagle算法：为了减少广域网的小分组数目，从而减小网络拥塞的出现，会造成粘包。</li>\n</ol>\n<p>netty的解决方案：</p>\n<ol>\n<li>短连接，发完一次消息后便断开连接。下一次发消息的时候再次建立连接，重置了缓冲区</li>\n<li>设置合理的缓冲区</li>\n</ol>\n<h2 id=\"半包\"><a href=\"#半包\" class=\"headerlink\" title=\"半包\"></a>半包</h2><p>现象：发送abcdef接收到abc和def</p>\n<p>原因：</p>\n<ol>\n<li>应用层：bytebuf过小</li>\n<li>TCP滑动窗口过小</li>\n<li>链路层：MSS限制</li>\n</ol>\n<p>netty解决方案</p>\n<p><code>FixedLengthFrameDecoder</code>定长帧解码器：固定收到的帧的大小，若收到半包，则延迟交付，直到收到其他消息满足大小，再交付</p>\n<p><code>LineBasedFrameDecoder</code>行帧解码器：根据特定字符来区分完整的信息，避免半包</p>\n<p><code>LengthFiledBasedFrameDecoder</code> ：指定内容长度，偏移量，从第几个字节开始读，跳过几个字节再读，从而精准读取内容避免半包</p>\n<h1 id=\"MpscQueue\"><a href=\"#MpscQueue\" class=\"headerlink\" title=\"MpscQueue\"></a>MpscQueue</h1><p>Mpsc来自JCTools，即JAVA的高并发增强包，主要提供了一些 JDK 缺失的并发数据结构</p>\n<ol>\n<li>Spsc 单生产者单消费者</li>\n<li>Mpsc 多生产者单消费者</li>\n<li>Spmc 单生产者多消费者</li>\n<li>Mpmc 多生产者多消费者</li>\n</ol>\n<p>Mpsc 的全称是 Multi Producer Single Consumer，多生产者单消费者。</p>\n<p>Mpsc Queue 可以保证多个生产者同时访问队列是线程安全的，而且同一时刻只允许一个消费者从队列中读取数据。</p>\n<p><strong>Netty Reactor 线程中的任务队列 taskQueue 必须满足多个生产者可以同时提交任务，所以 JCTools 提供的 Mpsc Queue 非常适合 Netty Reactor 线程模型</strong></p>\n<h2 id=\"MpscArrayQueue为例\"><a href=\"#MpscArrayQueue为例\" class=\"headerlink\" title=\"MpscArrayQueue为例\"></a><strong>MpscArrayQueue为例</strong></h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//继承类的所有变量声明</span>\n<span class=\"token comment\">// ConcurrentCircularArrayQueueL0Pad.java</span>\n<span class=\"token keyword\">long</span> p01<span class=\"token punctuation\">,</span> p02<span class=\"token punctuation\">,</span> p03<span class=\"token punctuation\">,</span> p04<span class=\"token punctuation\">,</span> p05<span class=\"token punctuation\">,</span> p06<span class=\"token punctuation\">,</span> p07<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">long</span> p10<span class=\"token punctuation\">,</span> p11<span class=\"token punctuation\">,</span> p12<span class=\"token punctuation\">,</span> p13<span class=\"token punctuation\">,</span> p14<span class=\"token punctuation\">,</span> p15<span class=\"token punctuation\">,</span> p16<span class=\"token punctuation\">,</span> p17<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// ConcurrentCircularArrayQueue.java</span>\n<span class=\"token comment\">// 计算数组下标的掩码</span>\n<span class=\"token keyword\">protected</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span> mask<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 存放队列数据的数组</span>\n<span class=\"token keyword\">protected</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">E</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> buffer<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// MpmcArrayQueueL1Pad.java</span>\n<span class=\"token keyword\">long</span> p00<span class=\"token punctuation\">,</span> p01<span class=\"token punctuation\">,</span> p02<span class=\"token punctuation\">,</span> p03<span class=\"token punctuation\">,</span> p04<span class=\"token punctuation\">,</span> p05<span class=\"token punctuation\">,</span> p06<span class=\"token punctuation\">,</span> p07<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">long</span> p10<span class=\"token punctuation\">,</span> p11<span class=\"token punctuation\">,</span> p12<span class=\"token punctuation\">,</span> p13<span class=\"token punctuation\">,</span> p14<span class=\"token punctuation\">,</span> p15<span class=\"token punctuation\">,</span> p16<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// MpmcArrayQueueProducerIndexField.java</span>\n<span class=\"token comment\">// 生产者索引</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">long</span> producerIndex<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// MpscArrayQueueMidPad.java</span>\n<span class=\"token keyword\">long</span> p01<span class=\"token punctuation\">,</span> p02<span class=\"token punctuation\">,</span> p03<span class=\"token punctuation\">,</span> p04<span class=\"token punctuation\">,</span> p05<span class=\"token punctuation\">,</span> p06<span class=\"token punctuation\">,</span> p07<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">long</span> p10<span class=\"token punctuation\">,</span> p11<span class=\"token punctuation\">,</span> p12<span class=\"token punctuation\">,</span> p13<span class=\"token punctuation\">,</span> p14<span class=\"token punctuation\">,</span> p15<span class=\"token punctuation\">,</span> p16<span class=\"token punctuation\">,</span> p17<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// MpscArrayQueueProducerLimitField.java</span>\n<span class=\"token comment\">// 生产者索引的最大值</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">long</span> producerLimit<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// MpscArrayQueueL2Pad.java</span>\n<span class=\"token keyword\">long</span> p00<span class=\"token punctuation\">,</span> p01<span class=\"token punctuation\">,</span> p02<span class=\"token punctuation\">,</span> p03<span class=\"token punctuation\">,</span> p04<span class=\"token punctuation\">,</span> p05<span class=\"token punctuation\">,</span> p06<span class=\"token punctuation\">,</span> p07<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">long</span> p10<span class=\"token punctuation\">,</span> p11<span class=\"token punctuation\">,</span> p12<span class=\"token punctuation\">,</span> p13<span class=\"token punctuation\">,</span> p14<span class=\"token punctuation\">,</span> p15<span class=\"token punctuation\">,</span> p16<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// MpscArrayQueueConsumerIndexField.java</span>\n<span class=\"token comment\">// 消费者索引</span>\n<span class=\"token keyword\">protected</span> <span class=\"token keyword\">long</span> consumerIndex<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// MpscArrayQueueL3Pad.java</span>\n<span class=\"token keyword\">long</span> p01<span class=\"token punctuation\">,</span> p02<span class=\"token punctuation\">,</span> p03<span class=\"token punctuation\">,</span> p04<span class=\"token punctuation\">,</span> p05<span class=\"token punctuation\">,</span> p06<span class=\"token punctuation\">,</span> p07<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">long</span> p10<span class=\"token punctuation\">,</span> p11<span class=\"token punctuation\">,</span> p12<span class=\"token punctuation\">,</span> p13<span class=\"token punctuation\">,</span> p14<span class=\"token punctuation\">,</span> p15<span class=\"token punctuation\">,</span> p16<span class=\"token punctuation\">,</span> p17<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在pad类中填充了大量long的数据，其命名没有什么特殊的含义，只是起到填充的作用，这是为了解决<strong>伪共享（false sharing）</strong>问题</p>\n<h2 id=\"伪共享问题\"><a href=\"#伪共享问题\" class=\"headerlink\" title=\"伪共享问题\"></a>伪共享问题</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>你的行为似乎有利于共享，但是却徒增消耗</p></blockquote>\n<p>为了平衡CPU与内存的速度差异，常常会设立多层缓存机制，一般是三层，CPU 读取数据时，首先会从 L1 查找，如果未命中则继续查找 L2，如果还未能命中则继续查找 L3，最后还没命中的话只能从内存中查找，读取完成后再将数据逐级放入缓存中。</p>\n<p>此外，多线程之间共享一份数据的时候，需要其中一个线程将数据写回主存（总线嗅探机制保证可见性），其他线程访问主存数据。</p>\n<p>CPU 缓存由若干个缓存行（Cache Line） 组成，<strong>缓存行是 CPU 缓存可操作的最小单位</strong>。</p>\n<p>Cache Line 的大小与 CPU 架构有关，在目前主流的 64 位架构下，Cache Line 的大小通常为 64 Byte。</p>\n<p>而 Java 中一个 long 类型是 8 Byte，所以一个 Cache Line 可以存储 <strong>8 个 long 类型变量</strong>。</p>\n<p>CPU 在加载内存数据时，会将相邻的数据一同读取到 Cache Line 中（一次加载连续的 64 个字节），这样就可以避免 CPU 频繁与内存进行交互了。</p>\n<p>例如：如果访问一个 long 型的单独变量 a，并且还有另外一个 long 型变量 b 紧挨着它，那么当加载 a 时候将免费加载 b</p>\n<p>伪共享就会在此出现：</p>\n<ol>\n<li>假设有 A、B、C、D 四个变量，线程1尝试修改变量A，于是将A和B、C、D一起都加载到了core1的一个 Cache Line；</li>\n<li>此时，线程2读取变量B，也将A、C、D加载到了core2的同一 Cache Line；</li>\n<li>线程1 对变量 A 进行修改，修改完成后将变量A值写回主存，然后 <strong>CPU1 会通知 CPU2 该缓存行已经失效</strong>；</li>\n<li>线程 2 在Core2 中对变量 C 进行修改时，发现 Cache line 已经失效，所以需要重新从主存中读取数据加载到当前 Cache line 中。</li>\n</ol>\n<p><strong>当多个线程同时修改互相独立的变量时，如果这些变量共享同一个缓存行，就会出现写竞争，导致频繁从主存加载数据，影响性能</strong>。</p>\n<img src=\"../img/JCtool.png\" alt=\"JCtool\" style=\"zoom: 67%;\" />\n\n<p>常见的解决思路就是：<strong>以空间换时间，让不同线程操作的不相干变量加载到不同缓存行，避免相互影响</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">FalseSharingPadding</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">long</span> p1<span class=\"token punctuation\">,</span> p2<span class=\"token punctuation\">,</span> p3<span class=\"token punctuation\">,</span> p4<span class=\"token punctuation\">,</span> p5<span class=\"token punctuation\">,</span> p6<span class=\"token punctuation\">,</span> p7<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">long</span> value <span class=\"token operator\">=</span> <span class=\"token number\">0L</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">long</span> p9<span class=\"token punctuation\">,</span> p10<span class=\"token punctuation\">,</span> p11<span class=\"token punctuation\">,</span> p12<span class=\"token punctuation\">,</span> p13<span class=\"token punctuation\">,</span> p14<span class=\"token punctuation\">,</span> p15<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>变量 value 前后分别填充了 7 个 long 类型的变量。</p>\n<p>这样不论在什么情况下，都可以保证在多线程访问 value 变量时，value 与其他不相关的变量处于不同的 Cache Line</p>\n<h2 id=\"MPSC方法解析\"><a href=\"#MPSC方法解析\" class=\"headerlink\" title=\"MPSC方法解析\"></a>MPSC方法解析</h2><h3 id=\"加入元素\"><a href=\"#加入元素\" class=\"headerlink\" title=\"加入元素\"></a>加入元素</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// MpscArrayQueue.java</span>\n<span class=\"token comment\">//生产者加入元素</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">offer</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> <span class=\"token class-name\">E</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span> <span class=\"token operator\">==</span> e<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NullPointerException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span> mask <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>mask<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 获取生产者索引最大限制</span>\n    <span class=\"token keyword\">long</span> producerLimit <span class=\"token operator\">=</span> <span class=\"token function\">lvProducerLimit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">long</span> pIndex<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">do</span>\n    <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// 获取生产者索引</span>\n        pIndex <span class=\"token operator\">=</span> <span class=\"token function\">lvProducerIndex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 如果生产者索引达到了最大值，防止追尾</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pIndex <span class=\"token operator\">>=</span> producerLimit<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">// 消费者索引，以volatile的形式获取，保证获取的是最新的值</span>\n            <span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span> cIndex <span class=\"token operator\">=</span> <span class=\"token function\">lvConsumerIndex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">// 修改为当前消费者的索引加上数组的大小</span>\n            producerLimit <span class=\"token operator\">=</span> cIndex <span class=\"token operator\">+</span> mask <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token comment\">// 如果依然达到了最大值，则返回false，表示队列满了，再放元素就追尾了</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pIndex <span class=\"token operator\">>=</span> producerLimit<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 队列已满</span>\n            <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token keyword\">else</span>\n            <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token function\">soProducerLimit</span><span class=\"token punctuation\">(</span>producerLimit<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        <span class=\"token comment\">// 更新 producerLimit</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">casProducerIndex</span><span class=\"token punctuation\">(</span>pIndex<span class=\"token punctuation\">,</span> pIndex <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// CAS 更新生产者索引，更新成功则退出，说明当前生产者已经占领索引值</span>\n    <span class=\"token comment\">// 计算生产者索引在数组中下标</span>\n    <span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span> offset <span class=\"token operator\">=</span> <span class=\"token function\">calcCircularRefElementOffset</span><span class=\"token punctuation\">(</span>pIndex<span class=\"token punctuation\">,</span> mask<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 向数组中放入数据</span>\n    <span class=\"token function\">soRefElement</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">,</span> offset<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//获取生产者索引最大值和修改生产者索引最大值</span>\n  <span class=\"token comment\">// 读取producerLimit</span>\n<span class=\"token keyword\">protected</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span> <span class=\"token function\">lvProducerLimit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// producerLimit本身就是volatile修饰的</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>producerLimit<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token comment\">// 保存producerLimit</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">void</span> <span class=\"token function\">soProducerLimit</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// 这个方法会加StoreStore屏障</span>\n        <span class=\"token comment\">// 会把最新值直接更新到主内存中，但其它线程不会立即可见</span>\n        <span class=\"token comment\">// 其它线程需要使用volatile语义才能读取到最新值</span>\n        <span class=\"token comment\">// 这相当于是一种延时更新的方法，比volatile语义的性能要高一些</span>\n        <span class=\"token class-name\">UnsafeAccess</span><span class=\"token punctuation\">.</span><span class=\"token constant\">UNSAFE</span><span class=\"token punctuation\">.</span><span class=\"token function\">putOrderedLong</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">P_LIMIT_OFFSET</span><span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//获取生产者索引，更新生产者索引</span>\n <span class=\"token comment\">// 读取producerIndex</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span> <span class=\"token function\">lvProducerIndex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// producerIndex本身就用volatile修饰了</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>producerIndex<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n \n    <span class=\"token comment\">// CAS更新producerIndex</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">casProducerIndex</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> expect<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> newValue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// CAS更新</span>\n        <span class=\"token keyword\">return</span> <span class=\"token class-name\">UnsafeAccess</span><span class=\"token punctuation\">.</span><span class=\"token constant\">UNSAFE</span><span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSwapLong</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">P_INDEX_OFFSET</span><span class=\"token punctuation\">,</span> expect<span class=\"token punctuation\">,</span> newValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 读取consumerIndex</span>\n  <span class=\"token keyword\">protected</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span> <span class=\"token function\">lvConsumerIndex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token comment\">// 以volatile的形式加载consumerIndex</span>\n      <span class=\"token comment\">// 此时会从内存读取最新的值</span>\n      <span class=\"token keyword\">return</span> <span class=\"token class-name\">UnsafeAccess</span><span class=\"token punctuation\">.</span><span class=\"token constant\">UNSAFE</span><span class=\"token punctuation\">.</span><span class=\"token function\">getLongVolatile</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">C_INDEX_OFFSET</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 修改数组对应偏移量的值</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> <span class=\"token keyword\">void</span> <span class=\"token function\">soElement</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> buffer<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> offset<span class=\"token punctuation\">,</span> <span class=\"token class-name\">E</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// 比使用下标更新数组元素有两个优势</span>\n        <span class=\"token comment\">// 1. 使用Unsafe操作内存更新更快</span>\n        <span class=\"token comment\">// 2. 使用putOrderedObject会直接更新到主内存，而使用下标不会立马更新到主内存</span>\n        <span class=\"token class-name\">UnsafeAccess</span><span class=\"token punctuation\">.</span><span class=\"token constant\">UNSAFE</span><span class=\"token punctuation\">.</span><span class=\"token function\">putOrderedObject</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">,</span> offset<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"/../img/MPSC.png\" alt=\"MPSC\"></p>\n<ol>\n<li>初始时，两个线程拿到的 <code>pIndex</code> 都等于producerIndex为0，小于 producerLimit ；</li>\n<li>接着，两个线程都会尝试 CAS 更新 producerIndex + 1 ，必然只有一个线程能更新成功，另一个失败；</li>\n<li>假设 Thread1 CAS 操作成功，那么它拿到的 <code>pIndex</code> 为0，Thread2 失败后就会重新更新 producerIndex ，然后更新成功，拿到 <code>pIndex</code> 为1；</li>\n<li>最后，根据 <code>pIndex</code> 进行位运算，得到数组对应的下标，然后通过 <code>UNSAFE.putOrderedObject()</code> 方法将数据写入到数组中。</li>\n</ol>\n<h3 id=\"获取元素\"><a href=\"#获取元素\" class=\"headerlink\" title=\"获取元素\"></a>获取元素</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//无CAS</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">E</span> <span class=\"token function\">poll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// 读取consumerIndex的值</span>\n        <span class=\"token keyword\">long</span> cIndex <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">lpConsumerIndex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 计算在数组中的偏移量</span>\n        <span class=\"token keyword\">long</span> offset <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">calcElementOffset</span><span class=\"token punctuation\">(</span>cIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 获取存储元素的数组</span>\n        <span class=\"token class-name\">E</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> buffer <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>buffer<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 取元素，通过StoreStore写入队列，通过LoadLoad取出来的元素是最新值</span>\n        <span class=\"token class-name\">E</span> e <span class=\"token operator\">=</span> <span class=\"token class-name\">UnsafeRefArrayAccess</span><span class=\"token punctuation\">.</span><span class=\"token function\">lvElement</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">,</span> offset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span> <span class=\"token operator\">==</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">// 元素入队是先更新了producerIndex的值，再把更新元素到数组中</span>\n            <span class=\"token comment\">// 如果在两者之间，进行了消费，则此处是无法获取到元素的</span>\n            <span class=\"token comment\">// 所以需要进入下面的判断</span>\n            <span class=\"token comment\">// 判断consumerIndex是否等于producerIndex</span>\n            <span class=\"token comment\">// 只有两者不相等，才可以再消费元素</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cIndex <span class=\"token operator\">==</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">lvProducerIndex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token comment\">// 使用死循环来取元素，直到取到为止</span>\n            <span class=\"token keyword\">do</span> <span class=\"token punctuation\">&#123;</span>\n                e <span class=\"token operator\">=</span> <span class=\"token class-name\">UnsafeRefArrayAccess</span><span class=\"token punctuation\">.</span><span class=\"token function\">lvElement</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">,</span> offset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">// 更新取出的位置元素为null</span>\n        <span class=\"token class-name\">UnsafeRefArrayAccess</span><span class=\"token punctuation\">.</span><span class=\"token function\">spElement</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">,</span> offset<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span><span class=\"token punctuation\">)</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 修改consumerIndex的索引为新值，使用StoreStore屏障，直接更新到主内存</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">soConsumerIndex</span><span class=\"token punctuation\">(</span>cIndex <span class=\"token operator\">+</span> <span class=\"token number\">1L</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 返回出队的元素</span>\n        <span class=\"token keyword\">return</span> e<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>因为只有一个消费者线程，所以整个 poll() 的过程没有 CAS 操作。</p>\n<p>poll() 方法核心思路是获取消费者索引 consumerIndex，然后根据 consumerIndex 计算得出数组对应的偏移量，然后将数组对应位置的元素取出并返回，最后将 consumerIndex 移动到环形数组下一个位置。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">protected</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span> <span class=\"token function\">lpConsumerIndex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n       <span class=\"token comment\">// 直接返回消费者索引</span>\n       <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>consumerIndex<span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">&#125;</span>\n   <span class=\"token comment\">// 保存消费者索引值</span>\n   <span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">soConsumerIndex</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> l<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n       <span class=\"token comment\">// 这个方法会加StoreStore屏障</span>\n       <span class=\"token comment\">// 会把最新值直接更新到主内存中，但其它线程不会立即可见</span>\n       <span class=\"token comment\">// 其它线程需要使用volatile语义才能读取到最新值</span>\n       <span class=\"token comment\">// 这相当于是一种延时更新的方法，比volatile语义的性能要高一些</span>\n       <span class=\"token class-name\">UnsafeAccess</span><span class=\"token punctuation\">.</span><span class=\"token constant\">UNSAFE</span><span class=\"token punctuation\">.</span><span class=\"token function\">putOrderedLong</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">C_INDEX_OFFSET</span><span class=\"token punctuation\">,</span> l<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> <span class=\"token keyword\">void</span> <span class=\"token function\">spElement</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> buffer<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> offset<span class=\"token punctuation\">,</span> <span class=\"token class-name\">E</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// 更新buffer在offset处的元素值</span>\n        <span class=\"token class-name\">UnsafeAccess</span><span class=\"token punctuation\">.</span><span class=\"token constant\">UNSAFE</span><span class=\"token punctuation\">.</span><span class=\"token function\">putObject</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">,</span> offset<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n \n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">E</span> <span class=\"token function\">lvElement</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> buffer<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> offset<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// 获取buffer在offset处的元素值</span>\n        <span class=\"token keyword\">return</span> <span class=\"token class-name\">UnsafeAccess</span><span class=\"token punctuation\">.</span><span class=\"token constant\">UNSAFE</span><span class=\"token punctuation\">.</span><span class=\"token function\">getObjectVolatile</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">,</span> offset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//计算偏移量</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">long</span> <span class=\"token function\">calcElementOffset</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> index<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> mask<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// REF_ARRAY_BASE，基础地址，数组在内存中的地址</span>\n        <span class=\"token comment\">// REF_ELEMENT_SHIFT，可以简单地看作一个元素占用多少字节</span>\n        <span class=\"token comment\">// 64位系统中一个引用对象占用64位，也就是8字节，但是压缩模式下占用4字节</span>\n        <span class=\"token comment\">// index &amp; mask 计算数组下标</span>\n        <span class=\"token comment\">// 比如数组大小为4，mask就为3时，4&amp;3=100&amp;011=0</span>\n        <span class=\"token keyword\">return</span> <span class=\"token constant\">REF_ARRAY_BASE</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>index <span class=\"token operator\">&amp;</span> mask<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token constant\">REF_ELEMENT_SHIFT</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ol>\n<li>Unsafe 方法<ol>\n<li>**putOrderedXxx()**，使用 StoreStore 屏障，会把最新值更新到主内存，但不会立即失效其它缓存行中的数据，是一种延时更新机制；</li>\n<li>**putXxxVolatile()**，使用 StoreLoad 屏障，会把最新值更新到主内存，同时会把其它缓存行的数据失效，或者说会刷新其它缓存行的数据；</li>\n<li>**putXxx(obj, offset)**，不使用任何屏障，更新对象对应偏移量的值；</li>\n<li>**getXxxVolatile()**，使用 LoadLoad 屏障，会从主内存获取最新值；</li>\n<li>**getXxx(obj, offset)**，不使用任何屏障，读取对象对应偏移量的值；</li>\n</ol>\n</li>\n</ol>\n<p>总结：</p>\n<h4 id=\"MPSC实现高并发和高性能使用了哪些方法？\"><a href=\"#MPSC实现高并发和高性能使用了哪些方法？\" class=\"headerlink\" title=\"MPSC实现高并发和高性能使用了哪些方法？\"></a><em><strong>MPSC实现高并发和高性能使用了哪些方法？</strong></em></h4><ol>\n<li>LazySet 延迟更新机制：在更新producerLimit，消费者索引，和环形数组元素时使用StoreStore屏障，虽然写操作结果有纳秒级的延迟，但是由于没有立刻读取的操作，所以没有问题，且提升了性能</li>\n<li>使用偏移量来更新数组元素，比下标性能更好</li>\n<li>使用UNSAFE方法来直接操作内存</li>\n</ol>\n","text":"Netty和Tomcat有什么区别？Netty是一个基于NIO的异步网络通信框架，性能高，封装了原生NIO，降低了编码复杂度。 Tomcat是一个Web服务器，是一个Servlet容器，内部只运行Servlet程序并处理HTTP请求。 Netty封装的是IO模型，用于处理网络数据...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[],"tags":[{"name":"netty","slug":"netty","count":2,"path":"api/tags/netty.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Netty%E5%92%8CTomcat%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">Netty和Tomcat有什么区别？</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#reactor%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">reactor线程模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%95reactor-%E5%A4%9A%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">单reactor-多线程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E4%BB%8Ereactor-%E5%A4%9A%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">主从reactor-多线程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%B6%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">什么是零拷贝</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Netty%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84\"><span class=\"toc-text\">Netty的线程模型是怎么样的</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Netty%E4%B8%BA%E4%BB%80%E4%B9%88%E9%AB%98%E6%80%A7%E8%83%BD%EF%BC%9F\"><span class=\"toc-text\">Netty为什么高性能？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B2%98%E5%8C%85\"><span class=\"toc-text\">粘包</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%8A%E5%8C%85\"><span class=\"toc-text\">半包</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#MpscQueue\"><span class=\"toc-text\">MpscQueue</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#MpscArrayQueue%E4%B8%BA%E4%BE%8B\"><span class=\"toc-text\">MpscArrayQueue为例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BC%AA%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">伪共享问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#MPSC%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">MPSC方法解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%A0%E5%85%A5%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">加入元素</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">获取元素</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#MPSC%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E6%80%A7%E8%83%BD%E4%BD%BF%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F\"><span class=\"toc-text\">MPSC实现高并发和高性能使用了哪些方法？</span></a></li></ol></li></ol></li></ol>","author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"netty项目记录","uid":"cd132b199d60085bc82ceffbffeca6fd","slug":"netty项目记录——react线程模型简述","date":"2022-10-22T09:16:43.000Z","updated":"2022-11-15T12:38:14.159Z","comments":true,"path":"api/articles/netty项目记录——react线程模型简述.json","keywords":null,"cover":null,"text":"如何编写并启动一个服务端？ public void run() throws Exception&#123; //指定bossGroup，也就是负责处理连接请求的线程 EventLoopGroup bossGroup = new NioEventLoopGroup(1); //指...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"netty","slug":"netty","count":2,"path":"api/tags/netty.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"进程，线程和协程详解","uid":"27f3741f94599209904dbbf8d63cd0fd","slug":"进程，线程，协程","date":"2022-10-20T08:53:01.000Z","updated":"2022-11-22T08:14:57.357Z","comments":true,"path":"api/articles/进程，线程，协程.json","keywords":null,"cover":[],"text":"进程 an instance of a computer program that is being executed 进程是程序的一次执行，是一个程序及其数据，运行环境，在处理机上运行时所发生的活动。 与程序不同的是，进程具有动态性和生命周期，是系统进行资源分配和调度的独立单位...","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":7,"path":"api/tags/Java基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}