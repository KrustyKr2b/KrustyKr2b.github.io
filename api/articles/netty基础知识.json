{"title":"netty基础知识","uid":"4fe89795a63627b54cad79ec28758dc1","slug":"netty基础知识","date":"2022-10-22T08:35:26.000Z","updated":"2022-11-15T08:39:49.211Z","comments":true,"path":"api/articles/netty基础知识.json","keywords":null,"cover":[],"content":"<h2 id=\"Netty和Tomcat有什么区别？\"><a href=\"#Netty和Tomcat有什么区别？\" class=\"headerlink\" title=\"Netty和Tomcat有什么区别？\"></a><em><strong>Netty和Tomcat有什么区别？</strong></em></h2><p>Netty是一个基于NIO的异步网络通信框架，性能高，<strong>封装了原生NIO</strong>，降低了编码复杂度。</p>\n<p>Tomcat是一个Web服务器，是一个Servlet容器，内部只运行Servlet程序并处理HTTP请求。</p>\n<p>Netty封装的是IO模型，用于处理网络数据的传输，不关心具体的协议，其定制性更高</p>\n<h1 id=\"reactor线程模型\"><a href=\"#reactor线程模型\" class=\"headerlink\" title=\"reactor线程模型\"></a>reactor线程模型</h1><p>reactor就是IO多路复用（NIO）+线程池的结合优化版</p>\n<p>reactor线程模型：主要有四个角色</p>\n<ol>\n<li>Reactor：把IO事件分配给对应的handler处理，就是IO多路复用的select实现，即轮询监听</li>\n<li>Acceptor：处理客户端连接事件，创建Handler对象</li>\n<li>Handler：将自身与事件绑定，执行非阻塞读、写任务，负责channel的读入，业务处理完成后，负责将结果写出channel</li>\n<li>worker：用来处理handler传来的业务的线程</li>\n</ol>\n<p>其中1，2，3存放于主线程中，也称为bossGroup</p>\n<p>4存放于从线程，也就是线程池中，也称为workerGroup</p>\n<h2 id=\"单reactor-多线程\"><a href=\"#单reactor-多线程\" class=\"headerlink\" title=\"单reactor-多线程\"></a>单reactor-多线程</h2><p><img src=\"/../img/reactor3.png\" alt=\"reactor3\"></p>\n<h2 id=\"主从reactor-多线程\"><a href=\"#主从reactor-多线程\" class=\"headerlink\" title=\"主从reactor-多线程\"></a>主从reactor-多线程</h2><p>这种模型下是把Reactor线程拆分了mainReactor和subReactor两个部分</p>\n<p>mainReactor只处理连接事件，读写事件交给subReactor来处理。业务逻辑还是由线程池来处理</p>\n<p><img src=\"/../img/reactor4.png\" alt=\"reactor4\"></p>\n<h2 id=\"什么是零拷贝\"><a href=\"#什么是零拷贝\" class=\"headerlink\" title=\"什么是零拷贝\"></a><em><strong>什么是零拷贝</strong></em></h2><p>应用程序把内核中的一块数据转移到内核中的另一个区域去时，不需要经过先复制到用户空间，再转移到目标内核区域，而是实现直接转移，系统调用transferTo()</p>\n<h3 id=\"Netty的线程模型是怎么样的\"><a href=\"#Netty的线程模型是怎么样的\" class=\"headerlink\" title=\"Netty的线程模型是怎么样的\"></a><em><strong>Netty的线程模型是怎么样的</strong></em></h3><p>Netty同时支持Reactor单线程模型，多线程模型，主从多线程模型，用户可以配置参数在这三种模型之间切换</p>\n<p>服务端启动时，通常会创建两个NioEventLoopGroup实例，对应两个独立的Reactor线程池，bossGroup负责处理客户端的连接请求，workerGroup负责处理IO相关的操作，执行任务等。用户可以根据ServerBootstrap启动类选择参数配置线程模型。</p>\n<h3 id=\"Netty为什么高性能？\"><a href=\"#Netty为什么高性能？\" class=\"headerlink\" title=\"Netty为什么高性能？\"></a><em><strong>Netty为什么高性能？</strong></em></h3><ol>\n<li>NIO模型，用最少的资源完成最多的任务</li>\n<li>内存零拷贝，减少不必要的拷贝造成资源浪费，实现更高效率的传输</li>\n<li>串行化处理读写：消息的处理尽可能在同一个线程内完成，避免切换线程的花销，避免多线程竞争和同步锁。调整NIO线程池的线程参数，可以同时启动多个串行化的线程，相比于多线程竞争机制性能更优。</li>\n<li>支持protobuf：<code>protobuf</code> (protocol buffer) 是谷歌内部的混合语言数据标准。通过将结构化的数据进行序列化(串行化)，用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。是一个高性能的编解码框架，序列化数据后数据更小，传输速度更快，安全性也更高，netty可以直接在handler内添加protobuf编码解码器。</li>\n<li>内存池设计，申请的内存可以重用</li>\n</ol>\n<h2 id=\"粘包\"><a href=\"#粘包\" class=\"headerlink\" title=\"粘包\"></a>粘包</h2><p>现象：发送abc和def，结果接收到abcdef</p>\n<p>原因：</p>\n<ol>\n<li>应用层：接收方的bytebuf设置太大（默认1024）</li>\n<li>TCP滑动窗口足够大，且接收方处理不及时</li>\n<li>TCP的Nagle算法：为了减少广域网的小分组数目，从而减小网络拥塞的出现，会造成粘包。</li>\n</ol>\n<p>netty的解决方案：</p>\n<ol>\n<li>短连接，发完一次消息后便断开连接。下一次发消息的时候再次建立连接，重置了缓冲区</li>\n<li>设置合理的缓冲区</li>\n</ol>\n<h2 id=\"半包\"><a href=\"#半包\" class=\"headerlink\" title=\"半包\"></a>半包</h2><p>现象：发送abcdef接收到abc和def</p>\n<p>原因：</p>\n<ol>\n<li>应用层：bytebuf过小</li>\n<li>TCP滑动窗口过小</li>\n<li>链路层：MSS限制</li>\n</ol>\n<p>netty解决方案</p>\n<p><code>FixedLengthFrameDecoder</code>定长帧解码器：固定收到的帧的大小，若收到半包，则延迟交付，直到收到其他消息满足大小，再交付</p>\n<p><code>LineBasedFrameDecoder</code>行帧解码器：根据特定字符来区分完整的信息，避免半包</p>\n<p><code>LengthFiledBasedFrameDecoder</code> ：指定内容长度，偏移量，从第几个字节开始读，跳过几个字节再读，从而精准读取内容避免半包</p>\n","text":"Netty和Tomcat有什么区别？Netty是一个基于NIO的异步网络通信框架，性能高，封装了原生NIO，降低了编码复杂度。 Tomcat是一个Web服务器，是一个Servlet容器，内部只运行Servlet程序并处理HTTP请求。 Netty封装的是IO模型，用于处理网络数据...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"netty","slug":"netty","count":2,"path":"api/tags/netty.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Netty%E5%92%8CTomcat%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">Netty和Tomcat有什么区别？</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#reactor%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">reactor线程模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%95reactor-%E5%A4%9A%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">单reactor-多线程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E4%BB%8Ereactor-%E5%A4%9A%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">主从reactor-多线程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%B6%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">什么是零拷贝</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Netty%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84\"><span class=\"toc-text\">Netty的线程模型是怎么样的</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Netty%E4%B8%BA%E4%BB%80%E4%B9%88%E9%AB%98%E6%80%A7%E8%83%BD%EF%BC%9F\"><span class=\"toc-text\">Netty为什么高性能？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B2%98%E5%8C%85\"><span class=\"toc-text\">粘包</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%8A%E5%8C%85\"><span class=\"toc-text\">半包</span></a></li></ol>","author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"netty项目记录","uid":"cd132b199d60085bc82ceffbffeca6fd","slug":"netty项目记录——react线程模型简述","date":"2022-10-22T09:16:43.000Z","updated":"2022-11-15T12:38:14.159Z","comments":true,"path":"api/articles/netty项目记录——react线程模型简述.json","keywords":null,"cover":null,"text":"如何编写并启动一个服务端？ public void run() throws Exception&#123; //指定bossGroup，也就是负责处理连接请求的线程 EventLoopGroup bossGroup = new NioEventLoopGroup(1); //指...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"netty","slug":"netty","count":2,"path":"api/tags/netty.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"进程，线程和协程","uid":"a81dd39014b037511fb6ceaf21738564","slug":"协程","date":"2022-10-20T08:53:01.000Z","updated":"2022-11-15T07:12:22.395Z","comments":true,"path":"api/articles/协程.json","keywords":null,"cover":[],"text":"进程an instance of a computer program that is being executed 进程是程序的一次执行，是一个程序及其数据，运行环境，在处理机上运行时所发生的活动。 与程序不同的是，进程具有动态性和生命周期，是系统进行资源分配和调度的独立单位。...","link":"","photos":[],"count_time":{"symbolsCount":"7.6k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":9,"path":"api/tags/Java基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}