{"title":"netty基础","uid":"f81fcbbeae7dcf45a5335b1888cb075e","slug":"netty基础知识","date":"2022-10-22T08:35:26.000Z","updated":"2022-11-24T12:42:57.070Z","comments":true,"path":"api/articles/netty基础知识.json","keywords":null,"cover":[],"content":"<h2 id=\"为什么我们不用Java-NIO？\"><a href=\"#为什么我们不用Java-NIO？\" class=\"headerlink\" title=\"为什么我们不用Java NIO？\"></a><em><strong>为什么我们不用Java NIO？</strong></em></h2><p>原生的Java NIO编程，对编程能力要求比较高，需要处理连接异常、网络闪断、拆包粘包、网络拥塞、长短连接等各种各样的网络通讯细节问题，这是一件非常困难且耗时的事情。并且，原生Java NIO还有一个臭名昭著的<em><strong>Epoll Bug</strong></em>，它会导致Selector空轮询，最终导致CPU 100%。官方声称在JDK 1.6版本的update 18修复了该问题，但是直到JDK1.7版本该问题仍旧存在，只不过该Bug发生概率降低了一些而已，它并没有被根本解决。</p>\n<h2 id=\"Netty和Tomcat有什么区别？\"><a href=\"#Netty和Tomcat有什么区别？\" class=\"headerlink\" title=\"Netty和Tomcat有什么区别？\"></a><em><strong>Netty和Tomcat有什么区别？</strong></em></h2><p>Netty是一个基于NIO的异步网络通信框架，性能高，<strong>封装了原生NIO</strong>，降低了编码复杂度。</p>\n<p>Tomcat是一个Web服务器，是一个Servlet容器，内部只运行Servlet程序并处理HTTP请求。</p>\n<p>Netty封装的是IO模型，用于处理网络数据的传输，不关心具体的协议，其定制性更高</p>\n<h1 id=\"reactor线程模型\"><a href=\"#reactor线程模型\" class=\"headerlink\" title=\"reactor线程模型\"></a>reactor线程模型</h1><p>reactor就是IO多路复用（NIO）+线程池的结合优化版</p>\n<p>reactor线程模型：主要有四个角色</p>\n<ol>\n<li>Reactor：把IO事件分配给对应的handler处理，就是IO多路复用的select实现，即轮询监听</li>\n<li>Acceptor：处理客户端连接事件，创建Handler对象</li>\n<li>Handler：将自身与事件绑定，执行非阻塞读、写任务，负责channel的读入，业务处理完成后，负责将结果写出channel</li>\n<li>worker：用来处理handler传来的业务的线程</li>\n</ol>\n<p>其中1，2，3存放于主线程中，也称为bossGroup</p>\n<p>4存放于从线程，也就是线程池中，也称为workerGroup</p>\n<h2 id=\"单reactor-多线程\"><a href=\"#单reactor-多线程\" class=\"headerlink\" title=\"单reactor-多线程\"></a>单reactor-多线程</h2><p><img src=\"/../img/reactor3.png\" alt=\"reactor3\"></p>\n<h2 id=\"主从reactor-多线程\"><a href=\"#主从reactor-多线程\" class=\"headerlink\" title=\"主从reactor-多线程\"></a>主从reactor-多线程</h2><p>这种模型下是把Reactor线程拆分了mainReactor和subReactor两个部分</p>\n<p>mainReactor只处理连接事件，读写事件交给subReactor来处理。业务逻辑还是由线程池来处理</p>\n<p><img src=\"/../img/reactor4.png\" alt=\"reactor4\"></p>\n<h3 id=\"Netty的线程模型是怎么样的\"><a href=\"#Netty的线程模型是怎么样的\" class=\"headerlink\" title=\"Netty的线程模型是怎么样的\"></a><em><strong>Netty的线程模型是怎么样的</strong></em></h3><p>Netty同时支持Reactor单线程模型，多线程模型，主从多线程模型，用户可以配置参数在这三种模型之间切换</p>\n<p>服务端启动时，通常会创建两个NioEventLoopGroup实例，对应两个独立的Reactor线程池，bossGroup负责处理客户端的连接请求，workerGroup负责处理IO相关的操作，执行任务等。用户可以根据ServerBootstrap启动类选择参数配置线程模型。</p>\n<h3 id=\"Netty为什么高性能？\"><a href=\"#Netty为什么高性能？\" class=\"headerlink\" title=\"Netty为什么高性能？\"></a><em><strong>Netty为什么高性能？</strong></em></h3><ol>\n<li>NIO模型，用最少的资源完成最多的任务</li>\n<li>内存零拷贝，减少不必要的拷贝造成资源浪费，实现更高效率的传输</li>\n<li>串行化处理读写：消息的处理尽可能在同一个线程内完成，避免切换线程的花销，避免多线程竞争和同步锁。调整NIO线程池的线程参数，可以同时启动多个串行化的线程，相比于多线程竞争机制性能更优。</li>\n<li>支持protobuf：<code>protobuf</code> (protocol buffer) 是谷歌内部的混合语言数据标准。通过将结构化的数据进行序列化(串行化)，用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。是一个高性能的编解码框架，序列化数据后数据更小，传输速度更快，安全性也更高，netty可以直接在handler内添加protobuf编码解码器。</li>\n<li>内存池设计，申请的内存可以重用</li>\n</ol>\n<h2 id=\"粘包\"><a href=\"#粘包\" class=\"headerlink\" title=\"粘包\"></a>粘包</h2><p>现象：发送abc和def，结果接收到abcdef</p>\n<p>原因：</p>\n<ol>\n<li>应用层：接收方的bytebuf设置太大（默认1024）</li>\n<li>TCP滑动窗口足够大，且接收方处理不及时</li>\n<li>TCP的Nagle算法：为了减少广域网的小分组数目，从而减小网络拥塞的出现，会造成粘包。</li>\n</ol>\n<p>netty的解决方案：</p>\n<ol>\n<li>短连接，发完一次消息后便断开连接。下一次发消息的时候再次建立连接，重置了缓冲区</li>\n<li>设置合理的缓冲区</li>\n</ol>\n<h2 id=\"半包\"><a href=\"#半包\" class=\"headerlink\" title=\"半包\"></a>半包</h2><p>现象：发送abcdef接收到abc和def</p>\n<p>原因：</p>\n<ol>\n<li>应用层：bytebuf过小</li>\n<li>TCP滑动窗口过小</li>\n<li>链路层：MSS限制</li>\n</ol>\n<p>netty解决方案</p>\n<p><code>FixedLengthFrameDecoder</code>定长帧解码器：固定收到的帧的大小，若收到半包，则延迟交付，直到收到其他消息满足大小，再交付</p>\n<p><code>LineBasedFrameDecoder</code>行帧解码器：根据特定字符来区分完整的信息，避免半包</p>\n<p><code>LengthFiledBasedFrameDecoder</code> ：指定内容长度，偏移量，从第几个字节开始读，跳过几个字节再读，从而精准读取内容避免半包</p>\n<h1 id=\"零拷贝\"><a href=\"#零拷贝\" class=\"headerlink\" title=\"零拷贝\"></a><strong>零拷贝</strong></h1><p>零拷贝（zero-copy），是指在计算机执行IO操作时，CPU 不需要先将数据从一个内存区域复制到另一个内存区域。具体来讲，就是数据从网络设备到用户程序空间传递的过程中，减少数据拷贝次数，减少系统调用，实现 CPU 的零参与，彻底消除 CPU 在这方面的负载。</p>\n<h3 id=\"传统的Linux-I-x2F-O模式\"><a href=\"#传统的Linux-I-x2F-O模式\" class=\"headerlink\" title=\"传统的Linux I&#x2F;O模式\"></a>传统的Linux I&#x2F;O模式</h3><p><img src=\"/../img/DMAIO.png\" alt=\"DMAIO\"></p>\n<p><code>shell read(file_fd, tmp_buf, len); write(socket_fd, tmp_buf, len);</code></p>\n<ol>\n<li>用户进程通过<code>read</code>函数向内核（kernel）发起系统调用，<strong>CPU 将用户进程从用户态切换到内核态</strong>；</li>\n<li>CPU 利用 DMA 控制器将数据从主存或硬盘拷贝到内核空间（kernel space）的读缓冲区（read buffer）；</li>\n<li>CPU 将读缓冲区中的数据拷贝到用户空间（user space）的用户缓冲区（user buffer）；</li>\n<li><strong>CPU 将用户进程从内核态切换回用户态</strong>，<code>read</code>调用执行返回；</li>\n<li>用户进程通过<code>write</code>函数向内核发起系统调用，<strong>CPU 将用户进程从用户态切换到内核态</strong>；</li>\n<li>CPU 将用户缓冲区中的数据拷贝到内核空间的网络缓冲区（socket buffer）;</li>\n<li>CPU 利用 DMA 控制器将数据从网络缓冲区拷贝到网卡，进行数据传输；</li>\n<li>CPU <strong>将用户进程从内核态切换回用户态</strong>，<code>write</code>调用执行返回。</li>\n</ol>\n<p>数据必须经过用户缓冲区才能到达Socket缓冲区，虽然加入了DMA来处理内核与硬件的数据传输，但是仍然效率不高</p>\n<h3 id=\"由mmap实现用户态直接I-x2F-O\"><a href=\"#由mmap实现用户态直接I-x2F-O\" class=\"headerlink\" title=\"由mmap实现用户态直接I&#x2F;O\"></a>由mmap实现用户态直接I&#x2F;O</h3><p><code>tmp_buf = mmap(file_fd, len);write(socket_fd, tmp_buf, len);</code></p>\n<p>使用 mmap 的目的是将内核中读缓冲区（read buffer）的地址与用户空间的缓冲区（user buffer）进行映射，从而实现内核缓冲区与应用程序内存的共享，省去了将数据从内核读缓冲区（read buffer）拷贝到用户缓冲区（user buffer）的过程，CPU直接将内核缓冲区中的数据拷贝到Socket缓冲区，节省了一次CPU拷贝。</p>\n<p><img src=\"/../img/DMAIO1.png\" alt=\"DMAIO1\"></p>\n<p>当<code>mmap</code>一个文件时，如果这个文件被另一个进程所截获，那么<code>write</code>系统调用会因为访问非法地址被<code>SIGBUS</code>信号终止，<code>SIGBUS</code>默认会杀死进程并产生一个 <code>coredump</code>，服务器可能因此被终止。</p>\n<h3 id=\"Sendfile实现内核内的数据传输\"><a href=\"#Sendfile实现内核内的数据传输\" class=\"headerlink\" title=\"Sendfile实现内核内的数据传输\"></a>Sendfile实现内核内的数据传输</h3><p><code>sendfile(socket_fd, file_fd, len);</code></p>\n<p>通过 Sendfile 系统调用，<strong>数据可以直接在内核空间内部进行 I&#x2F;O 传输，省去了数据在用户空间和内核空间之间的来回拷贝</strong>。</p>\n<p><img src=\"/../img/DMAIO2.png\" alt=\"DMAIO2\"></p>\n<p>基于 Sendfile 系统调用的零拷贝方式，整个拷贝过程会发生<strong>2次上下文切换</strong>，<strong>1 次CPU拷贝和2次DMA拷贝</strong>。</p>\n<p>Sendfile 存在的问题是：用户程序不能在中途对数据进行修改，而只是单纯地完成了一次数据传输过程，它只适用于将数据从文件拷贝到 Socket 套接字上的传输过程。</p>\n<h3 id=\"Sendfile-DMA-gather-copy实现硬件级的直接拷贝\"><a href=\"#Sendfile-DMA-gather-copy实现硬件级的直接拷贝\" class=\"headerlink\" title=\"Sendfile+DMA gather copy实现硬件级的直接拷贝\"></a>Sendfile+DMA gather copy实现硬件级的直接拷贝</h3><p>Linux内核2.4版本，对 Sendfile 系统调用进行了修改，为DMA拷贝引入了<code>gather</code>操作：它将内核空间的读缓冲区中对应的数据描述信息（内存地址、地址偏移量）记录到相应的网络缓冲区（ socket buffer）中，<strong>由 DMA 根据内存地址、地址偏移量将数据批量地从读缓冲区拷贝到网卡设备中。</strong></p>\n<p><img src=\"/../img/DMAIO3.png\" alt=\"DMAIO3\"></p>\n<p>DMA gather copy需要硬件的支持，Sendfile 拷贝方式不再从内核缓冲区的数据拷贝到 Socket 缓冲区，取而代之是<strong>仅仅拷贝缓冲区文件描述符和数据长度。</strong></p>\n<p>这样 DMA 引擎直接利用 gather 操作将页缓存中数据打包发送到网络中即可，本质是和虚拟内存映射类似的思路</p>\n<p>整个拷贝过程会发生<strong>2次上下文切换</strong>、<strong>0次CPU拷贝以及2次 DMA拷贝</strong>。</p>\n<h3 id=\"Splice实现管道传输\"><a href=\"#Splice实现管道传输\" class=\"headerlink\" title=\"Splice实现管道传输\"></a>Splice实现管道传输</h3><p>Linux内核2.6.17版本，引入了 Splice 系统调用。Splice 系统调用可以在内核空间的读缓冲区和网络缓冲区之间建立管道（pipeline），从而避免了两者之间的 CPU 拷贝操作。</p>\n<p>Splice 系统调用不仅不需要硬件支持，还实现了两个文件描述符之间的数据零拷贝。<img src=\"/../img/DMAIO4.png\" alt=\"DMAIO4\"></p>\n<p>整个拷贝过程会发生<strong>2次上下文切换</strong>，<strong>0次CPU拷贝以及2次DMA拷贝</strong></p>\n<table>\n<thead>\n<tr>\n<th>消息队列</th>\n<th>零拷贝方式</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>RocketMQ</td>\n<td>mmap + write</td>\n<td>适用于小块文件传输，频繁调用时，效率很高</td>\n<td>不能很好的利用DMA方式，会比sendfile多消耗CPU，内存安全性控制复杂，需要避免JVM Crash问题</td>\n</tr>\n<tr>\n<td>Kafka</td>\n<td>sendfile</td>\n<td>可以利用DMA方式，消耗CPU较少，大块文件传输效率高，无内存安全性问题</td>\n<td>小块文件效率低于mmap方式，只能是BIO方式传输，不能使用NIO方式</td>\n</tr>\n</tbody></table>\n<p>无论是传统 I&#x2F;O 拷贝方式还是引入零拷贝的方式，2次DMA拷贝都是少不了的，因为两次 DMA 都是依赖硬件完成的</p>\n<h2 id=\"netty的零拷贝\"><a href=\"#netty的零拷贝\" class=\"headerlink\" title=\"netty的零拷贝\"></a>netty的零拷贝</h2><p>Netty 中也使用了零拷贝技术，但是和操作系统层面上的零拷贝不太一样, Netty 零拷贝是相对于堆内存与堆外内存而言的，它的更多的是偏向于数据操作优化这样的概念。</p>\n<ol>\n<li>Netty接收和发送ByteBuffer采用DirectBuffer，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的JVM的堆内存进行socker读写，那么JVM将会将堆内存拷贝一份到直接内存中，然后在写入socket中。相比堆外直接内存，消息在发送过程中多了一次缓存区的拷贝</li>\n<li>Netty提供CompositeByteBuf组合缓冲区类，可以将多个 ByteBuf合并为一个逻辑上的ByteBufer，避免了各个ByteBufer之间的拷贝，将几个小buffer合并成一个大buffer的繁琐操作。</li>\n<li>Netty提供了ByteBuf的浅层复制操作(slice、 duplicate)，可以将ByteBuf分解为多个共享同一个存储区域的 ByteBuf，避免内存的拷贝</li>\n<li>Netty进行文件传输时，可以调用FileRegion包装的 **transferTo()**方法直接将文件缓冲区的数据发送到目标通道，避免普通的循环读取文件数据和写入通道所导致的内存拷贝问题。</li>\n<li>在将一个byte数组转换为一个ByteBuf对象的场景下，Netty 提供了一系列的包装类，避免了转换过程中的内存拷贝。</li>\n</ol>\n","text":"为什么我们不用Java NIO？原生的Java NIO编程，对编程能力要求比较高，需要处理连接异常、网络闪断、拆包粘包、网络拥塞、长短连接等各种各样的网络通讯细节问题，这是一件非常困难且耗时的事情。并且，原生Java NIO还有一个臭名昭著的Epoll Bug，它会导致Selec...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"netty","slug":"netty","count":3,"path":"api/tags/netty.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E4%B8%8D%E7%94%A8Java-NIO%EF%BC%9F\"><span class=\"toc-text\">为什么我们不用Java NIO？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Netty%E5%92%8CTomcat%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">Netty和Tomcat有什么区别？</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#reactor%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">reactor线程模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%95reactor-%E5%A4%9A%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">单reactor-多线程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E4%BB%8Ereactor-%E5%A4%9A%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">主从reactor-多线程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Netty%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84\"><span class=\"toc-text\">Netty的线程模型是怎么样的</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Netty%E4%B8%BA%E4%BB%80%E4%B9%88%E9%AB%98%E6%80%A7%E8%83%BD%EF%BC%9F\"><span class=\"toc-text\">Netty为什么高性能？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B2%98%E5%8C%85\"><span class=\"toc-text\">粘包</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%8A%E5%8C%85\"><span class=\"toc-text\">半包</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%9B%B6%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">零拷贝</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BC%A0%E7%BB%9F%E7%9A%84Linux-I-x2F-O%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">传统的Linux I&#x2F;O模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%B1mmap%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%80%81%E7%9B%B4%E6%8E%A5I-x2F-O\"><span class=\"toc-text\">由mmap实现用户态直接I&#x2F;O</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Sendfile%E5%AE%9E%E7%8E%B0%E5%86%85%E6%A0%B8%E5%86%85%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93\"><span class=\"toc-text\">Sendfile实现内核内的数据传输</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Sendfile-DMA-gather-copy%E5%AE%9E%E7%8E%B0%E7%A1%AC%E4%BB%B6%E7%BA%A7%E7%9A%84%E7%9B%B4%E6%8E%A5%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">Sendfile+DMA gather copy实现硬件级的直接拷贝</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Splice%E5%AE%9E%E7%8E%B0%E7%AE%A1%E9%81%93%E4%BC%A0%E8%BE%93\"><span class=\"toc-text\">Splice实现管道传输</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#netty%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">netty的零拷贝</span></a></li></ol>","author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"netty项目记录","uid":"cd132b199d60085bc82ceffbffeca6fd","slug":"netty项目记录——react线程模型简述","date":"2022-10-22T09:16:43.000Z","updated":"2022-11-15T12:38:14.159Z","comments":true,"path":"api/articles/netty项目记录——react线程模型简述.json","keywords":null,"cover":null,"text":"如何编写并启动一个服务端？ public void run() throws Exception&#123; //指定bossGroup，也就是负责处理连接请求的线程 EventLoopGroup bossGroup = new NioEventLoopGroup(1); //指...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"netty","slug":"netty","count":3,"path":"api/tags/netty.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"进程，线程和协程详解","uid":"27f3741f94599209904dbbf8d63cd0fd","slug":"进程，线程，协程","date":"2022-10-20T08:53:01.000Z","updated":"2022-11-30T12:20:10.397Z","comments":true,"path":"api/articles/进程，线程，协程.json","keywords":null,"cover":[],"text":"进程 an instance of a computer program that is being executed 进程是程序的一次执行，是一个程序及其数据，运行环境，在处理机上运行时所发生的活动。 与程序不同的是，进程具有动态性和生命周期，是系统进行资源分配和调度的独立单位...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":7,"path":"api/tags/Java基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}