{"title":"一篇关于锁的文章","uid":"a213144f9a961ec1d4584b73bef34320","slug":"一篇关于锁的文章","date":"2022-10-19T08:28:53.000Z","updated":"2022-10-23T09:10:58.278Z","comments":true,"path":"api/articles/一篇关于锁的文章.json","keywords":null,"cover":[],"content":"<p><strong>面试官：解释一下什么是乐观锁，悲观锁，自旋锁，读写锁，排它锁，共享锁，统一锁，分段锁</strong></p>\n<p>这种问题虽然庞大复杂，但是千万不要被干沉默，能说清楚就是P5往上</p>\n<h2 id=\"按抽象概念分\"><a href=\"#按抽象概念分\" class=\"headerlink\" title=\"按抽象概念分\"></a>按抽象概念分</h2><h3 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h3><p>悲观地认为数据大概率会被其他线程操作，所以具有强烈的独占性和排它性</p>\n<p>比如synchronized，先加锁再执行代码块</p>\n<h3 id=\"乐观锁\"><a href=\"#乐观锁\" class=\"headerlink\" title=\"乐观锁\"></a>乐观锁</h3><p>相反，乐观地认为数据不大会被其他线程操作，所以先执行代码块，遇见线程冲突的情况，再补偿</p>\n<h3 id=\"自旋锁\"><a href=\"#自旋锁\" class=\"headerlink\" title=\"自旋锁\"></a>自旋锁</h3><p>自旋锁是乐观锁的一种实现形式，首先需要了解一些概念</p>\n<h4 id=\"CAS操作：\"><a href=\"#CAS操作：\" class=\"headerlink\" title=\"CAS操作：\"></a>CAS操作：</h4><p>CAS全称为compare and swap，即比较和交换</p>\n<p>这是JDK提供的原子性操作。语义上是两步操作，但是CPU一条指令即可以完成</p>\n<p>汇编指令：lock cmpxchg  </p>\n<p>原子性保证lock：当执行cmpxchg时，其他CPU不允许打断这个操作，lock是硬件级的实现：锁定北桥信号</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">boolean</span> <span class=\"token function\">compareAndSwapLong</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> obj<span class=\"token punctuation\">,</span><span class=\"token class-name\">Long</span> valueOffset<span class=\"token punctuation\">,</span><span class=\"token keyword\">long</span> expect<span class=\"token punctuation\">,</span><span class=\"token keyword\">long</span> update<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//obj:对象的内存地址</span>\n<span class=\"token comment\">//valueOffset:偏移值</span>\n<span class=\"token comment\">//expect:期望的旧值</span>\n<span class=\"token comment\">//update:期望的新值</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>如果对象中的变量值为expect，则使用新的值update替换expect</strong></p>\n<p><strong>替换成功，返回true；替换失败，即变量值不为expect，返回false；</strong></p>\n<p>特点：非阻塞，即允许多个线程对共享资源进行修改，但是同一时刻只有一个线程可以进行写操作，其他线程并不是被阻塞，而是在不停重试拿到锁。</p>\n<p>在JAVA中若一个线程没有拿到锁被阻塞，就会造成线程的上下文切换，大量线程的重新调度会造成性能的浪费。volatile只能保证<strong>有序性和可见性</strong>，不能保证原子性。CAS就保证了<strong>原子性</strong>。</p>\n<p>CAS和volatile两者可以实现无锁并发</p>\n<img src=\"../img/CAS.png\" alt=\"CAS\" style=\"zoom: 80%;\" />\n\n<h4 id=\"ABA问题：\"><a href=\"#ABA问题：\" class=\"headerlink\" title=\"ABA问题：\"></a>ABA问题：</h4><p>假如线程1使用CAS修改初始值为A的变量X&#x3D;A，那么线程1首先会获取当前变量X的值（A），然后使用CAS操作尝试修改X的值为B，如果使用CAS修改成功了，那么程序运行一定是正常的吗？</p>\n<p>其实未必，这是因为有可能在线程1获取到变量X的值A后，在执行CAS之前，线程2使用了CAS修改了变量X值为B，然后又使用了CAS操作使得变量X值为A，虽然线程A执行了CAS操作时X&#x3D;A，但是这个A已经不是线程1获取到的A了。这就是ABA问题。</p>\n<p>ABA问题的产生是因为变量的状态值产生了<strong>环形转换</strong>，就是变量值可以从A到B，也可以B到A，如果变量的值只能朝着一个方向转换，例如A到B，B到C，不构成环路，就不会存在这个问题。</p>\n<p>JDK中的AtomicStampedReference类给每个变量的状态值都配备了一个<strong>时间戳，</strong>从而避免了ABA问题。或者是使<strong>用版本号</strong>，一个数据一个版本号，版本号不同数据值相同，也不会进行修改。</p>\n<p>所以自旋锁便是通过CAS来实现的，在获取锁的时候使用while循环不断进行CAS操作，类似于不断旋转，直到操作成功返回<code>true</code>，在释放锁的时候使用CAS将锁的状态从1变成0。</p>\n<h2 id=\"按读写属性分\"><a href=\"#按读写属性分\" class=\"headerlink\" title=\"按读写属性分\"></a>按读写属性分</h2><h3 id=\"排他锁\"><a href=\"#排他锁\" class=\"headerlink\" title=\"排他锁\"></a>排他锁</h3><p>又称写锁，X锁，只有一个线程能访问代码块，synchronized关键字即是排他锁。写的时候，不允许其他线程读，也不允许其他线程写</p>\n<h3 id=\"共享锁\"><a href=\"#共享锁\" class=\"headerlink\" title=\"共享锁\"></a>共享锁</h3><p>又称读锁，S锁，可以有多个线程访问代码块，允许同时读，不允许写，必须等所有锁释放后才可以写</p>\n<h3 id=\"读写锁\"><a href=\"#读写锁\" class=\"headerlink\" title=\"读写锁\"></a>读写锁</h3><p>概念同上</p>\n<h2 id=\"按粒度分\"><a href=\"#按粒度分\" class=\"headerlink\" title=\"按粒度分\"></a>按粒度分</h2><h3 id=\"统一锁\"><a href=\"#统一锁\" class=\"headerlink\" title=\"统一锁\"></a>统一锁</h3><p>大粒度的锁，防止出现死锁。</p>\n<p>锁定A线程，等待B线程；锁定B，等待A；</p>\n<p>若没有很好地同步，就会出现死锁</p>\n<p>统一锁便是将A和B统一为一个大锁</p>\n<h3 id=\"分段锁\"><a href=\"#分段锁\" class=\"headerlink\" title=\"分段锁\"></a>分段锁</h3><p>JDK1.7 ConcurrentHashMap</p>\n<p>HashMap是一个很长的链表，所以如果并发插入数据时，如果每次都锁定整个链表，性能会很差</p>\n<p>所以需要加入一种粒度较小的锁，即在一个桶内放入数据时，只锁定一段，而不是整个链表。</p>\n<p>当锁定一段时，不影响其他段的数据插入，提高了效率，缺点，代码实现复杂</p>\n","text":"面试官：解释一下什么是乐观锁，悲观锁，自旋锁，读写锁，排它锁，共享锁，统一锁，分段锁 这种问题虽然庞大复杂，但是千万不要被干沉默，能说清楚就是P5往上 按抽象概念分悲观锁悲观地认为数据大概率会被其他线程操作，所以具有强烈的独占性和排它性 比如synchronized，先加锁再执行...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"面试突击","slug":"面试突击","count":7,"path":"api/tags/面试突击.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8C%89%E6%8A%BD%E8%B1%A1%E6%A6%82%E5%BF%B5%E5%88%86\"><span class=\"toc-text\">按抽象概念分</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%82%B2%E8%A7%82%E9%94%81\"><span class=\"toc-text\">悲观锁</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B9%90%E8%A7%82%E9%94%81\"><span class=\"toc-text\">乐观锁</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%87%AA%E6%97%8B%E9%94%81\"><span class=\"toc-text\">自旋锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#CAS%E6%93%8D%E4%BD%9C%EF%BC%9A\"><span class=\"toc-text\">CAS操作：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ABA%E9%97%AE%E9%A2%98%EF%BC%9A\"><span class=\"toc-text\">ABA问题：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8C%89%E8%AF%BB%E5%86%99%E5%B1%9E%E6%80%A7%E5%88%86\"><span class=\"toc-text\">按读写属性分</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%92%E4%BB%96%E9%94%81\"><span class=\"toc-text\">排他锁</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B1%E4%BA%AB%E9%94%81\"><span class=\"toc-text\">共享锁</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%BB%E5%86%99%E9%94%81\"><span class=\"toc-text\">读写锁</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8C%89%E7%B2%92%E5%BA%A6%E5%88%86\"><span class=\"toc-text\">按粒度分</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%9F%E4%B8%80%E9%94%81\"><span class=\"toc-text\">统一锁</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%AE%B5%E9%94%81\"><span class=\"toc-text\">分段锁</span></a></li></ol></li></ol>","author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"synchronized,volatile与lock","uid":"2b0f61f6bf7b985f1f4587a53651bb18","slug":"synchronized-volatile与lock","date":"2022-10-20T06:09:39.000Z","updated":"2022-10-23T09:25:26.481Z","comments":true,"path":"api/articles/synchronized-volatile与lock.json","keywords":null,"cover":[],"text":"Synchronized同步锁，保证在同一时刻，被修饰的代码块或方法只有一个线程执行，以达到并发安全的效果 同步锁是解决并发问题最简单的一种方法，直接给代码块加上此关键字即可 在JDK1.5之前，Synchronized是一个重量级锁，在以后的版本经过改进后成重量级减小 sync...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"面试突击","slug":"面试突击","count":7,"path":"api/tags/面试突击.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"字典序问题","uid":"db91e78c8da8e89de1c0960e4a35ed33","slug":"字典序问题","date":"2022-10-19T05:30:33.000Z","updated":"2022-10-19T06:21:05.815Z","comments":true,"path":"api/articles/字典序问题.json","keywords":null,"cover":null,"text":"给你一个整数 n ，按字典序返回范围 [1, n] 内所有整数。 你必须设计一个时间复杂度为 O(n) 且使用 O(1) 额外空间的算法。 示例 1： 输入：n &#x3D; 13 输出：[1,10,11,12,13,2,3,4,5,6,7,8,9] 思路：字典序的构建可以看成是...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"LeetCode初见","slug":"LeetCode初见","count":6,"path":"api/tags/LeetCode初见.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}