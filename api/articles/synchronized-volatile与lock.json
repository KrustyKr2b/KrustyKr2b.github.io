{"title":"synchronized,volatile与lock","uid":"2b0f61f6bf7b985f1f4587a53651bb18","slug":"synchronized-volatile与lock","date":"2022-10-20T06:09:39.000Z","updated":"2022-10-20T08:28:27.526Z","comments":true,"path":"api/articles/synchronized-volatile与lock.json","keywords":null,"cover":[],"content":"<h1 id=\"Synchronized\"><a href=\"#Synchronized\" class=\"headerlink\" title=\"Synchronized\"></a>Synchronized</h1><p>同步锁，保证在同一时刻，被修饰的代码块或方法只有一个线程执行，以达到并发安全的效果</p>\n<p>同步锁是解决并发问题最简单的一种方法，直接给代码块加上此关键字即可</p>\n<p>在JDK1.5之前，Synchronized是一个重量级锁，在以后的版本经过改进后成重量级减小</p>\n<p>synchronized的作用主要有三个：</p>\n<ol>\n<li><strong>原子性</strong>：确保线程<strong>互斥</strong>地访问同步代码；</li>\n<li><strong>可见性</strong>：保证共享变量的修改能够及时可见，其实是通过Java内存模型中的“<strong>对一个变量unlock操作之前，必须要同步到主内存中</strong>；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值” 来保证的；</li>\n<li><strong>有序性</strong>：有效解决重排序问题，即 “一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”；</li>\n</ol>\n<h2 id=\"底层实现：\"><a href=\"#底层实现：\" class=\"headerlink\" title=\"底层实现：\"></a>底层实现：</h2><p>对象在JVM的内存布局为：对象头+实例数据+对齐填充</p>\n<p>对象头（12字节）</p>\n<p>其中有4字节的class pointer和8字节的MarkWord</p>\n<p>后者是实现锁的关键，MarkWord被设计成一个非固定的数据，它会根据对象的状态复用自身的空间，即会随着程序的运行发生变化。MarkWord的最后三字节分别为：<strong>1bit记录是否为偏向锁</strong>；<strong>2bit记录锁标志位。</strong>当锁标志位变为00时为轻量级锁，01代表未锁定或者可加偏向锁，10时为重量级锁。</p>\n<h3 id=\"偏向锁：\"><a href=\"#偏向锁：\" class=\"headerlink\" title=\"偏向锁：\"></a>偏向锁：</h3><p>当一个线程访问加了同步锁的代码块时，<strong>会在对象头中存储当前线程的 ID</strong>，<strong>后续这个线程进入和退出这段加了同步锁的代码块时，不需要再次加锁和释放锁</strong>。而是直接比较对象头里面是否存储了指向当前线程的偏向锁。如果相等表示偏向锁是偏向于当前线程的，就不需要再尝试获得锁了。</p>\n<p>说白了就是消除无竞争情况下的性能消耗，避免一个线程的情况下也去竞争锁，造成浪费资源。</p>\n<p>底层实现原理：</p>\n<ol>\n<li>首先获取锁 对象的 Markword，判断是否处于可偏向状态。偏向锁状态位0，锁标志01</li>\n<li>如果是可偏向状态，则通过 CAS 操作，把当前线程的 ID 写入到 MarkWord<br>a) 如果 cas 成功，那么 markword 就会记录当前线程的ID。 表示已经获得了锁对象的偏向锁，接着执行同步代码块<br>b) 如果 cas 失败，说明有其他线程已经获得了偏向锁，这种情况说明当前锁存在竞争，需要撤销已获得偏向锁的线程，并且把它持有的锁升级为轻量级锁（这个操作需要等到全局安全点，也就是没有线程在执行字节码）才能执行</li>\n<li>如果是已偏向状态，需要检查 markword 中存储的<br>线程ID 是否等于当前线程的 线程ID<br>a) 如果相等，不需要再次获得锁，可直接执行同步代码块<br>b) 如果不相等，说明当前锁偏向于其他线程，需要撤销偏向锁并升级到轻量级锁</li>\n</ol>\n<h3 id=\"轻量级锁：\"><a href=\"#轻量级锁：\" class=\"headerlink\" title=\"轻量级锁：\"></a>轻量级锁：</h3><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。</p>\n<p>然后线程尝试使用 CAS将对象头中的Mark Word替换为指向锁记录的指针(即00)。</p>\n<p>如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p>\n<p>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。</p>\n<p>轻量级锁不进行阻塞，而是使用自旋的方式，自旋虽然提升了响应速度，但是会增大CPU的消耗</p>\n<h3 id=\"重量级锁：\"><a href=\"#重量级锁：\" class=\"headerlink\" title=\"重量级锁：\"></a>重量级锁：</h3><p>直接采用阻塞的方式处理获取锁失败的线程，阻塞线程需要cpu从用户态转到内核态，代价比较大。而且可能会出现刚阻塞不久，锁就被释放的情况，所以阻塞的方式会降低响应速度</p>\n<p>锁会随着线程的竞争情况逐渐升级，偏向锁 &#x3D;&gt; 轻量级锁 &#x3D;&gt; 重量级锁 。锁可以升级但是不能降级。升级的目的是为了提高获得锁和释放锁的效率。</p>\n<h1 id=\"Volatile\"><a href=\"#Volatile\" class=\"headerlink\" title=\"Volatile\"></a>Volatile</h1><p>Volatile关键字的作用主要有如下两个：</p>\n<ol>\n<li>线程的可见性：当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。</li>\n<li>顺序一致性：禁止指令重排序</li>\n</ol>\n<p>Volatile和synchronized的区别</p>\n<ol>\n<li>Volatile是轻量级的synchronized，因为它不会引起上下文的切换和调度，所以Volatile性能更好。</li>\n<li>Volatile只能修饰变量，synchronized可以修饰方法，静态方法，代码块。</li>\n<li>volatile仅能实现变量的修改可见性，并不能保证原子性，synchronized则可以保证原子性。</li>\n<li>多线程访问volatile不会发生阻塞，而synchronized会发生阻塞。</li>\n<li>volatile是变量在多线程之间的可见性，synchronize是多线程之间访问资源的同步性。</li>\n</ol>\n<h2 id=\"如何保证线程的可见性\"><a href=\"#如何保证线程的可见性\" class=\"headerlink\" title=\"如何保证线程的可见性\"></a>如何保证线程的可见性</h2><h4 id=\"JAVA的内存模型\"><a href=\"#JAVA的内存模型\" class=\"headerlink\" title=\"JAVA的内存模型\"></a>JAVA的内存模型</h4><p>线程之间的共享变量存储在主内存中，而每一个线程都有一个私有的本地内存，local memory存储了该线程读写的共享变量的副本。所以当一个线程在本地内存更新共享变量的副本后，需要重新写入主内存。</p>\n<p>如何将新值刷新到主内存中：</p>\n<p><strong>CPU寄存器-&gt;Cache-&gt;Main memory</strong>，写缓冲区可以避免处理器停顿下来等待写入数据而造成的延迟，并且写缓冲区可以合并多次写，减少对内存总线的占用。</p>\n<p>但是在写入主内存之前，另外一个线程是看不到的，所以就需要volatile关键则来保证可见性</p>\n<p>当线程对volatile修饰的变量进行写操作时，汇编指令会多出一个lock前缀，这就是<strong>内存屏障</strong>，而在多核心环境下，这个前缀会对应两个操作：</p>\n<ol>\n<li>将当前缓存行的数据<strong>立即</strong>写回系统内存</li>\n<li>这个写回内存的操作会使其他cpu里缓存的副本无效化</li>\n</ol>\n<p>这就是缓存一致性协议，每个处理器通过嗅探在总线传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，从而需要重新从系统内存中读取数据。</p>\n<p>所以多核心环境下，每一个线程读取被volatile修饰的变量时，都必须在主内存中读取最新的结果，而不是使用local memory内的数据，这样保证了一个线程修改变量的结果其他线程都是可知的，保证了线程的可见性。</p>\n<h2 id=\"如何禁止指令重排\"><a href=\"#如何禁止指令重排\" class=\"headerlink\" title=\"如何禁止指令重排\"></a>如何禁止指令重排</h2><p>同样依赖于lock前缀，即内存屏障实现</p>\n<p>编译器不会对volatile读与volatile读后面的任意内存操作重排序；</p>\n<p>编译器不会对volatile写与volatile写前面的任意内存操作重排序。</p>\n<p><img src=\"/../img/volatile1.png\" alt=\"volatile1\"></p>\n<p><img src=\"/../img/volatile2.png\" alt=\"volatile2\"></p>\n","feature":true,"text":"Synchronized同步锁，保证在同一时刻，被修饰的代码块或方法只有一个线程执行，以达到并发安全的效果 同步锁是解决并发问题最简单的一种方法，直接给代码块加上此关键字即可 在JDK1.5之前，Synchronized是一个重量级锁，在以后的版本经过改进后成重量级减小 sync...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"面试突击","slug":"面试突击","count":6,"path":"api/tags/面试突击.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Synchronized\"><span class=\"toc-text\">Synchronized</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%9A\"><span class=\"toc-text\">底层实现：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%81%8F%E5%90%91%E9%94%81%EF%BC%9A\"><span class=\"toc-text\">偏向锁：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%9A\"><span class=\"toc-text\">轻量级锁：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%9A\"><span class=\"toc-text\">重量级锁：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Volatile\"><span class=\"toc-text\">Volatile</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7\"><span class=\"toc-text\">如何保证线程的可见性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#JAVA%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">JAVA的内存模型</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92\"><span class=\"toc-text\">如何禁止指令重排</span></a></li></ol></li></ol>","author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"一篇关于锁的文章","uid":"a213144f9a961ec1d4584b73bef34320","slug":"一篇关于锁的文章","date":"2022-10-19T08:28:53.000Z","updated":"2022-10-19T14:15:28.671Z","comments":true,"path":"api/articles/一篇关于锁的文章.json","keywords":null,"cover":[],"text":"面试官：解释一下什么是乐观锁，悲观锁，自旋锁，读写锁，排它锁，共享锁，统一锁，分段锁 这种问题虽然庞大复杂，但是千万不要被干沉默，能说清楚就是P5往上 按抽象概念分悲观锁悲观地认为数据大概率会被其他线程操作，所以具有强烈的独占性和排它性 比如synchronized，先加锁再执行...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"面试突击","slug":"面试突击","count":6,"path":"api/tags/面试突击.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}