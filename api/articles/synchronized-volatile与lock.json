{"title":"synchronized,volatile与lock","uid":"2b0f61f6bf7b985f1f4587a53651bb18","slug":"synchronized-volatile与lock","date":"2022-10-20T06:09:39.000Z","updated":"2022-10-31T06:16:33.398Z","comments":true,"path":"api/articles/synchronized-volatile与lock.json","keywords":null,"cover":[],"content":"<h1 id=\"Synchronized\"><a href=\"#Synchronized\" class=\"headerlink\" title=\"Synchronized\"></a>Synchronized</h1><p>同步锁，保证在同一时刻，被修饰的代码块或方法只有一个线程执行，以达到并发安全的效果</p>\n<p>同步锁是解决并发问题最简单的一种方法，直接给代码块加上此关键字即可</p>\n<p>在JDK1.5之前，Synchronized是一个重量级锁，在以后的版本经过改进后成重量级减小</p>\n<p>synchronized的作用主要有三个：</p>\n<ol>\n<li><strong>原子性</strong>：确保线程<strong>互斥</strong>地访问同步代码；</li>\n<li><strong>可见性</strong>：保证共享变量的修改能够及时可见，其实是通过Java内存模型中的“<strong>对一个变量unlock操作之前，必须要同步到主内存中</strong>；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值” 来保证的；</li>\n<li><strong>有序性</strong>：有效解决重排序问题，即 “一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”；</li>\n</ol>\n<h2 id=\"底层实现：\"><a href=\"#底层实现：\" class=\"headerlink\" title=\"底层实现：\"></a>底层实现：</h2><p>对象在JVM的内存布局为：对象头+实例数据+对齐填充</p>\n<h3 id=\"对象头（12字节）\"><a href=\"#对象头（12字节）\" class=\"headerlink\" title=\"对象头（12字节）\"></a>对象头（12字节）</h3><p>其中有4字节的class pointer和8字节的MarkWord</p>\n<p>后者是实现锁的关键，MarkWord被设计成一个非固定的数据，它会根据对象的状态复用自身的空间，即会随着程序的运行发生变化。MarkWord的最后三字节分别为：<strong>1bit记录是否为偏向锁</strong>；<strong>2bit记录锁标志位。</strong>当锁标志位变为00时为轻量级锁，01代表未锁定或者可加偏向锁，10时为重量级锁。</p>\n<h3 id=\"Monitor对象\"><a href=\"#Monitor对象\" class=\"headerlink\" title=\"Monitor对象\"></a>Monitor对象</h3><p>如果使用Synchronize修饰了一个对象，则MarkWord就会指向一个唯一的Monitor对象，并将标志位改为10，由操作系统提供</p>\n<p>Monitor中有三个变量，分别是Owner、EntryList和WaitSet</p>\n<p>Owner：当线程抢占到锁后，Owner就会指向该线程</p>\n<p>EntryList：当其他线程以自旋形式抢占Owner超过阈值后，便会进入阻塞状态，放入EntryList，等待被唤醒</p>\n<h3 id=\"具体步骤\"><a href=\"#具体步骤\" class=\"headerlink\" title=\"具体步骤\"></a>具体步骤</h3><ol>\n<li>thread0执行synchronize代码的时候，synchronized(obj)的obj对象的markword中ptr_to_heavyweight_monitor（指向monitor的指针）会指向一个monitor对象，执行cas操作将monitor的owner设置为thread0。<strong>在字节码中对应monitorenter操作指令</strong></li>\n<li>thread1执行到synchronized代码时,发现obj的markword指向了一个monitor并且owner不为null 并且不为抢锁线程,这时会进入entrylist进行blocked，thread2也一样</li>\n<li>thread0执行完同步代码退出synchronized，把obj markword里的数据还原比如hashcode，这些数据是存在monitor对象中的，然后根据不同的策略去唤醒entrylist的thread1和thread2的blocked线程，两个线程去抢owner。<strong>在字节码中对应monitorexit操作指令</strong></li>\n</ol>\n<h3 id=\"偏向锁：\"><a href=\"#偏向锁：\" class=\"headerlink\" title=\"偏向锁：\"></a>偏向锁：</h3><p>当一个线程访问加了同步锁的代码块时，<strong>会在对象头中存储当前线程的 ID</strong>，<strong>后续这个线程进入和退出这段加了同步锁的代码块时，不需要再次加锁和释放锁</strong>。而是直接比较对象头里面是否存储了指向当前线程的偏向锁。如果相等表示偏向锁是偏向于当前线程的，就不需要再尝试获得锁了。</p>\n<p>说白了就是消除无竞争情况下的性能消耗，避免一个线程的情况下也去竞争锁，造成浪费资源。</p>\n<p>底层实现原理：</p>\n<ol>\n<li>首先获取锁 对象的 MarkWord，判断是否处于可偏向状态。偏向锁状态位0，锁标志01</li>\n<li>如果是可偏向状态，则通过 CAS 操作，把当前线程的 ID 写入到 MarkWord<br>a) 如果 CAS 成功，那么 MarkWord就会记录当前线程的ID。 表示已经获得了锁对象的偏向锁，接着执行同步代码块<br>b) 如果 CAS 失败，说明有其他线程已经获得了偏向锁，这种情况说明当前锁存在竞争，需要撤销已获得偏向锁的线程，并且把它持有的锁升级为轻量级锁（这个操作需要等到全局安全点，也就是没有线程在执行字节码）才能执行</li>\n<li>如果是已偏向状态，需要检查 MarkWord 中存储的<br>线程ID 是否等于当前线程的 线程ID<br>a) 如果相等，不需要再次获得锁，可直接执行同步代码块<br>b) 如果不相等，说明当前锁偏向于其他线程，需要撤销偏向锁并升级到轻量级锁</li>\n</ol>\n<h3 id=\"轻量级锁：\"><a href=\"#轻量级锁：\" class=\"headerlink\" title=\"轻量级锁：\"></a>轻量级锁：</h3><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建 一个LockRecord</p>\n<p>然后线程尝试使用CAS将对象头中的MarkWord替换为指向锁记录的指针(即00)，官方称为Displaced Mark Word，谁成功将LockRecord贴上去了，谁就拿到锁了。</p>\n<p>如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p>\n<p>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。</p>\n<p>轻量级锁不进行阻塞，而是使用自旋的方式，自旋虽然提升了响应速度，但是会增大CPU的消耗</p>\n<h3 id=\"重量级锁：\"><a href=\"#重量级锁：\" class=\"headerlink\" title=\"重量级锁：\"></a>重量级锁：</h3><p>当竞争加剧，比如自旋次数超过某一阈值，就会升级为重量级锁，JDK1.6之前，需要自己进行调优设置自旋阈值，需要参考CPU核数。而以后的版本加入了自适应自旋，由JVM自动控制。</p>\n<p>此时需要向操作系统申请资源，申请mutex，将MarkWord替换为指向mutex的指针，拿到重量级锁</p>\n<p>其他线程进入阻塞队列，等待OS的调度，wait状态的线程不消耗cpu</p>\n<p>阻塞线程需要cpu从用户态转到内核态，代价比较大。而且可能会出现刚阻塞不久，锁就被释放的情况，所以阻塞的方式会降低响应速度</p>\n<p>锁会随着线程的竞争情况逐渐升级，偏向锁 &#x3D;&gt; 轻量级锁 &#x3D;&gt; 重量级锁 。锁可以升级但是不能降级。升级的目的是为了提高获得锁和释放锁的效率。</p>\n<h1 id=\"Volatile\"><a href=\"#Volatile\" class=\"headerlink\" title=\"Volatile\"></a>Volatile</h1><p>Volatile关键字的作用主要有如下两个：</p>\n<ol>\n<li>线程的可见性：当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。</li>\n<li>顺序一致性：禁止指令重排序</li>\n</ol>\n<p>Volatile和synchronized的区别</p>\n<ol>\n<li>Volatile是轻量级的synchronized，因为它不会引起上下文的切换和调度，所以Volatile性能更好。</li>\n<li>Volatile只能修饰变量，synchronized可以修饰方法，静态方法，代码块，类。</li>\n<li>volatile仅能实现变量的修改可见性，并不能保证原子性，synchronized则可以保证原子性。</li>\n<li>多线程访问volatile不会发生阻塞，而synchronized会发生阻塞。</li>\n<li>volatile是变量在多线程之间的可见性，synchronize是多线程之间访问资源的同步性。</li>\n</ol>\n<h2 id=\"如何保证线程的可见性\"><a href=\"#如何保证线程的可见性\" class=\"headerlink\" title=\"如何保证线程的可见性\"></a>如何保证线程的可见性</h2><h4 id=\"JAVA的内存模型\"><a href=\"#JAVA的内存模型\" class=\"headerlink\" title=\"JAVA的内存模型\"></a>JAVA的内存模型</h4><p>线程之间的共享变量存储在主内存中，而每一个线程都有一个私有的本地内存，local memory存储了该线程读写的共享变量的副本。所以当一个线程在本地内存更新共享变量的副本后，需要重新写入主内存。</p>\n<p>如何将新值刷新到主内存中：</p>\n<p><strong>CPU寄存器-&gt;Cache-&gt;Main memory</strong>，写缓冲区可以避免处理器停顿下来等待写入数据而造成的延迟，并且写缓冲区可以合并多次写，减少对内存总线的占用。</p>\n<p>但是在写入主内存之前，另外一个线程是看不到的，所以就需要volatile关键则来保证可见性</p>\n<p>当线程对volatile修饰的变量进行写操作时，汇编指令会多出一个lock前缀，这就是<strong>内存屏障</strong>，而在多核心环境下，这个前缀会对应两个操作：</p>\n<ol>\n<li>将当前缓存行的数据<strong>立即</strong>写回系统内存</li>\n<li>这个写回内存的操作会使其他cpu里缓存的副本无效化</li>\n</ol>\n<p>这就是缓存一致性协议，每个处理器通过嗅探在总线传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，从而需要重新从系统内存中读取数据。</p>\n<p>所以多核心环境下，每一个线程读取被volatile修饰的变量时，都必须在主内存中读取最新的结果，而不是使用local memory内的数据，这样保证了一个线程修改变量的结果其他线程都是可知的，保证了线程的可见性。</p>\n<h2 id=\"如何禁止指令重排\"><a href=\"#如何禁止指令重排\" class=\"headerlink\" title=\"如何禁止指令重排\"></a>如何禁止指令重排</h2><p>同样依赖于lock前缀，即内存屏障实现</p>\n<p>编译器不会对volatile读与volatile读后面的任意内存操作重排序；</p>\n<p>编译器不会对volatile写与volatile写前面的任意内存操作重排序。</p>\n<p><img src=\"/../img/volatile1.png\" alt=\"volatile1\"></p>\n<p><img src=\"/../img/volatile2.png\" alt=\"volatile2\"></p>\n<h1 id=\"Lock\"><a href=\"#Lock\" class=\"headerlink\" title=\"Lock\"></a>Lock</h1><p>synchronized存在一些问题：</p>\n<ol>\n<li><p>NonfairSync：加入持有锁的线程因为等待长时间IO或者其他原因，其他等待的线程无法响应中断，只能不断等待</p>\n<p><code>公平锁即尽量以请求锁的顺序来获取锁。比如同时有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该锁。</code></p>\n<p><code>非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。</code></p>\n</li>\n<li><p>synchronize是悲观锁，独占性很强，对读和写操作均是独占的</p>\n</li>\n<li><p>使用synchronized关键字无法确认线程是否成功获取到锁</p>\n</li>\n</ol>\n<h2 id=\"异常是否释放\"><a href=\"#异常是否释放\" class=\"headerlink\" title=\"异常是否释放\"></a>异常是否释放</h2><p>synchronized关键字在发生异常时会自动释放占有的锁，因此不会出现死锁；而lock发生异常的时候，必须手动unlock来释放锁，可能会引起死锁。解决方式：try catch包裹代码块，finally中写入unlock</p>\n<h2 id=\"是否响应中断\"><a href=\"#是否响应中断\" class=\"headerlink\" title=\"是否响应中断\"></a>是否响应中断</h2><p>lock可以用interrupt来中断等待，而synchronized只能不断等待锁的释放，不能响应中断</p>\n<h2 id=\"是否知道获取锁\"><a href=\"#是否知道获取锁\" class=\"headerlink\" title=\"是否知道获取锁\"></a>是否知道获取锁</h2><p>lock可以通过trylock来知道有没有获取锁，而synchronized不能</p>\n<h2 id=\"两者的异同\"><a href=\"#两者的异同\" class=\"headerlink\" title=\"两者的异同\"></a>两者的异同</h2><ol>\n<li>在JDK1.5之前lock的性能优于synchronized，以后的版本，在不断优化降低锁的重量级后，两者的性能差距缩小。</li>\n<li>lock是一个接口，而synchronized是一个关键字</li>\n<li>lock可以有多个获取锁的方式，可以不用一直等待。而synchronized只能等待</li>\n<li>Lock适合用于大量线程的同步，且大量线程竞争激烈时，lock的性能更优，lock锁还能使用readwritelock实现读写分离，提高多线程的读操作效率。</li>\n<li>lock可以实现公平锁与非公平锁，synchronized只能实现非公平锁</li>\n</ol>\n<h1 id=\"AQS\"><a href=\"#AQS\" class=\"headerlink\" title=\"AQS\"></a>AQS</h1><p>即AbstractQueuedSynchronizer类，抽象队列同步器，AQS是JUC的基类</p>\n<p>基于 volitile修饰的状态记录量<strong>state</strong>+Node对象构建的双向链表，先进先出，也就是队列</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//node类携带的信号量</span>\n<span class=\"token comment\">//排他锁标识</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> node <span class=\"token constant\">EXCLUSIVE</span> <span class=\"token operator\">=</span>  <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//后继节点需要被唤醒</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token constant\">SIGNAL</span>    <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//该节点已失效</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token constant\">CANCELLED</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//只有上一个节点是的ws为SIGNAL，当前节点才有可能被上一个节点唤醒</span>\n<span class=\"token keyword\">volatile</span> <span class=\"token keyword\">int</span> waitStatus<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"加锁（非公平为例）\"><a href=\"#加锁（非公平为例）\" class=\"headerlink\" title=\"加锁（非公平为例）\"></a>加锁（非公平为例）</h3><p>当调用lock()时，线程会尝试使用CAS的方式将state从0改变为1，返回true则证明成功拿到锁，将ExclusiveOwnerThread指向当前线程。若为重入，则会增加state的值。</p>\n<p>拿锁失败则会被放入队列。若队列为空，则会建立一个空节点作为哨兵，然后将此节点放在哨兵后。队列中的线程会acquireQueued()，内部由一个死循环实现，自旋地，独占且不可中断的方式获取同步状态，位于第二个节点的线程才有资格抢占锁，抢占后将晋升为头节点，原先的头节点会等待被GC。</p>\n<p>若获取锁失败或无资格获取锁，则会则根据前驱节点的waitStatus决定是否需要挂起线程，若为SIGNAL，则当前节点被安全阻塞。</p>\n<p>若为CANCELLED，则会向前查找到为SIGNAL的节点，并重新设置前驱节点，相当于是剔除了失效节点。</p>\n<p>若为0或者其他状态，通过CAS的方式设置为SIGNAL</p>\n<h3 id=\"锁的释放\"><a href=\"#锁的释放\" class=\"headerlink\" title=\"锁的释放\"></a>锁的释放</h3><p>release(int arg)，先检测state，若state减一后仍不为0，则代表有重入，返回false，等待下一次的释放。</p>\n<p>当state为0时，才会进行unpark()，即释放锁</p>\n<p>unparkSuccessor()，传入head节点，检测到后继节点中第一个waitStatus为-1的节点，并解除挂起状态</p>\n<h1 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h1><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ReentrantLock</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Lock</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>互斥锁，可重入锁，也是可以实现公平锁和非公平锁（默认）的一种锁。内部包含一个AQS对象，并基于AQS实现</p>\n<p>NonfairSync：非公平锁无论是队列里，还是外来线程，都会通过CAS直接尝试获取锁，能抢到锁到直接占有锁，抢不到才会到等待队列的队尾等待。</p>\n<p>fairSync：公平锁则是所有线程并发进入acquire方法，通过hasQueuedPredecessors方法来严格控制队列获取锁的顺序，外来线程无法参与竞争。</p>\n<p><img src=\"/../img/reentrantLock.png\" alt=\"reentrantLock\"></p>\n<p>ReentrantLock内部有三个类</p>\n<p><img src=\"/../img/reentrantLock1.png\" alt=\"reentrantLock1\"></p>\n<h1 id=\"CountDownLatch\"><a href=\"#CountDownLatch\" class=\"headerlink\" title=\"CountDownLatch\"></a>CountDownLatch</h1><p>CountDownLatch是一个倒数的计数器阀门，初始化时阀门关闭，指定计数的数量，当数量倒数减到0时阀门打开，被阻塞线程被唤醒</p>\n<p>工作方式：初始值为线程数，当线程完成自己的任务后，计数器的值就减一，当计数器为0时，表示所有线程都已完成任务。然后等待的线程就可以恢复执行。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">CountDownLatch</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> count<span class=\"token punctuation\">)</span>：构造函数，需要指定一个等于线程数的<span class=\"token keyword\">int</span>数值<span class=\"token punctuation\">;</span>\n<span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>：当前线程调用该方法会进入等待状态，直到同步器状态为<span class=\"token number\">0</span>时被其他线程唤醒或者被其他线程中断。也即将计数器减为<span class=\"token number\">0</span>返回<span class=\"token boolean\">true</span>的线程负责唤醒阻塞的线程。当计数器为<span class=\"token number\">0</span>时，调用<span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>方法将立即返回<span class=\"token punctuation\">;</span>\n<span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> timeout<span class=\"token punctuation\">,</span> <span class=\"token class-name\">TimeUnit</span> unit<span class=\"token punctuation\">)</span>：该方法与<span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>作用一样，只是添加了等待的时间，如果超过等待时间还没有被唤醒或者被中断，那么阻塞线程将退出阻塞状态<span class=\"token punctuation\">;</span>\n<span class=\"token function\">countDown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>：该方法主要是将指定的计数器减<span class=\"token number\">1</span>，当计数器已经是<span class=\"token number\">0</span>了调用该方法将会被忽略，也就是说计数器的值最小只能是<span class=\"token number\">0</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>原理：维护一个AQS，将state设置为Count数量，当state为0时，才会唤醒队列中的线程</p>\n<h1 id=\"CyclicBarrier\"><a href=\"#CyclicBarrier\" class=\"headerlink\" title=\"CyclicBarrier\"></a><strong>CyclicBarrier</strong></h1><p>CyclicBarrier是一个可循环的屏障，它允许多个线程在执行完相应的操作后彼此等待共同到达一个point，等所有线程都到达后再继续执行。比如等所有运动员都跨过第一个栅栏后，才允许继续向前。</p>\n<p>工作方式：初始值同样为线程数，当线程完成自己的任务后，计数器的值减一，若state不为0，则自身阻塞，直到state为0，即所有线程都完成任务后，才会从障碍点继续运行。</p>\n<p>CyclicBarrier是可以循环的，每个线程可以调用两次的await()方法，重复利用栅栏的计数器。调用nextGeneration()方法，唤醒所有阻塞线程，并重置count。</p>\n<p>原理：维护ReentryLock的Lock方法和Condition实现</p>\n<p>而计数器阀门则不可以循环，count为0后就不能再使用。</p>\n<h3 id=\"CyclicBarrier和CountDownLatch区别\"><a href=\"#CyclicBarrier和CountDownLatch区别\" class=\"headerlink\" title=\"CyclicBarrier和CountDownLatch区别\"></a>CyclicBarrier和CountDownLatch区别</h3><ol>\n<li>CountDownLatch的await()线程会等待计数器减为0，而执行CyclicBarrier的await()方法会使线程进入阻塞等待其他线程到达障点</li>\n<li>CountDownLatch计数器不能重置，CyclicBarrier可以重置循环利用，可以应对更多的情况，比如程序出错后重置</li>\n<li>CountDownLatch是基于AQS的共享模式实现的，CyclicBarrier是基于ReentrantLock和Condition实现的</li>\n<li>CountDownLatch会阻塞主线程，CyclicBarrier不会阻塞主线程，只会阻塞子线程</li>\n</ol>\n","text":"Synchronized同步锁，保证在同一时刻，被修饰的代码块或方法只有一个线程执行，以达到并发安全的效果 同步锁是解决并发问题最简单的一种方法，直接给代码块加上此关键字即可 在JDK1.5之前，Synchronized是一个重量级锁，在以后的版本经过改进后成重量级减小 sync...","link":"","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":12,"path":"api/tags/Java基础知识.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Synchronized\"><span class=\"toc-text\">Synchronized</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%9A\"><span class=\"toc-text\">底层实现：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E5%A4%B4%EF%BC%8812%E5%AD%97%E8%8A%82%EF%BC%89\"><span class=\"toc-text\">对象头（12字节）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Monitor%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">Monitor对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">具体步骤</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%81%8F%E5%90%91%E9%94%81%EF%BC%9A\"><span class=\"toc-text\">偏向锁：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%9A\"><span class=\"toc-text\">轻量级锁：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%9A\"><span class=\"toc-text\">重量级锁：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Volatile\"><span class=\"toc-text\">Volatile</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7\"><span class=\"toc-text\">如何保证线程的可见性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#JAVA%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">JAVA的内存模型</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92\"><span class=\"toc-text\">如何禁止指令重排</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Lock\"><span class=\"toc-text\">Lock</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%82%E5%B8%B8%E6%98%AF%E5%90%A6%E9%87%8A%E6%94%BE\"><span class=\"toc-text\">异常是否释放</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%98%AF%E5%90%A6%E5%93%8D%E5%BA%94%E4%B8%AD%E6%96%AD\"><span class=\"toc-text\">是否响应中断</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%98%AF%E5%90%A6%E7%9F%A5%E9%81%93%E8%8E%B7%E5%8F%96%E9%94%81\"><span class=\"toc-text\">是否知道获取锁</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%A4%E8%80%85%E7%9A%84%E5%BC%82%E5%90%8C\"><span class=\"toc-text\">两者的异同</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#AQS\"><span class=\"toc-text\">AQS</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%A0%E9%94%81%EF%BC%88%E9%9D%9E%E5%85%AC%E5%B9%B3%E4%B8%BA%E4%BE%8B%EF%BC%89\"><span class=\"toc-text\">加锁（非公平为例）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%94%81%E7%9A%84%E9%87%8A%E6%94%BE\"><span class=\"toc-text\">锁的释放</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ReentrantLock\"><span class=\"toc-text\">ReentrantLock</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#CountDownLatch\"><span class=\"toc-text\">CountDownLatch</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#CyclicBarrier\"><span class=\"toc-text\">CyclicBarrier</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CyclicBarrier%E5%92%8CCountDownLatch%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">CyclicBarrier和CountDownLatch区别</span></a></li></ol></li></ol></li></ol>","author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"进程，线程和协程","uid":"a81dd39014b037511fb6ceaf21738564","slug":"协程","date":"2022-10-20T08:53:01.000Z","updated":"2022-11-09T08:25:59.112Z","comments":true,"path":"api/articles/协程.json","keywords":null,"cover":[],"text":"线程的Linux实现windows操作系统的内核提供了专门支持线程的机制，而在windows中，线程也被抽象为一种比进程更轻量级的可以独立处理事件的单元 而在Linux中却不一样，从内核的角度来看，并没有线程这个概念，Linux把所有的线程都当作进程来处理，内核也并没有定义独特的...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":12,"path":"api/tags/Java基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"一篇关于锁的文章","uid":"a213144f9a961ec1d4584b73bef34320","slug":"一篇关于锁的文章","date":"2022-10-19T08:28:53.000Z","updated":"2022-10-31T06:17:36.262Z","comments":true,"path":"api/articles/一篇关于锁的文章.json","keywords":null,"cover":[],"text":"面试官：解释一下什么是乐观锁，悲观锁，自旋锁，读写锁，排它锁，共享锁，统一锁，分段锁 这种问题虽然庞大复杂，但是千万不要被干沉默，能说清楚就是P5往上 按抽象概念分悲观锁悲观地认为数据大概率会被其他线程操作，所以具有强烈的独占性和排它性 比如synchronized，先加锁再执行...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":12,"path":"api/tags/Java基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}