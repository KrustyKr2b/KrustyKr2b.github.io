{"title":"每日一问10/14/2022","uid":"91683efeeb5b4f823eb3ffc7a800c9f1","slug":"每日一问10-14-2022","date":"2022-10-14T06:56:54.000Z","updated":"2022-10-31T06:16:52.443Z","comments":true,"path":"api/articles/每日一问10-14-2022.json","keywords":null,"cover":null,"content":"<h3 id=\"Q1：接口和抽象类有哪些区别\"><a href=\"#Q1：接口和抽象类有哪些区别\" class=\"headerlink\" title=\"Q1：接口和抽象类有哪些区别\"></a>Q1：接口和抽象类有哪些区别</h3><p>答：</p>\n<p>相同点：</p>\n<ol>\n<li>不能被实例化</li>\n<li>可以将抽象类和接口类型作为引用类型</li>\n<li>一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部实现</li>\n</ol>\n<p>不同点：</p>\n<ol>\n<li>抽象类中可以定义构造器，可以有抽象方法和具体方法，抽象类中可以定义成员变量，一个类只能继承一个抽象类，抽象类中可以包含静态方法，抽象类中的成员可以由private,protected,public修饰</li>\n<li>接口中的成员全部都是由public修饰，不能定义构造器，只能有抽象方法，不能有静态方法，一个类可以实现多个接口</li>\n</ol>\n<p>除了语法上的异同之外，两者还有语义上的不同。抽象类适合描述某一更具体的概念，比如狗<strong>是</strong>一种<strong>动物</strong>，而不能说狗<strong>实现</strong>了动物的<strong>接口</strong>。接口则用于描述多个事物的共同特征，比如鸟<strong>实现了</strong>flyable接口，这个flyable就是一种<strong>行为特征</strong>，当然也可以描述其他的特征。</p>\n<h3 id=\"Q2：HashCode-和equals-的关系，如何使用？\"><a href=\"#Q2：HashCode-和equals-的关系，如何使用？\" class=\"headerlink\" title=\"Q2：HashCode()和equals()的关系，如何使用？\"></a>Q2：HashCode()和equals()的关系，如何使用？</h3><p>答：</p>\n<ol>\n<li>equals()来自Object()类，默认使用&#x3D;&#x3D;来比较地址值，判断引用指向是否是一个对象。通过重写该方法来定义新的规则，比如String类中的equals方法就是逐个比较字符串的字符</li>\n<li>HashCode()来自Object()类，这是一个本地方法，在没有被重写时默认返回对象在堆内存上的独特值，可以认为是对象在堆内存中的身份证号，具有唯一性。重写HashCode后，可以返回计算而出的哈希值，即散列算法，用于确定元素的桶位置，例如HashMap</li>\n<li>如何使用：查找一个元素，当调用散列算法后，快速定位到相应位置，若该桶内有元素，则调用equals()，由于哈希碰撞的存在，HashCode()相等时，不一定就是相应的元素，所以必须调用equals()来判断是否为要查找的元素</li>\n</ol>\n<h3 id=\"Q3：-x3D-x3D-和equals的区别\"><a href=\"#Q3：-x3D-x3D-和equals的区别\" class=\"headerlink\" title=\"Q3：&#x3D;&#x3D;和equals的区别\"></a>Q3：&#x3D;&#x3D;和equals的区别</h3><p>答：</p>\n<p>&#x3D;&#x3D;：若比较的是基本数据类型，则比较的是数值是否相等；如果比较的是引用数据类型，则比较的是地址值</p>\n<p>equals()：用来比较引用指向的对象地址是否相等。不可用于基本数据类型的比较。</p>\n<p>在Object类中，equals就是由&#x3D;&#x3D;来实现的，可以认为equals在被重写前，两者作用是相等的</p>\n<h3 id=\"Q4：HashMap为什么是线程不安全的\"><a href=\"#Q4：HashMap为什么是线程不安全的\" class=\"headerlink\" title=\"Q4：HashMap为什么是线程不安全的\"></a>Q4：HashMap为什么是线程不安全的</h3><p>答：</p>\n<p>JAVA7可能造成死循环：由于resize时的数据迁移采用头插法（当时的人觉得比较高效），而头插法会导致链表顺序颠倒（因为先插入的元素在后面），当线程A未完成transfer操作时被挂起，而线程B成功完成了transfer操作，线程A再次获取时间片后继续执行transfer，由于头插法导致链表顺序颠倒，便有可能导致生成环形链表。</p>\n<p>JAVA8可能造成数据丢失：假设两个线程A、B都在进行put操作，并且hash函数计算出的插入下标是相同的，当线程A执行过程中由于时间片耗尽导致被挂起，而线程B得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程A获得时间片，由于之前已经进行了hash碰撞的判断，所有此时不会再进行判断，而是直接进行插入，这就导致了线程B插入的数据被线程A覆盖了，从而线程不安全。</p>\n","text":"Q1：接口和抽象类有哪些区别答： 相同点： 不能被实例化 可以将抽象类和接口类型作为引用类型 一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部实现 不同点： 抽象类中可以定义构造器，可以有抽象方法和具体方法，抽象类中可以定义成员变量，一个类只能继承一个抽象类...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":12,"path":"api/tags/Java基础知识.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Q1%EF%BC%9A%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">Q1：接口和抽象类有哪些区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Q2%EF%BC%9AHashCode-%E5%92%8Cequals-%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F\"><span class=\"toc-text\">Q2：HashCode()和equals()的关系，如何使用？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Q3%EF%BC%9A-x3D-x3D-%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">Q3：&#x3D;&#x3D;和equals的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Q4%EF%BC%9AHashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84\"><span class=\"toc-text\">Q4：HashMap为什么是线程不安全的</span></a></li></ol>","author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"子序列数目","uid":"22f311f06a9cae50742dc4cb95ef15a1","slug":"子序列数目","date":"2022-10-14T14:28:37.000Z","updated":"2022-10-14T14:34:26.115Z","comments":true,"path":"api/articles/子序列数目.json","keywords":null,"cover":null,"text":"输入：s &#x3D; &quot;abc&quot; 输出：7 解释：7 个不同的子序列分别是 &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;ab&quot;, &quot;ac&quot;, &quot;bc&quot;...","link":"","photos":[],"count_time":{"symbolsCount":762,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"LeetCode初见","slug":"LeetCode初见","count":8,"path":"api/tags/LeetCode初见.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"每日一问10/13/2022","uid":"cfe019c4b3b720ab570d0b0eea78733d","slug":"每日一问10-13-2022","date":"2022-10-13T12:41:31.000Z","updated":"2022-10-31T06:16:43.604Z","comments":true,"path":"api/articles/每日一问10-13-2022.json","keywords":null,"cover":null,"text":"Q1：Object o = new Object()在内存中占用多少个字节？答： 一个对象在内存中的存储布局：markword：8字节，锁信息+HashCode+GC信息；classPointer:4字节；对齐：保证大小能被8整除；数据段：即对象内声明的变量 所以一个空对象最小为...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":12,"path":"api/tags/Java基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}