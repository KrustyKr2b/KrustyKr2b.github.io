{"title":"Redis随想","uid":"2181d0c3b44c85661e4d1e16727307c2","slug":"Redis随想","date":"2022-09-24T05:45:16.000Z","updated":"2022-10-13T08:14:13.391Z","comments":true,"path":"api/articles/Redis随想.json","keywords":null,"cover":null,"content":"<h1 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h1><h2 id=\"SDS结构模型\"><a href=\"#SDS结构模型\" class=\"headerlink\" title=\"SDS结构模型\"></a>SDS结构模型</h2><p>基于C语言，由Redis封装的一种简单高效安全的数据结构</p>\n<h3 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h3><p>SDS的底层实现思路其实十分简单</p>\n<ol>\n<li>无符号变量len：记录字符串的长度</li>\n<li>无符号变量free：记录空闲内存的大小</li>\n<li>char型数组buf：存储字符</li>\n</ol>\n<p>其中：buf尾部会自动追加一个空字符，遵循了c语言原生字符串的规范，并且SDS的指针也不是指向起始位置，而是指向buf，使得SDS可以直接使用一部分库函数。</p>\n<p>SDS取消了字节对齐，使得指针移动一位便可以读取到header里的信息。如果没有取消，这个移动的位数是未知的，就无法兼容C语言的库函数了，指针操作也要麻烦很多。</p>\n<h3 id=\"数据结构优化：\"><a href=\"#数据结构优化：\" class=\"headerlink\" title=\"数据结构优化：\"></a>数据结构优化：</h3><p>如果一个字符串非常短，但是记录信息的头部却占用了更多的空间，这未免有一些浪费，所以SDS会分为五种类型</p>\n<ol>\n<li>短字符串：小于32，用一个char类型的flag变量来记录长度，低三位存储类型，高三位存储长度</li>\n<li>短字符串：用一字节的char来记录长度，一字节的flag来记录类型</li>\n<li>长字符串：用2字节的short来记录长度，1字节的flag来记录类型</li>\n<li>长字符串：用4字节的int来记录长度</li>\n<li>超长字符串：用8字节的long来记录字符串</li>\n</ol>\n<p>SDS的最大长度：在3.X版本中，因为数据结构中的len属性是由int来修饰的，所以buf的最大长度就是214783647，即512MB</p>\n<p>但是在6.x版本后，长度就更多样了</p>\n<h3 id=\"SDS相比原生string的优势：\"><a href=\"#SDS相比原生string的优势：\" class=\"headerlink\" title=\"SDS相比原生string的优势：\"></a>SDS相比原生string的优势：</h3><ol>\n<li>O(1)时间复杂度获取字符串的长度：因为C语言原生基本数据类型不记录自身长度，当要计算一个字符串的长度必须遍历整个字符串，直到遇到空字符为止，时间复杂度O(n)，而使用SDS则直接获取len属性即可，时间复杂度为O(1)</li>\n<li>二进制安全：在C语言中，用空字符表示字符串的结束，若字符串本身就包含空字符，那么遇到便会截断，即非二进制安全。与其相对的便是二进制安全，SDS使用len属性来判断字符串是否结束，不会受到空字符影响。</li>\n<li>杜绝缓冲区溢出：在C语言中，在对字符串进行拼接操作时，若没有给字符串分配足够的内存，那么就可能产生缓冲区溢出，把其他数据覆盖掉。而SDS的自动扩容机制杜绝了溢出，<code>sdsMakeRoomFor</code>方法：参数：原字符串，待加入的字符串。若空闲空间大于待拼接字符串的长度，则无需扩容；若拼接后的长度小于1M，则直接扩容至新长度的两倍；若拼接后的长度大于1M，则扩容至新长度+1M；扩容后检查类型，若发生变化，则需要为SDS重新分配内存（header的大小也改变了）</li>\n<li>优化的内存分配策略：预分配：扩容后的SDS不会恰好容下新字符串，而是多分配了一些空间，从而减少修改字符串时带来的内存重分配次数；惰性空间释放机制：当缩短字符串时，不会立刻回收空余的空间，而是仅仅更新len属性，空余空间供将来使用，减少内存分配频率，当然Redis也提供了释放未使用空间的方法<code>sdsRemoveFreeSpace</code></li>\n</ol>\n<h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><p>Redis 的列表相当于 Java 语言里面的 LinkedList，这意味着List的插入和删除操作非常块，但是索引定位就比较慢了</p>\n<p>List支持先进先出（lpop）先进后出（rpop）</p>\n<p>List有两种实现方式：压缩列表和双向循环链表</p>\n<h4 id=\"ziplist\"><a href=\"#ziplist\" class=\"headerlink\" title=\"ziplist\"></a><code>ziplist</code></h4><p>节点的数据小于64字节，数据个数小于512个</p>\n<p>一般的数组都要求每一格的元素大小相同，但是若要存储不同大小的字符串，就需要以最大长度来作为元素大小，会造成一定程度的浪费。而压缩列表就是将元素紧凑，但是会在每个元素的头部追加一个len属性，这样就能很容易计算出下一个元素的内存地址。</p>\n<h4 id=\"双向链表\"><a href=\"#双向链表\" class=\"headerlink\" title=\"双向链表\"></a>双向链表</h4><p>和<code>linkedlist</code>很相似，可以处理数据量较大的情况，每个节点包含value和前驱，后继节点的指针</p>\n<h2 id=\"Hash\"><a href=\"#Hash\" class=\"headerlink\" title=\"Hash\"></a>Hash</h2><p>和JAVA里的hashmap类似，都是无序的键值对集合。</p>\n<p>hash也有两种实现方式，当数据量小的时候，使用压缩列表，当数据量大的时候，使用散列表。</p>\n<p>hash的底层和hashmap也差不多，都是数组+链表的二维结构，但是hash只能存储字符串，并且rehash的方式也不一样，redis为了保证高性能，采用渐进式的rehash方法，即在不断输入的任务以及hash操作中一步步将旧结构里的内容迁移到新结构中</p>\n<h2 id=\"SET\"><a href=\"#SET\" class=\"headerlink\" title=\"SET\"></a>SET</h2><p>集合，存储一组不重复的数据，同样两种实现方法：有序数组（只用于处理整数）和散列表。前者是处理较少的数据，后者是处理大量数据。</p>\n<h2 id=\"Redis的持久化\"><a href=\"#Redis的持久化\" class=\"headerlink\" title=\"Redis的持久化\"></a>Redis的持久化</h2><p>因为redis的数据是在内存里，一旦断电或者宕机，数据便会丢失，所以必须保证数据不会因为故障而丢失</p>\n<h5 id=\"RDB-redis-database\"><a href=\"#RDB-redis-database\" class=\"headerlink\" title=\"RDB(redis database)\"></a>RDB(redis database)</h5><p>即快照，在指定的时间间隔内将内存中的所有数据集快照写入磁盘</p>\n<p>Redis会单独创建fork一个子进程来进行持久化，依靠操作系统的COW机制（写入时复制，在client没有对数据进行写入时，子进程和主进程通过指针共享一个物理页面，当client对数据进行写入修改时，OS才会为页面创建副本，子进程将副本数据写入RDB，而这个过程仍然不影响主进程对数据的修改），fork进程内部的数据便是整个数据库的一个快照。当子进程完成对新RDB文件的写入时，便会拿其替换原来的RDB文件。</p>\n<p><code>fork 的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。 子进程读取数据，然后序列化写到磁盘中。</code></p>\n<p>RDB是对整个内存的数据进行快照，所以只有一个文件，这种方法适合大规模的数据恢复，而且很方便，因为OS只需要fork一个子进程，服务进程无需进行其他的IO操作，最大化保障redis的性能。</p>\n<p>但是RDB也有一些缺点：最后一次快照无法及时写入内存，可能会发生丢失，因为是由fork子进程来完成持久化，相当于克隆了一份内存数据，当数据集较大时，可能会影响整个服务器的性能。</p>\n<h5 id=\"AOF-Append-Only-File\"><a href=\"#AOF-Append-Only-File\" class=\"headerlink\" title=\"AOF(Append Only File)\"></a>AOF(Append Only File)</h5><p>以日志的形式来记录写操作，只记录写指令，恢复时只需从前往后执行一遍即可完成数据恢复的工作。</p>\n<p>记录方式：写后日志：即在数据写入内存后再记录日志，让操作系统先执行命令，只有命令执行成功才能被记录，这种方式排除了错误的指令，并且不会阻塞当前的写操作。</p>\n<p>风险：若写入数据后未来得及记录日志便宕机，就会造成数据丢失。虽然避免了当前命令的阻塞，但是会给下一个操作带来阻塞 的风险，因为AOF日志是在主线程中进行的，写入磁盘时，磁盘的写压力大，可能会造成后序操作的阻塞。</p>\n<p>同步写回：每个操作完成后写回，会影响性能，但是可靠性高</p>\n<p>每秒写回：即每秒进行一次写回，性能适中，但是可能会丢失这一秒内的数据</p>\n<p>操作系统控制的写回：每个写完命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时写回磁盘。性能好，但是宕机时丢失的数据多</p>\n<h2 id=\"Redis的事务\"><a href=\"#Redis的事务\" class=\"headerlink\" title=\"Redis的事务\"></a>Redis的事务</h2><p>redis是不支持回滚的：由程序员自行纠正编程错误，无回滚的方式保证了内部的简单快速</p>\n<p>以MULTI开始一个事务，将多个命令入队，入队后不会立即执行，而是放置在等待执行的队列里，由EXEC触发事务</p>\n<p>所有命令都会被序列化，顺序执行，执行过程中不会被其他客户端的命令打断</p>\n<p>在提交之前所有命令都不会被执行</p>\n<p>不保证原子性：有一条命令失败，其他的命令仍然会进行，没有回滚</p>\n<h1 id=\"MYSQL\"><a href=\"#MYSQL\" class=\"headerlink\" title=\"MYSQL\"></a>MYSQL</h1><p>关系型数据库，插件式的存储引擎，这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p>\n<ol>\n<li>客户端通过协议与服务器连接，发送查询语句，先检查缓存是否命中，若命中直接返回，否则进行语句解析</li>\n<li>预处理，检查语句是否有语法错误，查询优化（是否会使用索引扫描），生成查询计划，启动查询引擎，开始查询，底层存储引擎调用API获取数据，返回给客户端</li>\n<li>MYSQL默认使用B树索引</li>\n</ol>\n<h2 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h2><p>索引的本质就是一个满足某种查找算法的数据结构，常见的有BST，AVL，红黑树，Btree，B+树等等</p>\n<p>这些结构以某种方式指向数据（索引结点指向数据记录物理地址的指针）</p>\n<ol>\n<li>索引大大减少了服务器需要扫描的数据量，提高了检索效率</li>\n<li>避免排序，减少CPU消耗</li>\n<li>将随机IO转换为顺序IO</li>\n</ol>\n<p>索引也是一张表，保存了主键和索引，指向了实体表，也需要占用内存。索引存储于外存，所以索引的查询也需要磁盘IO开销</p>\n<p>虽然提高了查询速度，但是在对实体表进行更新时，索引也需要进行相应的维护更新，而索引的维护也需要开销，降低了更新表的速度</p>\n<p>HASH索引：等值查询很快，计算的hash值与对应的行指针一并存入表中，哈希碰撞的元素以链表的形式相连。但是不支持范围查询，也不支持排序。所以应用场景少。</p>\n<h3 id=\"B树\"><a href=\"#B树\" class=\"headerlink\" title=\"B树\"></a>B树</h3><p>考虑到IO时十分高昂的操作，且数据库动辄百万级数据量，所以当一次IO时，常常以页作为单位来读取数据，当读取一页的数据至内存缓冲区时，实际上才发生了一次IO，所以控制IO的次数对于索引效率的提升，至关重要。</p>\n<p>B+树的特点：</p>\n<ol>\n<li>除叶子结点外的子节点：只起到索引的作用，仅存储指针，不存储信息</li>\n<li>所有信息存储于叶子结点，所有叶子结点在底部链接形成一个线性链表</li>\n</ol>\n<p>MYSQL默认使用B+树：为啥要用B+树，不用B树</p>\n<p>因为两者都是存储于磁盘，而IO是花销很大的操作，innoDB每次申请磁盘空间时都会申请若干条连续的磁盘块来组成一页，并放入内存，读取索引，放回磁盘，不断重复，直到找到数据。所以如果每次申请到的数据都能有助于定位到所需数据，这将会减少IO次数，提高查询效率。</p>\n<p>对于B树，因为B树的每一个结点都会存储键和数据，每个结点的信息存储能力有限，树的高度也会更高，增加了IO次数。而B+树的非叶子结点只存储键，所以B+树的非叶子结点可以存储更多的信息，降低了树高度，平均一次IO可以获取更多索引，所以B+树更适合外存索引。其中在 MySQL 底层对 B+ 树进行进一步优化：<strong>叶子节之间是双向链表，节点内部是单向链表，且在链表的头结点和尾节点也是循环指向的</strong>。</p>\n<h2 id=\"跳表skipList\"><a href=\"#跳表skipList\" class=\"headerlink\" title=\"跳表skipList\"></a>跳表skipList</h2><p>跳表是可以实现二分查找的有序链表，常用于redis的有序集合数据结构</p>\n<p>拥有与红黑树相近的查找，删除，插入效率，并且范围查找效率更优越</p>\n<p>原理在于为有序链表建立多级索引，从而实现跳跃查找，</p>\n<p>最底层包含所有元素，第一级索引包含1&#x2F;2的元素，以此类推。</p>\n<p>每个索引包含了一个指针数组，指向了该索引可以到达的所有节点，数组下标即当前指针所在的层数。</p>\n<p>通过生成随机数的方式，来为每一个插入的元素设定索引级数，从而无需重建整个索引，降低了时间复杂度</p>\n","text":"RedisSDS结构模型基于C语言，由Redis封装的一种简单高效安全的数据结构 源码分析SDS的底层实现思路其实十分简单 无符号变量len：记录字符串的长度 无符号变量free：记录空闲内存的大小 char型数组buf：存储字符 其中：buf尾部会自动追加一个空字符，遵循了c语...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"数据库基础知识","slug":"数据库基础知识","count":1,"path":"api/tags/数据库基础知识.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Redis\"><span class=\"toc-text\">Redis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SDS%E7%BB%93%E6%9E%84%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">SDS结构模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\"><span class=\"toc-text\">源码分析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96%EF%BC%9A\"><span class=\"toc-text\">数据结构优化：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SDS%E7%9B%B8%E6%AF%94%E5%8E%9F%E7%94%9Fstring%E7%9A%84%E4%BC%98%E5%8A%BF%EF%BC%9A\"><span class=\"toc-text\">SDS相比原生string的优势：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#List\"><span class=\"toc-text\">List</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ziplist\"><span class=\"toc-text\">ziplist</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">双向链表</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Hash\"><span class=\"toc-text\">Hash</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SET\"><span class=\"toc-text\">SET</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96\"><span class=\"toc-text\">Redis的持久化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#RDB-redis-database\"><span class=\"toc-text\">RDB(redis database)</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#AOF-Append-Only-File\"><span class=\"toc-text\">AOF(Append Only File)</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Redis%E7%9A%84%E4%BA%8B%E5%8A%A1\"><span class=\"toc-text\">Redis的事务</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#MYSQL\"><span class=\"toc-text\">MYSQL</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">索引</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#B%E6%A0%91\"><span class=\"toc-text\">B树</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B7%B3%E8%A1%A8skipList\"><span class=\"toc-text\">跳表skipList</span></a></li></ol></li></ol>","author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>大三艰苦找实习的初阶技术人</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"划分k个相等子集","uid":"8a33ad4dd9e973b50a7c9fd8c1c572f8","slug":"划分k个相等子集","date":"2022-09-27T13:57:25.000Z","updated":"2022-10-13T14:07:20.667Z","comments":true,"path":"api/articles/划分k个相等子集.json","keywords":null,"cover":null,"text":"输入： nums &#x3D; [4, 3, 2, 3, 5, 2, 1], k &#x3D; 4 输出： True 说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和 桶问题：若可以划分为k个子集，则想象有k个桶，容量均为sum&#x2F;k，...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"LeetCode初见","slug":"LeetCode初见","count":2,"path":"api/tags/LeetCode初见.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>大三艰苦找实习的初阶技术人</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"子集排列问题sucks","uid":"e0c4de6a72c616ec823d805c53472b1a","slug":"子集排列问题sucks","date":"2022-09-13T05:14:49.000Z","updated":"2022-10-13T13:40:03.754Z","comments":true,"path":"api/articles/子集排列问题sucks.json","keywords":null,"cover":null,"text":"回溯算法解决所有子集排列问题形式一：元素无重复，且不可复选，即nums中所有元素均唯一，且最多使用一次 /* 组合/子集问题回溯算法框架 */ //使用start参数来避免复选 void backtrack(int[] nums, int start) &#123; // 回溯算...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"算法归纳","slug":"算法归纳","count":2,"path":"api/tags/算法归纳.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>大三艰苦找实习的初阶技术人</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}