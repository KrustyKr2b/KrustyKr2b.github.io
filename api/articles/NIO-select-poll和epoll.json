{"title":"NIO select poll和epoll","uid":"2a1374b017f253762c103f23513f4420","slug":"NIO-select-poll和epoll","date":"2022-11-02T05:45:40.000Z","updated":"2022-11-03T11:49:56.794Z","comments":true,"path":"api/articles/NIO-select-poll和epoll.json","keywords":null,"cover":[],"content":"<h1 id=\"用户空间和内核空间\"><a href=\"#用户空间和内核空间\" class=\"headerlink\" title=\"用户空间和内核空间\"></a>用户空间和内核空间</h1><p>操作系统为了支持多个应用同时运行，需要保证不同进程之间相对独立，一个进程的崩溃不会影响其他进程，恶意进程不能读取其他进程的数据。于是内存空间被划分为两部分，<strong>内核空间和用户空间</strong>，内核空间的代码和数据拥有更高的权限，而用户空间的代码不能访问高级别的空间，因此保护了操作系统自身的内存数据。</p>\n<p><strong>用户态</strong>：指进程运行在用户地址空间中的状态，被执行的代码要受到 CPU 的很多检查。进程只能访问地址空间中规定的页面的虚拟地址。</p>\n<p><strong>内核态</strong>：指进程运行在内核地址空间中的状态，此时 CPU 可以执行任何指令。运行的代码也不受任何的限制，可以自由地访问任何有效地址，也可以直接进行端口的访问。所有系统资源的管理都是在内核态去做的，比如创建一个线程需要分配资源，就需要进入内核态，来完成。</p>\n<h2 id=\"什么是进程上下文\"><a href=\"#什么是进程上下文\" class=\"headerlink\" title=\"什么是进程上下文\"></a>什么是进程上下文</h2><p>在Linux中，用户程序装入系统形成一个进程的实质是系统为用户程序提供一个完整的运行环境</p>\n<p>进程的运行环境是由它的程序代码和程序运行所需要的数据结构以及硬件环境组成的，进程的运行环境主要包括：</p>\n<ol>\n<li>进程空间中的代码和数据、各种数据结构、进程堆栈和共享内存区等。</li>\n<li>环境变量：提供进程运行所需的环境信息。</li>\n<li>系统数据：进程空间中的对进程进行管理和控制所需的信息，包括进程任务结构体以及内核堆栈等。</li>\n<li>进程访问设备或者文件时的权限。</li>\n<li>各种硬件寄存器。</li>\n<li>地址转换信息。</li>\n</ol>\n<p>从以上组成情况可以看到，进程的运行环境是动态变化的，尤其是硬件寄存器的值以及进程控制信息是随着进程的运行而不断变化的。在Linux中把系统提供给进程的的处于<strong>动态变化的运行环境总和</strong>称为进程上下文。</p>\n<p>系统中的每一个进程都有自己的上下文。一个正在使用处理器运行的进程称为当前进程(current)。当前进程因时间片用完或者因等待某个事件而阻塞时，进程调度需要把处理器的使用权从当前进程交给另一个进程，这个过程叫做进程切换。</p>\n<p>此时，被调用进程成为当前进程。在进程切换时系统要把当前进程的上下文保存在指定的内存区域（该进程的任务状态段TSS中），然后把下一个使用处理器运行的进程的上下文设置成当前进程的上下文。</p>\n<p>当一个进程经过调度再次使用CPU运行时，系统要恢复该进程保存的上下文。所以，<strong>进程的切换也就是上下文切换</strong>。</p>\n<p>在系统内核为用户进程服务时，通常是进程通过系统调用执行内核代码，此时内核为用户进程服务，可以说内核在代替当前进程执行某种服务。所以可以认为，<strong>内核态就是内核运行在进程上下文中的状态</strong>。</p>\n<p><strong>中断上下文</strong>：硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理。所谓的“中断上下文”，其实也可以看作就是硬<strong>件传递过来的这些参数和内核需要保存的一些其他环境</strong>（主要是当前被打断执行的进程环境）</p>\n<h2 id=\"如何从用户态进入内核态：中断\"><a href=\"#如何从用户态进入内核态：中断\" class=\"headerlink\" title=\"如何从用户态进入内核态：中断\"></a>如何从用户态进入内核态：中断</h2><p>中断是CPU的一个功能：CPU停下工作后，保留现场，自动的转去执行相应的处理程序，CPU的控制权发生改变，处理完该事件后再返回断点继续执行。<strong>避免了CPU的轮询检查</strong>，而是转换为事件驱动，向CPU发送中断事件，强制让CPU来执行中断处理程序。发生中断，CPU会立即进入<strong>内核态</strong>，针对不同的中断信号，采取不同的处理方式。**中断是CPU从用户态进入核心态的唯一途径(如系统调用)**。</p>\n<h3 id=\"硬中断\"><a href=\"#硬中断\" class=\"headerlink\" title=\"硬中断\"></a>硬中断</h3><p>硬中断时由外部事件引起的，具有<strong>随机性和突发性</strong>，比如键盘，鼠标的输入，磁盘的读写，缺页。硬中断的中断号是<strong>由中断控制器提供的</strong>，硬中断是<strong>可以屏蔽</strong>掉的。</p>\n<p>流程如下</p>\n<ol>\n<li><strong>外设</strong> 将中断请求发送给中断控制器；</li>\n<li><strong>中断控制器</strong> 根据中断优先级，有序地将中断号传递给 CPU；</li>\n<li><strong>CPU</strong> 终止执行当前程序流，将 CPU 所有寄存器的数值保存到栈中；</li>\n<li><strong>CPU</strong> 根据中断号，从<strong>中断向量表</strong>中查找中断处理程序的入口地址，执行中断处理程序；</li>\n<li><strong>CPU</strong> 恢复寄存器中的数值，返回原程序流停止位置继续执行。</li>\n</ol>\n<h3 id=\"软中断（被动）\"><a href=\"#软中断（被动）\" class=\"headerlink\" title=\"软中断（被动）\"></a>软中断（被动）</h3><p>CPU的内部事件或者程序引起的中断，如程序故障，电压故障。</p>\n<h3 id=\"软中断（主动）\"><a href=\"#软中断（主动）\" class=\"headerlink\" title=\"软中断（主动）\"></a>软中断（主动）</h3><p>也称作<strong>系统调用</strong>，用户进程<strong>主动要求</strong>进入内核态。用户进程通过系统调用申请操作系统提供服务。</p>\n<p> 系统调用使用的是一个特别的中断实现的。具体是:调用 int $<strong>0x80</strong>的汇编指令，将产生向量为0x80的编程异常（软中断）</p>\n<p>软中断模拟了硬中断的处理过程：</p>\n<ol>\n<li>无</li>\n<li>无</li>\n<li><strong>CPU</strong> 终止执行当前程序流，将 CPU 所有寄存器的数值保存到栈中；</li>\n<li><strong>CPU</strong> 根据中断向量，从中断向量表中查找中断处理程序的入口地址，执行中断处理程序；</li>\n<li><strong>CPU</strong> 恢复寄存器中的数值，返回原程序流停止位置继续执行。</li>\n</ol>\n<h1 id=\"套接字编程\"><a href=\"#套接字编程\" class=\"headerlink\" title=\"套接字编程\"></a>套接字编程</h1><p>Socket，表示进程间网络通信的特殊文件类型。本质是内核借助缓冲区形成的伪文件。<code>Linux</code>将<strong>套接字封装成文件</strong>的目的是为了<strong>统一接口</strong>，使得<strong>读写套接字和读写文件的操作一致</strong>。</p>\n<p>在TCP&#x2F;IP协议中，“IP地址+TCP或UDP端口号”<strong>唯一标识网络通讯中的一个进程</strong>。</p>\n<p>“IP地址+端口号”就对应一个socket。欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用Socket来描述网络连接的一对一关系。</p>\n<p><img src=\"/../img/socket.png\" alt=\"socket\"></p>\n<p>一个<strong>文件描述符</strong>指向一个<strong>套接字</strong></p>\n<p><strong>一个套接字</strong>内部由<strong>内核</strong>借助<strong>两个缓冲区</strong>实现，一个写缓冲、读缓冲。</p>\n<p><strong>在通信过程中， 套接字一定是成对出现的</strong>。一端的发送缓冲区对应对端的接收缓冲区</p>\n<p><img src=\"/../img/sokect1.png\" alt=\"sokect1\"></p>\n<ol>\n<li>socket()创建一个socket</li>\n<li>bind()为socket绑定ip+port</li>\n<li>listen()设置监听上限，即同时跟服务器建立socket连接的数量</li>\n<li>accept()：阻塞监听客户端连接，创建一个新的socket用来与客户端通信</li>\n<li>connect()：客户端使用现有的socket与服务器建立连接，如果不使用bind绑定客户端地址结构，采用“隐式绑定”，系统自动分配ip+port</li>\n</ol>\n<h1 id=\"网络IO\"><a href=\"#网络IO\" class=\"headerlink\" title=\"网络IO\"></a>网络IO</h1><p>同步：同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。<strong>也就是说，调用会等待返回结果计算完成才能继续执行。</strong>BIO,NIO,select,poll,epoll都是同步的，只不过会有阻塞，非阻塞的区别。</p>\n<p>异步：异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。<strong>也就是说，其实异步调用会直接返回，但是这个结果不是计算的结果，当结果计算出来之后，才通知被调用的程序。</strong></p>\n<p>阻塞：阻塞调用是指<strong>调用结果返回之前</strong>，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务。</p>\n<p>非阻塞：不管可不可以读写，<strong>它都会立即返回</strong>，返回成功说明读写操作完成了，返回失败会设置相应errno状态码，根据这个errno可以进一步执行其他处理。它不会像阻塞IO那样，卡在那里不动。</p>\n<h2 id=\"BIO\"><a href=\"#BIO\" class=\"headerlink\" title=\"BIO\"></a>BIO</h2><p>即阻塞IO，一个socket对应一个线程，若无数据发送则会一直阻塞等待，造成资源浪费</p>\n<p>特别是在JAVA环境下，线程的创建，切换，代价高昂</p>\n<p>结构简单，适合规模小，低并发的情况</p>\n<p><img src=\"/../img/BIO.png\" alt=\"BIO\"></p>\n<h2 id=\"NIO\"><a href=\"#NIO\" class=\"headerlink\" title=\"NIO\"></a>NIO</h2><p>非阻塞IO，指使用一个线程不断轮询来管理所有套接字，即一个while死循环来不断遍历，一旦发现有数据便进行处理。</p>\n<p>做到了单线程也能管理所有套接字。这是非阻塞的，就算没有数据也不会停下来，而是返回无数据的标识，然后再进行下一次的轮询。</p>\n<p>NIO是面向缓冲区的，每个连接都有一个缓冲区来暂存数据，由管道来进行双向传输</p>\n<p><img src=\"/../img/reactor2.png\" alt=\"reactor2\"></p>\n<h2 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a>select</h2><p>NIO是一种十分创新的思想，但是也有许多问题，比如忙循环。</p>\n<p>若一直在用户空间进行轮询，则会资源浪费，复杂度至少为O(n)</p>\n<p>而select就是将所有的fd收集并交给内核，进行一次系统调用，复杂度降为O(1)</p>\n<p><img src=\"/../img/select.png\" alt=\"select\"></p>\n<p>内核会返回一个整数，若小于零，代表没有任何数据或请求到达，若大于零，代表可以进行处理。若等于零，代表等待超时。</p>\n<p><strong>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</strong></p>\n<p><strong>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</strong></p>\n<p>fd_set的大小是有限制的，即单个进程能维护的套接字的大小有限，32位为1024，64位机默认是2048。可以修改。</p>\n<h2 id=\"poll\"><a href=\"#poll\" class=\"headerlink\" title=\"poll\"></a>poll</h2><p>poll的实现和select很相似，不同的是用于管理文件描述符的集合由数组变为了链表，所以没有最大连接数的限制。存在和select同样的问题</p>\n<h2 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h2><p> 与前面所有的轮询机制不同，epoll使用的是<strong>事件驱动</strong>，即当发生事件时，每个fd上有注册有回调函数，当网卡接收到数据时会回调该函数，同时将该fd的引用放入rdlist就绪列表中。</p>\n<p>当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。</p>\n<p>如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户。</p>\n<p>避免了遍历所有的fd，只检查发生事件的fd</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; 数据结构\n&#x2F;&#x2F; 每一个epoll对象都有一个独立的eventpoll结构体\n&#x2F;&#x2F; 用于存放通过epoll_ctl方法向epoll对象中添加进来的事件\nstruct eventpoll &#123;\n    &#x2F;*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*&#x2F;\n    struct rb_root  rbr;\n    &#x2F;*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*&#x2F;\n    struct list_head rdlist;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行流程</p>\n<ol>\n<li>调用epoll_create()创建一个ep对象，在内核空间中开辟了一块空间存储eventpoll，返回一个文件句柄，即红黑树的根节点</li>\n<li>调用epoll_ctl()向红黑树中添加、删除、修改fd</li>\n<li>调用epoll_wait()等待，当有事件发生时网卡驱动会调用fd上注册的函数并将该fd添加到rdlist中，解除阻塞。由于fd的引用在红黑树上，所以查找速度很快。</li>\n</ol>\n<p><img src=\"/../img/epoll.png\" alt=\"epoll\"></p>\n<p>总结：</p>\n<ol>\n<li>EPOLL支持的最大文件描述符上限是整个系统最大可打开的文件数目, 1G内存理论上最大创建10万个文件描述符</li>\n<li>每个文件描述符上都有一个callback函数，当socket有事件发生时会回调这个函数将该fd的引用添加到就绪列表中，select和poll并不会明确指出是哪些文件描述符就绪，而epoll会。造成的区别就是，系统调用返回后，调用select和poll的程序需要遍历监听的整个文件描述符找到是谁处于就绪，而epoll则直接处理即可</li>\n<li>select、poll采用轮询的方式来检查文件描述符是否处于就绪态，而epoll采用回调机制。造成的结果就是，随着fd的增加，select和poll的效率会线性降低，而epoll不会受到太大影响，<strong>除非活跃的socket很多</strong></li>\n</ol>\n","feature":true,"text":"用户空间和内核空间操作系统为了支持多个应用同时运行，需要保证不同进程之间相对独立，一个进程的崩溃不会影响其他进程，恶意进程不能读取其他进程的数据。于是内存空间被划分为两部分，内核空间和用户空间，内核空间的代码和数据拥有更高的权限，而用户空间的代码不能访问高级别的空间，因此保护了操...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"网络编程基础知识","slug":"网络编程基础知识","count":1,"path":"api/tags/网络编程基础知识.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%92%8C%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4\"><span class=\"toc-text\">用户空间和内核空间</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87\"><span class=\"toc-text\">什么是进程上下文</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E4%BB%8E%E7%94%A8%E6%88%B7%E6%80%81%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E6%80%81%EF%BC%9A%E4%B8%AD%E6%96%AD\"><span class=\"toc-text\">如何从用户态进入内核态：中断</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A1%AC%E4%B8%AD%E6%96%AD\"><span class=\"toc-text\">硬中断</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BD%AF%E4%B8%AD%E6%96%AD%EF%BC%88%E8%A2%AB%E5%8A%A8%EF%BC%89\"><span class=\"toc-text\">软中断（被动）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BD%AF%E4%B8%AD%E6%96%AD%EF%BC%88%E4%B8%BB%E5%8A%A8%EF%BC%89\"><span class=\"toc-text\">软中断（主动）</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">套接字编程</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BD%91%E7%BB%9CIO\"><span class=\"toc-text\">网络IO</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#BIO\"><span class=\"toc-text\">BIO</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#NIO\"><span class=\"toc-text\">NIO</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#select\"><span class=\"toc-text\">select</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#poll\"><span class=\"toc-text\">poll</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#epoll\"><span class=\"toc-text\">epoll</span></a></li></ol></li></ol>","author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Java基础知识汇总","uid":"2e8864ab557e295b3f55e14c06a19e33","slug":"JAVA基础知识汇总","date":"2022-11-13T07:48:43.000Z","updated":"2022-11-13T07:56:15.222Z","comments":true,"path":"api/articles/JAVA基础知识汇总.json","keywords":null,"cover":null,"text":"Object类中有哪些方法 equals()：未被重写前，由&#x3D;&#x3D;来实现，比较引用数据类型的引用地址是否相同 HashCode()：本地方法，未被重写前返回对象在堆上的唯一地址值，可以看作是对象的身份ID clone()：实现了cloneable接口才可以调用该...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":9,"path":"api/tags/Java基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"洪水淹没算法","uid":"52c15247d71045907737fa627f8aa035","slug":"洪水淹没算法","date":"2022-10-31T06:51:29.000Z","updated":"2022-10-31T11:10:18.126Z","comments":true,"path":"api/articles/洪水淹没算法.json","keywords":null,"cover":[],"text":"695. 岛屿的最大面积 输入：grid &#x3D; [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0]...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"LeetCode初见","slug":"LeetCode初见","count":8,"path":"api/tags/LeetCode初见.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}