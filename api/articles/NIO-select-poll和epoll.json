{"title":"NIO select poll和epoll","uid":"2a1374b017f253762c103f23513f4420","slug":"NIO-select-poll和epoll","date":"2022-11-02T05:45:40.000Z","updated":"2022-11-16T08:55:31.783Z","comments":true,"path":"api/articles/NIO-select-poll和epoll.json","keywords":null,"cover":[],"content":"<h1 id=\"套接字编程\"><a href=\"#套接字编程\" class=\"headerlink\" title=\"套接字编程\"></a>套接字编程</h1><p>Socket，表示进程间网络通信的特殊文件类型。本质是内核借助缓冲区形成的伪文件。<code>Linux</code>将<strong>套接字封装成文件</strong>的目的是为了<strong>统一接口</strong>，使得<strong>读写套接字和读写文件的操作一致</strong>。</p>\n<p>在TCP&#x2F;IP协议中，“IP地址+TCP或UDP端口号”<strong>唯一标识网络通讯中的一个进程</strong>。</p>\n<p>“IP地址+端口号”就对应一个socket。欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用Socket来描述网络连接的一对一关系。</p>\n<p><img src=\"/../img/socket.png\" alt=\"socket\"></p>\n<p>一个<strong>文件描述符</strong>指向一个<strong>套接字</strong></p>\n<p><strong>一个套接字</strong>内部由<strong>内核</strong>借助<strong>两个缓冲区</strong>实现，一个写缓冲、读缓冲。</p>\n<p><strong>在通信过程中， 套接字一定是成对出现的</strong>。一端的发送缓冲区对应对端的接收缓冲区</p>\n<p><img src=\"/../img/sokect1.png\" alt=\"sokect1\"></p>\n<ol>\n<li>socket()创建一个socket</li>\n<li>bind()为socket绑定ip+port</li>\n<li>listen()设置监听上限，即同时跟服务器建立socket连接的数量</li>\n<li>accept()：阻塞监听客户端连接，创建一个新的socket用来与客户端通信</li>\n<li>connect()：客户端使用现有的socket与服务器建立连接，如果不使用bind绑定客户端地址结构，采用“隐式绑定”，系统自动分配ip+port</li>\n</ol>\n<h1 id=\"网络IO\"><a href=\"#网络IO\" class=\"headerlink\" title=\"网络IO\"></a>网络IO</h1><p>同步：同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。<strong>也就是说，调用会等待返回结果计算完成才能继续执行。</strong>BIO,NIO,select,poll,epoll都是同步的，只不过会有阻塞，非阻塞的区别。</p>\n<p>异步：异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。<strong>也就是说，其实异步调用会直接返回，但是这个结果不是计算的结果，当结果计算出来之后，才通知被调用的程序。</strong></p>\n<p>阻塞：阻塞调用是指<strong>调用结果返回之前</strong>，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务。</p>\n<p>非阻塞：不管可不可以读写，<strong>它都会立即返回</strong>，返回成功说明读写操作完成了，返回失败会设置相应errno状态码，根据这个errno可以进一步执行其他处理。它不会像阻塞IO那样，卡在那里不动。</p>\n<h2 id=\"BIO\"><a href=\"#BIO\" class=\"headerlink\" title=\"BIO\"></a>BIO</h2><p>即阻塞IO，一个socket对应一个线程，若无数据发送则会一直阻塞等待，造成资源浪费</p>\n<p>特别是在JAVA环境下，线程的创建，切换，代价高昂</p>\n<p>结构简单，适合规模小，低并发的情况</p>\n<p><img src=\"/../img/BIO.png\" alt=\"BIO\"></p>\n<h4 id=\"特点：面向流的，阻塞的\"><a href=\"#特点：面向流的，阻塞的\" class=\"headerlink\" title=\"特点：面向流的，阻塞的\"></a>特点：面向流的，阻塞的</h4><p>java1.4以前的io模型，一连接对一个线程，原始的IO是面向流的，不存在缓存的概念。</p>\n<p>Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。</p>\n<p>此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区</p>\n<p>Java IO的各种流是阻塞的，这意味着当一个线程调用read或 write方法时，该线程被阻塞，直到有一些数据被读取，或数据完全写入，该线程在此期间不能再干任何事情了。</p>\n<h2 id=\"NIO\"><a href=\"#NIO\" class=\"headerlink\" title=\"NIO\"></a>NIO</h2><p>非阻塞IO，指使用一个线程不断轮询来管理所有套接字，即一个while死循环来不断遍历，一旦发现有数据便进行处理。</p>\n<p>做到了单线程也能管理所有套接字。这是非阻塞的，就算没有数据也不会停下来，而是返回无数据的标识，然后再进行下一次的轮询。</p>\n<p>NIO是面向缓冲区的，每个连接都有一个缓冲区来暂存数据，由管道来进行双向传输</p>\n<p><img src=\"/../img/reactor2.png\" alt=\"reactor2\"></p>\n<h2 id=\"selector\"><a href=\"#selector\" class=\"headerlink\" title=\"selector\"></a>selector</h2><p>实现循环监听通道信号的组件</p>\n<p>一个selector 对应一个线程， 多个channel以事件的方式注册于selector，代表一个进程便可以处理多个连接</p>\n<p>selector 会在各个通道上切换，只有在连接&#x2F;通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，避免了多线程之间的上下文切换导致的开销</p>\n<h3 id=\"channel\"><a href=\"#channel\" class=\"headerlink\" title=\"channel\"></a>channel</h3><p>NIO的通道类似于流，但有些区别如下：</p>\n<ol>\n<li>通道可以同时进行读写，而流只能读或者只能写</li>\n<li>通道可以实现异步读写数据</li>\n<li>通道可以从缓冲读数据，也可以写数据到缓冲</li>\n</ol>\n<p>channel 是双向的, 可以返回底层操作系统的情况, 比如Linux ，底层的操作系统通道就是双向的</p>\n<h3 id=\"buffer\"><a href=\"#buffer\" class=\"headerlink\" title=\"buffer\"></a>buffer</h3><p>Buffer 就是一个内存块 ，底层是有一个数组</p>\n<p>channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer</p>\n<p>数据的读取写入是通过Buffer, 这个和BIO不同 , BIO 中要么是输入流，或者是输出流，不能双向</p>\n<p>但是NIO的Buffer 是可以读也可以写, 需要 flip 方法切换</p>\n<h4 id=\"特点：面向块，非阻塞\"><a href=\"#特点：面向块，非阻塞\" class=\"headerlink\" title=\"特点：面向块，非阻塞\"></a>特点：面向块，非阻塞</h4><p>NIO是面向缓冲区的。数据被读取到缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性。</p>\n<p>Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。</p>\n<p>NIO是可以做到用一个线程来处理多个操作的。selector会不断循环监听channel，如果通道中没有数据即没有请求时它可以去处理别的通道或者做其他的事情，如果通道中有数据它就会选择这个通道然后进行处理，实现了一个线程处理多个连接。</p>\n<h1 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a><code>select</code></h1><p>NIO是一种十分创新的思想，但是也有许多问题，比如忙循环。</p>\n<p>若一直在用户空间进行轮询，则会资源浪费，复杂度至少为O(n)</p>\n<p>而select就是将所有的fd收集并交给内核，进行一次系统调用，复杂度降为O(1)</p>\n<p><img src=\"/../img/select.png\" alt=\"select\"></p>\n<p>内核会返回一个整数，若小于零，代表没有任何数据或请求到达，若大于零，代表可以进行处理。若等于零，代表等待超时。</p>\n<p><strong>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</strong></p>\n<p><strong>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</strong></p>\n<p>fd_set的大小是有限制的，即单个进程能维护的套接字的大小有限，32位为1024，64位机默认是2048。可以修改。</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">while (1) &#123;\n      read_fd_set &#x3D; all_fd_set;\n      printf(&quot;阻塞中... lastfd&#x3D;%d\\n&quot;, lastfd);\n    \t&#x2F;&#x2F;获取标志位\n      int nready &#x3D; select(lastfd+1, &amp;read_fd_set, NULL, NULL, NULL);\n      switch (nready) &#123;\n          case 0 :\n              printf(&quot;select time out ......\\n&quot;);\n              break;\n          case -1 :\n              perror(&quot;select error \\n&quot;);\n              break;\n          default:\n              &#x2F;&#x2F; 监听到新的客户端连接\n              if (FD_ISSET(lfd, &amp;read_fd_set)) &#123;\n                  struct sockaddr_in client_addr; \n                  socklen_t cliaddr_len &#x3D; sizeof(client_addr);\n                  char cli_ip[INET_ADDRSTRLEN] &#x3D; &quot;&quot;;  \n                  &#x2F;&#x2F; 肯定有连接不会阻塞\n                  int clientfd &#x3D; accept(lfd, (struct sockaddr*)&amp;client_addr, &amp;cliaddr_len);\n                  inet_ntop(AF_INET, &amp;client_addr.sin_addr, cli_ip, INET_ADDRSTRLEN);\n                  printf(&quot;----------------------------------------------\\n&quot;);\n                  printf(&quot;client ip&#x3D;%s,port&#x3D;%d\\n&quot;, cli_ip, ntohs(client_addr.sin_port));\n                  &#x2F;&#x2F; 将clientfd加入读集合\n                  FD_SET(clientfd, &amp;all_fd_set);  \n                  lastfd &#x3D; clientfd;\n                  if(0 &#x3D;&#x3D; --nready) &#123;\n                      continue;\n                  &#125;\n              &#125;\n              int i;\n              &#x2F;&#x2F;遍历所有的fdset来处理事件\n              for (i &#x3D; lfd + 1;i &lt;&#x3D; lastfd; i++) &#123;\n                  &#x2F;&#x2F; 处理读事件\n                  if (FD_ISSET(i, &amp;read_fd_set)) &#123;\n                      char recv_buf[512] &#x3D; &quot;&quot;;\n                      int rs &#x3D; read(i, recv_buf, sizeof(recv_buf));\n                      if (rs &#x3D;&#x3D; 0 ) &#123;\n                          close(i);\n                          FD_CLR(i, &amp;all_fd_set);\n                      &#125; else &#123;\n                          printf(&quot;%s\\n&quot;,recv_buf);\n                          &#x2F;&#x2F; 给每一个服务端写数据\n                          int j;\n                          for (j &#x3D; lfd + 1;j &lt;&#x3D; lastfd; j++) &#123;\n                              if (j !&#x3D; i) &#123;\n                                  write(j, recv_buf, strlen(recv_buf));\n                              &#125;\n                          &#125;\n                      &#125;\n                  &#125;\n              &#125;\n      &#125;\n      \n  &#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h1 id=\"poll\"><a href=\"#poll\" class=\"headerlink\" title=\"poll\"></a><code>poll</code></h1><p>poll的实现和select很相似，不同的是用于管理文件描述符的集合由数组变为了链表，所以没有最大连接数的限制。存在和select同样的问题</p>\n<h1 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a><code>epoll</code></h1><p> 与前面所有的轮询机制不同，epoll使用的是<strong>事件驱动</strong>，即当发生事件时，每个fd上有注册有回调函数，当网卡接收到数据时会回调该函数，同时将该fd的引用放入rdlist就绪列表中。</p>\n<p>当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。</p>\n<p>如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户。</p>\n<p>避免了遍历所有的fd，只检查发生事件的fd</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; 数据结构\n&#x2F;&#x2F; 每一个epoll对象都有一个独立的eventpoll结构体\n&#x2F;&#x2F; 用于存放通过epoll_ctl方法向epoll对象中添加进来的事件\nstruct eventpoll &#123;\n    &#x2F;*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*&#x2F;\n    struct rb_root  rbr;\n    &#x2F;*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*&#x2F;\n    struct list_head rdlist;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行流程</p>\n<ol>\n<li>调用epoll_create()创建一个ep对象，在内核空间中开辟了一块空间存储eventpoll，返回一个文件句柄，即红黑树的根节点</li>\n<li>调用epoll_ctl()向红黑树中添加、删除、修改fd</li>\n<li>调用epoll_wait()等待，当有事件发生时网卡驱动会调用fd上注册的函数并将该fd添加到rdlist中，解除阻塞。由于fd的引用在红黑树上，所以查找速度很快。</li>\n</ol>\n<p><img src=\"/../img/epoll.png\" alt=\"epoll\"></p>\n<p>总结：</p>\n<ol>\n<li>EPOLL支持的最大文件描述符上限是整个系统最大可打开的文件数目, 1G内存理论上最大创建10万个文件描述符</li>\n<li>每个文件描述符上都有一个callback函数，当socket有事件发生时会回调这个函数将该fd的引用添加到就绪列表中，select和poll并不会明确指出是哪些文件描述符就绪，而epoll会。造成的区别就是，系统调用返回后，调用select和poll的程序需要遍历监听的整个文件描述符找到是谁处于就绪，而epoll则直接处理即可</li>\n<li>select、poll采用轮询的方式来检查文件描述符是否处于就绪态，而epoll采用回调机制。造成的结果就是，随着fd的增加，select和poll的效率会线性降低，而epoll不会受到太大影响，<strong>除非活跃的socket很多</strong></li>\n</ol>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token comment\">//开辟内核空间，返回文件描述符</span>\n<span class=\"token keyword\">int</span> epfd <span class=\"token operator\">=</span> <span class=\"token function\">epoll_create</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nevent<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>fd <span class=\"token operator\">=</span> lfd<span class=\"token punctuation\">;</span>\nevent<span class=\"token punctuation\">.</span>events <span class=\"token operator\">=</span> EPOLLIN<span class=\"token punctuation\">;</span>\n<span class=\"token function\">epoll_ctl</span><span class=\"token punctuation\">(</span>epfd<span class=\"token punctuation\">,</span> EPOLL_CTL_ADD<span class=\"token punctuation\">,</span> lfd<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>event<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"阻塞中....\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \t<span class=\"token comment\">//从事件集中获取文件描述符</span>\n        <span class=\"token keyword\">int</span> nready <span class=\"token operator\">=</span> <span class=\"token function\">epoll_wait</span><span class=\"token punctuation\">(</span>epfd<span class=\"token punctuation\">,</span> events<span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> nready<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">// 监听到新的客户端连接</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>events<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>fd <span class=\"token operator\">==</span> lfd<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token keyword\">struct</span> <span class=\"token class-name\">sockaddr_in</span> client_addr<span class=\"token punctuation\">;</span> \n                <span class=\"token class-name\">socklen_t</span> cliaddr_len <span class=\"token operator\">=</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>client_addr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">char</span> cli_ip<span class=\"token punctuation\">[</span>INET_ADDRSTRLEN<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>  \n                <span class=\"token comment\">// 肯定有连接不会阻塞</span>\n                <span class=\"token keyword\">int</span> clientfd <span class=\"token operator\">=</span> <span class=\"token function\">accept</span><span class=\"token punctuation\">(</span>lfd<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">sockaddr</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&amp;</span>client_addr<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>cliaddr_len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token function\">inet_ntop</span><span class=\"token punctuation\">(</span>AF_INET<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>client_addr<span class=\"token punctuation\">.</span>sin_addr<span class=\"token punctuation\">,</span> cli_ip<span class=\"token punctuation\">,</span> INET_ADDRSTRLEN<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                event<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>fd <span class=\"token operator\">=</span> clientfd<span class=\"token punctuation\">;</span>\n                event<span class=\"token punctuation\">.</span>events <span class=\"token operator\">=</span> EPOLLIN <span class=\"token operator\">|</span> EPOLLET<span class=\"token punctuation\">;</span>\n                <span class=\"token function\">epoll_ctl</span><span class=\"token punctuation\">(</span>epfd<span class=\"token punctuation\">,</span> EPOLL_CTL_ADD<span class=\"token punctuation\">,</span> clientfd<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>event<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                \n                <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"----------------------------------------------\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"client ip=%s,port=%d\\n\"</span><span class=\"token punctuation\">,</span> cli_ip<span class=\"token punctuation\">,</span> <span class=\"token function\">ntohs</span><span class=\"token punctuation\">(</span>client_addr<span class=\"token punctuation\">.</span>sin_port<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token keyword\">char</span> recv_buf<span class=\"token punctuation\">[</span><span class=\"token number\">512</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">int</span> rs <span class=\"token operator\">=</span> <span class=\"token function\">read</span><span class=\"token punctuation\">(</span>events<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>fd<span class=\"token punctuation\">,</span> recv_buf<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>recv_buf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>rs <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                    <span class=\"token function\">close</span><span class=\"token punctuation\">(</span>events<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>fd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token function\">epoll_ctl</span><span class=\"token punctuation\">(</span>epfd<span class=\"token punctuation\">,</span> EPOLL_CTL_DEL<span class=\"token punctuation\">,</span> events<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>fd<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>event<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span>\n                <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%s\\n\"</span><span class=\"token punctuation\">,</span>recv_buf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>      \n    <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"C10K问题\"><a href=\"#C10K问题\" class=\"headerlink\" title=\"C10K问题\"></a>C10K问题</h1><p><strong>服务器如何支持10k个并发连接？</strong></p>\n<h2 id=\"为每个连接分配一个独立的线程-x2F-进程\"><a href=\"#为每个连接分配一个独立的线程-x2F-进程\" class=\"headerlink\" title=\"为每个连接分配一个独立的线程&#x2F;进程\"></a>为每个连接分配一个独立的线程&#x2F;进程</h2><p>这一思路最为直接。但是，由于申请进程&#x2F;线程会占用相当可观的系统资源，同时对于多进程&#x2F;线程的管理会对系统造成压力，因此，这种方案不具备良好的可扩展性。这一思路在服务器资源还没有富裕到足够程度的时候，是不可行的。即便资源足够富裕，效率也不够高。</p>\n<p>总之，此思路技术实现会使得资源占用过多，可扩展性差，在实际应用中已被抛弃。</p>\n<h2 id=\"IO多路复用\"><a href=\"#IO多路复用\" class=\"headerlink\" title=\"IO多路复用\"></a><strong>IO多路复用</strong></h2><ol>\n<li>循环逐个处理各个连接，每个连接对应一个 socket。当所有 socket 都有数据的时候，这种方法是可行的。但是，当应用读取某个 socket 的文件数据不 ready 的时候，整个应用会阻塞在这里，等待该文件句柄ready，即使别的文件句柄 ready，也无法往下处理。任一文件句柄的不成功会阻塞住整个应用。</li>\n<li>使用select方法解决上面阻塞的问题。在读取文件句柄之前，先查下它的状态，如果ready 了，就进行处理；如果不 ready， 就不进行处理；于是，有了 select 方案。用一个 fd_set 结构体来告诉内核同时监控多个文件句柄，当其中有文件句柄的状态发生指定变化（例如某句柄由不可用变为可用）或超时，则调用返回。同时，在使用上，因为只有一个字段记录关注和发生事件，所以每次调用之前，要重新初始化fd_set结构体。并且因为监听的是所有fd，所以当fd过多时，检查状态就会很慢</li>\n<li>poll 和select原理基本相同，不过消除了文件句柄上限。使用不同字段分别标注“关注事件和发生事件”，来避免重复初始化。</li>\n<li>使用epoll，“poll逐个排查所有文件句柄状态”效率不高。如果在调用返回的时候，只给应用提供发生了状态变化（很可能是数据 ready）的文件句柄，进行排查的效率就高很多。epoll 采用了这种设计，适用于大规模的应用场景。实验表明：当文件句柄数目超过10之后，epoll 性能将优于 select 和 poll；当文件句柄数目达到 10K 的时候，epoll 已经超过 select 和 poll 两个数量级。</li>\n</ol>\n<h2 id=\"C10M：服务器如何支持10M个并发连接？\"><a href=\"#C10M：服务器如何支持10M个并发连接？\" class=\"headerlink\" title=\"C10M：服务器如何支持10M个并发连接？\"></a>C10M：服务器如何支持10M个并发连接？</h2><p>内核是问题所在，要高效地去除阻塞，让CPU更多地处理核心任务。不要让内核执行所有繁重的任务。将数据包处理、内存管理、处理器调度等任务从内核转移到应用程序，由应用程序高效地完成。让Linux只处理控制层，数据层完全交给应用程序来处理。</p>\n<p>当连接很多时，首先需要大量的进程&#x2F;线程。同时，系统中的应用进程&#x2F;线程可能大量地都处于 ready 状态，需要系统不断地进行快速切换，系统的上下文的切换是有代价的。</p>\n<p>所以我们面临的瓶颈有两个：一个是进程&#x2F;线程作为处理单元，还是太厚重了；另一个是系统调度的代价太高了。</p>\n<p>如果有一种更轻量级的进程&#x2F;线程作为处理单元，而且它们的调度可以做到很快，也许就能解决问题，这就是<strong>协程</strong></p>\n<h3 id=\"协程\"><a href=\"#协程\" class=\"headerlink\" title=\"协程\"></a>协程</h3><p>协程在实现上都是试图用一组少量的线程来实现多个任务，一旦某个任务阻塞，则可能用同一线程继续运行其他任务，避免大量上下文的切换。每个协程所独占的系统资源往往只有栈部分。各个协程之间的切换，往往是用户通过代码来显式指定的（跟各种callback 类似），不需要内核参与，可以很方便实地现异步。</p>\n<p>这个技术本质上是<strong>异步非阻塞</strong>技术，它是将事件回调进行了包装，让程序员看不到里面的事件循环。程序员就像写阻塞代码一样简单。</p>\n<p>比如调用 client-&gt;recv() 等待接收数据时，就像阻塞代码一样写。实际上是，底层库在执行recv时悄悄保存了一个状态，比如代码行数、局部变量的值。然后，就跳回到EventLoop中了。什么时候真的数据到来时，它再把刚才保存的代码行数、局部变量值取出来，又开始继续执行。</p>\n<p>这就是协程的本质。<strong>协程是异步非阻塞的另外一种展现形式</strong>。Golang、Erlang、Lua协程都是这个模型。</p>\n","feature":true,"text":"套接字编程Socket，表示进程间网络通信的特殊文件类型。本质是内核借助缓冲区形成的伪文件。Linux将套接字封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。 在TCP&#x2F;IP协议中，“IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程。 “...","link":"","photos":[],"count_time":{"symbolsCount":"9.4k","symbolsTime":"9 mins."},"categories":[],"tags":[{"name":"网络编程基础知识","slug":"网络编程基础知识","count":1,"path":"api/tags/网络编程基础知识.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">套接字编程</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BD%91%E7%BB%9CIO\"><span class=\"toc-text\">网络IO</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#BIO\"><span class=\"toc-text\">BIO</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%89%B9%E7%82%B9%EF%BC%9A%E9%9D%A2%E5%90%91%E6%B5%81%E7%9A%84%EF%BC%8C%E9%98%BB%E5%A1%9E%E7%9A%84\"><span class=\"toc-text\">特点：面向流的，阻塞的</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#NIO\"><span class=\"toc-text\">NIO</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#selector\"><span class=\"toc-text\">selector</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#channel\"><span class=\"toc-text\">channel</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#buffer\"><span class=\"toc-text\">buffer</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%89%B9%E7%82%B9%EF%BC%9A%E9%9D%A2%E5%90%91%E5%9D%97%EF%BC%8C%E9%9D%9E%E9%98%BB%E5%A1%9E\"><span class=\"toc-text\">特点：面向块，非阻塞</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#select\"><span class=\"toc-text\">select</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#poll\"><span class=\"toc-text\">poll</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#epoll\"><span class=\"toc-text\">epoll</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#C10K%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">C10K问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E6%AF%8F%E4%B8%AA%E8%BF%9E%E6%8E%A5%E5%88%86%E9%85%8D%E4%B8%80%E4%B8%AA%E7%8B%AC%E7%AB%8B%E7%9A%84%E7%BA%BF%E7%A8%8B-x2F-%E8%BF%9B%E7%A8%8B\"><span class=\"toc-text\">为每个连接分配一个独立的线程&#x2F;进程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8\"><span class=\"toc-text\">IO多路复用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#C10M%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%8110M%E4%B8%AA%E5%B9%B6%E5%8F%91%E8%BF%9E%E6%8E%A5%EF%BC%9F\"><span class=\"toc-text\">C10M：服务器如何支持10M个并发连接？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E7%A8%8B\"><span class=\"toc-text\">协程</span></a></li></ol></li></ol></li></ol>","author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Java基础知识汇总","uid":"2e8864ab557e295b3f55e14c06a19e33","slug":"JAVA基础知识汇总","date":"2022-11-13T07:48:43.000Z","updated":"2022-11-21T14:40:58.433Z","comments":true,"path":"api/articles/JAVA基础知识汇总.json","keywords":null,"cover":null,"text":"Object类中有哪些方法 equals()：未被重写前，由&#x3D;&#x3D;来实现，比较引用数据类型的引用地址是否相同 HashCode()：本地方法，未被重写前返回对象在堆上的唯一地址值，可以看作是对象的身份ID clone()：实现了cloneable接口才可以调用该...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":7,"path":"api/tags/Java基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"洪水淹没算法","uid":"52c15247d71045907737fa627f8aa035","slug":"洪水淹没算法","date":"2022-10-31T06:51:29.000Z","updated":"2022-10-31T11:10:18.126Z","comments":true,"path":"api/articles/洪水淹没算法.json","keywords":null,"cover":[],"text":"695. 岛屿的最大面积 输入：grid &#x3D; [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0]...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"LeetCode初见","slug":"LeetCode初见","count":9,"path":"api/tags/LeetCode初见.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}