{"title":"NIO select poll和epoll","uid":"2a1374b017f253762c103f23513f4420","slug":"NIO-select-poll和epoll","date":"2022-11-02T05:45:40.000Z","updated":"2022-11-14T07:11:41.687Z","comments":true,"path":"api/articles/NIO-select-poll和epoll.json","keywords":null,"cover":[],"content":"<h1 id=\"套接字编程\"><a href=\"#套接字编程\" class=\"headerlink\" title=\"套接字编程\"></a>套接字编程</h1><p>Socket，表示进程间网络通信的特殊文件类型。本质是内核借助缓冲区形成的伪文件。<code>Linux</code>将<strong>套接字封装成文件</strong>的目的是为了<strong>统一接口</strong>，使得<strong>读写套接字和读写文件的操作一致</strong>。</p>\n<p>在TCP&#x2F;IP协议中，“IP地址+TCP或UDP端口号”<strong>唯一标识网络通讯中的一个进程</strong>。</p>\n<p>“IP地址+端口号”就对应一个socket。欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用Socket来描述网络连接的一对一关系。</p>\n<p><img src=\"/../img/socket.png\" alt=\"socket\"></p>\n<p>一个<strong>文件描述符</strong>指向一个<strong>套接字</strong></p>\n<p><strong>一个套接字</strong>内部由<strong>内核</strong>借助<strong>两个缓冲区</strong>实现，一个写缓冲、读缓冲。</p>\n<p><strong>在通信过程中， 套接字一定是成对出现的</strong>。一端的发送缓冲区对应对端的接收缓冲区</p>\n<p><img src=\"/../img/sokect1.png\" alt=\"sokect1\"></p>\n<ol>\n<li>socket()创建一个socket</li>\n<li>bind()为socket绑定ip+port</li>\n<li>listen()设置监听上限，即同时跟服务器建立socket连接的数量</li>\n<li>accept()：阻塞监听客户端连接，创建一个新的socket用来与客户端通信</li>\n<li>connect()：客户端使用现有的socket与服务器建立连接，如果不使用bind绑定客户端地址结构，采用“隐式绑定”，系统自动分配ip+port</li>\n</ol>\n<h1 id=\"网络IO\"><a href=\"#网络IO\" class=\"headerlink\" title=\"网络IO\"></a>网络IO</h1><p>同步：同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。<strong>也就是说，调用会等待返回结果计算完成才能继续执行。</strong>BIO,NIO,select,poll,epoll都是同步的，只不过会有阻塞，非阻塞的区别。</p>\n<p>异步：异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。<strong>也就是说，其实异步调用会直接返回，但是这个结果不是计算的结果，当结果计算出来之后，才通知被调用的程序。</strong></p>\n<p>阻塞：阻塞调用是指<strong>调用结果返回之前</strong>，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务。</p>\n<p>非阻塞：不管可不可以读写，<strong>它都会立即返回</strong>，返回成功说明读写操作完成了，返回失败会设置相应errno状态码，根据这个errno可以进一步执行其他处理。它不会像阻塞IO那样，卡在那里不动。</p>\n<h2 id=\"BIO\"><a href=\"#BIO\" class=\"headerlink\" title=\"BIO\"></a>BIO</h2><p>即阻塞IO，一个socket对应一个线程，若无数据发送则会一直阻塞等待，造成资源浪费</p>\n<p>特别是在JAVA环境下，线程的创建，切换，代价高昂</p>\n<p>结构简单，适合规模小，低并发的情况</p>\n<p><img src=\"/../img/BIO.png\" alt=\"BIO\"></p>\n<h4 id=\"特点：面向流的，阻塞的\"><a href=\"#特点：面向流的，阻塞的\" class=\"headerlink\" title=\"特点：面向流的，阻塞的\"></a>特点：面向流的，阻塞的</h4><p>java1.4以前的io模型，一连接对一个线程，原始的IO是面向流的，不存在缓存的概念。</p>\n<p>Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。</p>\n<p>此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区</p>\n<p>Java IO的各种流是阻塞的，这意味着当一个线程调用read或 write方法时，该线程被阻塞，直到有一些数据被读取，或数据完全写入，该线程在此期间不能再干任何事情了。</p>\n<h2 id=\"NIO\"><a href=\"#NIO\" class=\"headerlink\" title=\"NIO\"></a>NIO</h2><p>非阻塞IO，指使用一个线程不断轮询来管理所有套接字，即一个while死循环来不断遍历，一旦发现有数据便进行处理。</p>\n<p>做到了单线程也能管理所有套接字。这是非阻塞的，就算没有数据也不会停下来，而是返回无数据的标识，然后再进行下一次的轮询。</p>\n<p>NIO是面向缓冲区的，每个连接都有一个缓冲区来暂存数据，由管道来进行双向传输</p>\n<p><img src=\"/../img/reactor2.png\" alt=\"reactor2\"></p>\n<h2 id=\"selector\"><a href=\"#selector\" class=\"headerlink\" title=\"selector\"></a>selector</h2><p>实现循环监听通道信号的组件</p>\n<p>一个selector 对应一个线程， 多个channel以事件的方式注册于selector，代表一个进程便可以处理多个连接</p>\n<p>selector 会在各个通道上切换，只有在连接&#x2F;通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，避免了多线程之间的上下文切换导致的开销</p>\n<h3 id=\"channel\"><a href=\"#channel\" class=\"headerlink\" title=\"channel\"></a>channel</h3><p>NIO的通道类似于流，但有些区别如下：</p>\n<ol>\n<li>通道可以同时进行读写，而流只能读或者只能写</li>\n<li>通道可以实现异步读写数据</li>\n<li>通道可以从缓冲读数据，也可以写数据到缓冲</li>\n</ol>\n<p>channel 是双向的, 可以返回底层操作系统的情况, 比如Linux ，底层的操作系统通道就是双向的</p>\n<h3 id=\"buffer\"><a href=\"#buffer\" class=\"headerlink\" title=\"buffer\"></a>buffer</h3><p>Buffer 就是一个内存块 ，底层是有一个数组</p>\n<p>channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer</p>\n<p>数据的读取写入是通过Buffer, 这个和BIO不同 , BIO 中要么是输入流，或者是输出流，不能双向</p>\n<p>但是NIO的Buffer 是可以读也可以写, 需要 flip 方法切换</p>\n<h4 id=\"特点：面向块，非阻塞\"><a href=\"#特点：面向块，非阻塞\" class=\"headerlink\" title=\"特点：面向块，非阻塞\"></a>特点：面向块，非阻塞</h4><p>NIO是面向缓冲区的。数据被读取到缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性。</p>\n<p>Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。</p>\n<p>NIO是可以做到用一个线程来处理多个操作的。selector会不断循环监听channel，如果通道中没有数据即没有请求时它可以去处理别的通道或者做其他的事情，如果通道中有数据它就会选择这个通道然后进行处理，实现了一个线程处理多个连接。</p>\n<h1 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a><code>select</code></h1><p>NIO是一种十分创新的思想，但是也有许多问题，比如忙循环。</p>\n<p>若一直在用户空间进行轮询，则会资源浪费，复杂度至少为O(n)</p>\n<p>而select就是将所有的fd收集并交给内核，进行一次系统调用，复杂度降为O(1)</p>\n<p><img src=\"/../img/select.png\" alt=\"select\"></p>\n<p>内核会返回一个整数，若小于零，代表没有任何数据或请求到达，若大于零，代表可以进行处理。若等于零，代表等待超时。</p>\n<p><strong>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</strong></p>\n<p><strong>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</strong></p>\n<p>fd_set的大小是有限制的，即单个进程能维护的套接字的大小有限，32位为1024，64位机默认是2048。可以修改。</p>\n<h1 id=\"poll\"><a href=\"#poll\" class=\"headerlink\" title=\"poll\"></a><code>poll</code></h1><p>poll的实现和select很相似，不同的是用于管理文件描述符的集合由数组变为了链表，所以没有最大连接数的限制。存在和select同样的问题</p>\n<h1 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a><code>epoll</code></h1><p> 与前面所有的轮询机制不同，epoll使用的是<strong>事件驱动</strong>，即当发生事件时，每个fd上有注册有回调函数，当网卡接收到数据时会回调该函数，同时将该fd的引用放入rdlist就绪列表中。</p>\n<p>当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。</p>\n<p>如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户。</p>\n<p>避免了遍历所有的fd，只检查发生事件的fd</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; 数据结构\n&#x2F;&#x2F; 每一个epoll对象都有一个独立的eventpoll结构体\n&#x2F;&#x2F; 用于存放通过epoll_ctl方法向epoll对象中添加进来的事件\nstruct eventpoll &#123;\n    &#x2F;*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*&#x2F;\n    struct rb_root  rbr;\n    &#x2F;*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*&#x2F;\n    struct list_head rdlist;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行流程</p>\n<ol>\n<li>调用epoll_create()创建一个ep对象，在内核空间中开辟了一块空间存储eventpoll，返回一个文件句柄，即红黑树的根节点</li>\n<li>调用epoll_ctl()向红黑树中添加、删除、修改fd</li>\n<li>调用epoll_wait()等待，当有事件发生时网卡驱动会调用fd上注册的函数并将该fd添加到rdlist中，解除阻塞。由于fd的引用在红黑树上，所以查找速度很快。</li>\n</ol>\n<p><img src=\"/../img/epoll.png\" alt=\"epoll\"></p>\n<p>总结：</p>\n<ol>\n<li>EPOLL支持的最大文件描述符上限是整个系统最大可打开的文件数目, 1G内存理论上最大创建10万个文件描述符</li>\n<li>每个文件描述符上都有一个callback函数，当socket有事件发生时会回调这个函数将该fd的引用添加到就绪列表中，select和poll并不会明确指出是哪些文件描述符就绪，而epoll会。造成的区别就是，系统调用返回后，调用select和poll的程序需要遍历监听的整个文件描述符找到是谁处于就绪，而epoll则直接处理即可</li>\n<li>select、poll采用轮询的方式来检查文件描述符是否处于就绪态，而epoll采用回调机制。造成的结果就是，随着fd的增加，select和poll的效率会线性降低，而epoll不会受到太大影响，<strong>除非活跃的socket很多</strong></li>\n</ol>\n","feature":true,"text":"套接字编程Socket，表示进程间网络通信的特殊文件类型。本质是内核借助缓冲区形成的伪文件。Linux将套接字封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。 在TCP&#x2F;IP协议中，“IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程。 “...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"网络编程基础知识","slug":"网络编程基础知识","count":1,"path":"api/tags/网络编程基础知识.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">套接字编程</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BD%91%E7%BB%9CIO\"><span class=\"toc-text\">网络IO</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#BIO\"><span class=\"toc-text\">BIO</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%89%B9%E7%82%B9%EF%BC%9A%E9%9D%A2%E5%90%91%E6%B5%81%E7%9A%84%EF%BC%8C%E9%98%BB%E5%A1%9E%E7%9A%84\"><span class=\"toc-text\">特点：面向流的，阻塞的</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#NIO\"><span class=\"toc-text\">NIO</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#selector\"><span class=\"toc-text\">selector</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#channel\"><span class=\"toc-text\">channel</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#buffer\"><span class=\"toc-text\">buffer</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%89%B9%E7%82%B9%EF%BC%9A%E9%9D%A2%E5%90%91%E5%9D%97%EF%BC%8C%E9%9D%9E%E9%98%BB%E5%A1%9E\"><span class=\"toc-text\">特点：面向块，非阻塞</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#select\"><span class=\"toc-text\">select</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#poll\"><span class=\"toc-text\">poll</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#epoll\"><span class=\"toc-text\">epoll</span></a></li></ol>","author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Java基础知识汇总","uid":"2e8864ab557e295b3f55e14c06a19e33","slug":"JAVA基础知识汇总","date":"2022-11-13T07:48:43.000Z","updated":"2022-11-13T07:56:15.222Z","comments":true,"path":"api/articles/JAVA基础知识汇总.json","keywords":null,"cover":null,"text":"Object类中有哪些方法 equals()：未被重写前，由&#x3D;&#x3D;来实现，比较引用数据类型的引用地址是否相同 HashCode()：本地方法，未被重写前返回对象在堆上的唯一地址值，可以看作是对象的身份ID clone()：实现了cloneable接口才可以调用该...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":9,"path":"api/tags/Java基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"洪水淹没算法","uid":"52c15247d71045907737fa627f8aa035","slug":"洪水淹没算法","date":"2022-10-31T06:51:29.000Z","updated":"2022-10-31T11:10:18.126Z","comments":true,"path":"api/articles/洪水淹没算法.json","keywords":null,"cover":[],"text":"695. 岛屿的最大面积 输入：grid &#x3D; [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0]...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"LeetCode初见","slug":"LeetCode初见","count":9,"path":"api/tags/LeetCode初见.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}