{"title":"netty进阶","uid":"c4bbab825e6b5f8c309a31fde6de63ea","slug":"netty进阶","date":"2022-11-24T08:04:09.000Z","updated":"2022-11-24T08:04:45.671Z","comments":true,"path":"api/articles/netty进阶.json","keywords":null,"cover":[],"content":"<h1 id=\"MpscQueue\"><a href=\"#MpscQueue\" class=\"headerlink\" title=\"MpscQueue\"></a>MpscQueue</h1><p>Mpsc来自JCTools，即JAVA的高并发增强包，主要提供了一些 JDK 缺失的并发数据结构</p>\n<ol>\n<li>Spsc 单生产者单消费者</li>\n<li>Mpsc 多生产者单消费者</li>\n<li>Spmc 单生产者多消费者</li>\n<li>Mpmc 多生产者多消费者</li>\n</ol>\n<p>Mpsc 的全称是 Multi Producer Single Consumer，多生产者单消费者，多个生产者线程通过CAS无锁操作提升性能，单个消费者不需要加锁；</p>\n<p>Mpsc Queue 可以保证多个生产者同时访问队列是线程安全的，而且同一时刻只允许一个消费者从队列中读取数据。</p>\n<p>MpscArrayQueue内部的环形数组容量为 2 的次幂，可以通过位运算快速定位到数组对应下标。</p>\n<p><strong>Netty Reactor 线程中的任务队列 taskQueue 必须满足多个生产者可以同时提交任务，所以 JCTools 提供的 Mpsc Queue 非常适合 Netty Reactor 线程模型</strong></p>\n<h2 id=\"MpscArrayQueue为例\"><a href=\"#MpscArrayQueue为例\" class=\"headerlink\" title=\"MpscArrayQueue为例\"></a><strong>MpscArrayQueue为例</strong></h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//继承类的所有变量声明</span>\n<span class=\"token comment\">// ConcurrentCircularArrayQueueL0Pad.java</span>\n<span class=\"token keyword\">long</span> p01<span class=\"token punctuation\">,</span> p02<span class=\"token punctuation\">,</span> p03<span class=\"token punctuation\">,</span> p04<span class=\"token punctuation\">,</span> p05<span class=\"token punctuation\">,</span> p06<span class=\"token punctuation\">,</span> p07<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">long</span> p10<span class=\"token punctuation\">,</span> p11<span class=\"token punctuation\">,</span> p12<span class=\"token punctuation\">,</span> p13<span class=\"token punctuation\">,</span> p14<span class=\"token punctuation\">,</span> p15<span class=\"token punctuation\">,</span> p16<span class=\"token punctuation\">,</span> p17<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// ConcurrentCircularArrayQueue.java</span>\n<span class=\"token comment\">// 计算数组下标的掩码</span>\n<span class=\"token keyword\">protected</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span> mask<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 存放队列数据的数组</span>\n<span class=\"token keyword\">protected</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">E</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> buffer<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// MpmcArrayQueueL1Pad.java</span>\n<span class=\"token keyword\">long</span> p00<span class=\"token punctuation\">,</span> p01<span class=\"token punctuation\">,</span> p02<span class=\"token punctuation\">,</span> p03<span class=\"token punctuation\">,</span> p04<span class=\"token punctuation\">,</span> p05<span class=\"token punctuation\">,</span> p06<span class=\"token punctuation\">,</span> p07<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">long</span> p10<span class=\"token punctuation\">,</span> p11<span class=\"token punctuation\">,</span> p12<span class=\"token punctuation\">,</span> p13<span class=\"token punctuation\">,</span> p14<span class=\"token punctuation\">,</span> p15<span class=\"token punctuation\">,</span> p16<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// MpmcArrayQueueProducerIndexField.java</span>\n<span class=\"token comment\">// 生产者索引</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">long</span> producerIndex<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// MpscArrayQueueMidPad.java</span>\n<span class=\"token keyword\">long</span> p01<span class=\"token punctuation\">,</span> p02<span class=\"token punctuation\">,</span> p03<span class=\"token punctuation\">,</span> p04<span class=\"token punctuation\">,</span> p05<span class=\"token punctuation\">,</span> p06<span class=\"token punctuation\">,</span> p07<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">long</span> p10<span class=\"token punctuation\">,</span> p11<span class=\"token punctuation\">,</span> p12<span class=\"token punctuation\">,</span> p13<span class=\"token punctuation\">,</span> p14<span class=\"token punctuation\">,</span> p15<span class=\"token punctuation\">,</span> p16<span class=\"token punctuation\">,</span> p17<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// MpscArrayQueueProducerLimitField.java</span>\n<span class=\"token comment\">// 生产者索引的最大值</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">long</span> producerLimit<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// MpscArrayQueueL2Pad.java</span>\n<span class=\"token keyword\">long</span> p00<span class=\"token punctuation\">,</span> p01<span class=\"token punctuation\">,</span> p02<span class=\"token punctuation\">,</span> p03<span class=\"token punctuation\">,</span> p04<span class=\"token punctuation\">,</span> p05<span class=\"token punctuation\">,</span> p06<span class=\"token punctuation\">,</span> p07<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">long</span> p10<span class=\"token punctuation\">,</span> p11<span class=\"token punctuation\">,</span> p12<span class=\"token punctuation\">,</span> p13<span class=\"token punctuation\">,</span> p14<span class=\"token punctuation\">,</span> p15<span class=\"token punctuation\">,</span> p16<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// MpscArrayQueueConsumerIndexField.java</span>\n<span class=\"token comment\">// 消费者索引</span>\n<span class=\"token keyword\">protected</span> <span class=\"token keyword\">long</span> consumerIndex<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// MpscArrayQueueL3Pad.java</span>\n<span class=\"token keyword\">long</span> p01<span class=\"token punctuation\">,</span> p02<span class=\"token punctuation\">,</span> p03<span class=\"token punctuation\">,</span> p04<span class=\"token punctuation\">,</span> p05<span class=\"token punctuation\">,</span> p06<span class=\"token punctuation\">,</span> p07<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">long</span> p10<span class=\"token punctuation\">,</span> p11<span class=\"token punctuation\">,</span> p12<span class=\"token punctuation\">,</span> p13<span class=\"token punctuation\">,</span> p14<span class=\"token punctuation\">,</span> p15<span class=\"token punctuation\">,</span> p16<span class=\"token punctuation\">,</span> p17<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在pad类中填充了大量long的数据，其命名没有什么特殊的含义，只是起到填充的作用，这是为了解决<strong>伪共享（false sharing）</strong>问题</p>\n<h2 id=\"伪共享问题\"><a href=\"#伪共享问题\" class=\"headerlink\" title=\"伪共享问题\"></a>伪共享问题</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>你的行为似乎有利于共享，但是却徒增消耗</p></blockquote>\n<p>为了平衡CPU与内存的速度差异，常常会设立多层缓存机制，一般是三层，CPU 读取数据时，首先会从 L1 查找，如果未命中则继续查找 L2，如果还未能命中则继续查找 L3，最后还没命中的话只能从内存中查找，读取完成后再将数据逐级放入缓存中。</p>\n<p>此外，多线程之间共享一份数据的时候，需要其中一个线程将数据写回主存（总线嗅探机制保证可见性），其他线程访问主存数据。</p>\n<p>CPU 缓存由若干个缓存行（Cache Line） 组成，<strong>缓存行是 CPU 缓存可操作的最小单位</strong>。</p>\n<p>Cache Line 的大小与 CPU 架构有关，在目前主流的 64 位架构下，Cache Line 的大小通常为 64 Byte。</p>\n<p>而 Java 中一个 long 类型是 8 Byte，所以一个 Cache Line 可以存储 <strong>8 个 long 类型变量</strong>。</p>\n<p>CPU 在加载内存数据时，会将相邻的数据一同读取到 Cache Line 中（一次加载连续的 64 个字节），这样就可以避免 CPU 频繁与内存进行交互了。</p>\n<p>例如：如果访问一个 long 型的单独变量 a，并且还有另外一个 long 型变量 b 紧挨着它，那么当加载 a 时候将免费加载 b</p>\n<p>伪共享就会在此出现：</p>\n<ol>\n<li>假设有 A、B、C、D 四个变量，线程1尝试修改变量A，于是将A和B、C、D一起都加载到了core1的一个 Cache Line；</li>\n<li>此时，线程2读取变量B，也将A、C、D加载到了core2的同一 Cache Line；</li>\n<li>线程1 对变量 A 进行修改，修改完成后将变量A值写回主存，然后 <strong>CPU1 会通知 CPU2 该缓存行已经失效</strong>；</li>\n<li>线程 2 在Core2 中对变量 C 进行修改时，发现 Cache line 已经失效，所以需要重新从主存中读取数据加载到当前 Cache line 中。</li>\n</ol>\n<p><strong>当多个线程同时修改互相独立的变量时，如果这些变量共享同一个缓存行，就会出现写竞争，导致频繁从主存加载数据，影响性能</strong>。</p>\n<img src=\"../img/JCtool.png\" alt=\"JCtool\" style=\"zoom: 67%;\" />\n\n<p>常见的解决思路就是：<strong>以空间换时间，让不同线程操作的不相干变量加载到不同缓存行，避免相互影响</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">FalseSharingPadding</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">long</span> p1<span class=\"token punctuation\">,</span> p2<span class=\"token punctuation\">,</span> p3<span class=\"token punctuation\">,</span> p4<span class=\"token punctuation\">,</span> p5<span class=\"token punctuation\">,</span> p6<span class=\"token punctuation\">,</span> p7<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">long</span> value <span class=\"token operator\">=</span> <span class=\"token number\">0L</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">long</span> p9<span class=\"token punctuation\">,</span> p10<span class=\"token punctuation\">,</span> p11<span class=\"token punctuation\">,</span> p12<span class=\"token punctuation\">,</span> p13<span class=\"token punctuation\">,</span> p14<span class=\"token punctuation\">,</span> p15<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>变量 value 前后分别填充了 7 个 long 类型的变量。</p>\n<p>这样不论在什么情况下，都可以保证在多线程访问 value 变量时，value 与其他不相关的变量处于不同的 Cache Line</p>\n<h2 id=\"MPSC方法解析\"><a href=\"#MPSC方法解析\" class=\"headerlink\" title=\"MPSC方法解析\"></a>MPSC方法解析</h2><h3 id=\"加入元素\"><a href=\"#加入元素\" class=\"headerlink\" title=\"加入元素\"></a>加入元素</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// MpscArrayQueue.java</span>\n<span class=\"token comment\">//生产者加入元素</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">offer</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> <span class=\"token class-name\">E</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span> <span class=\"token operator\">==</span> e<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NullPointerException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span> mask <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>mask<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 获取生产者索引最大限制</span>\n    <span class=\"token keyword\">long</span> producerLimit <span class=\"token operator\">=</span> <span class=\"token function\">lvProducerLimit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">long</span> pIndex<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">do</span>\n    <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// 获取生产者索引</span>\n        pIndex <span class=\"token operator\">=</span> <span class=\"token function\">lvProducerIndex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 如果生产者索引达到了最大值，防止追尾</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pIndex <span class=\"token operator\">>=</span> producerLimit<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">// 消费者索引，以volatile的形式获取，保证获取的是最新的值</span>\n            <span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span> cIndex <span class=\"token operator\">=</span> <span class=\"token function\">lvConsumerIndex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">// 修改为当前消费者的索引加上数组的大小</span>\n            producerLimit <span class=\"token operator\">=</span> cIndex <span class=\"token operator\">+</span> mask <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token comment\">// 如果依然达到了最大值，则返回false，表示队列满了，再放元素就追尾了</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pIndex <span class=\"token operator\">>=</span> producerLimit<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 队列已满</span>\n            <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token keyword\">else</span>\n            <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token function\">soProducerLimit</span><span class=\"token punctuation\">(</span>producerLimit<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        <span class=\"token comment\">// 更新 producerLimit</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">casProducerIndex</span><span class=\"token punctuation\">(</span>pIndex<span class=\"token punctuation\">,</span> pIndex <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// CAS 更新生产者索引，更新成功则退出，说明当前生产者已经占领索引值</span>\n    <span class=\"token comment\">// 计算生产者索引在数组中下标</span>\n    <span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span> offset <span class=\"token operator\">=</span> <span class=\"token function\">calcCircularRefElementOffset</span><span class=\"token punctuation\">(</span>pIndex<span class=\"token punctuation\">,</span> mask<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 向数组中放入数据</span>\n    <span class=\"token function\">soRefElement</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">,</span> offset<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//获取生产者索引最大值和修改生产者索引最大值</span>\n  <span class=\"token comment\">// 读取producerLimit</span>\n<span class=\"token keyword\">protected</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span> <span class=\"token function\">lvProducerLimit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// producerLimit本身就是volatile修饰的</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>producerLimit<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token comment\">// 保存producerLimit</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">void</span> <span class=\"token function\">soProducerLimit</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// 这个方法会加StoreStore屏障</span>\n        <span class=\"token comment\">// 会把最新值直接更新到主内存中，但其它线程不会立即可见</span>\n        <span class=\"token comment\">// 其它线程需要使用volatile语义才能读取到最新值</span>\n        <span class=\"token comment\">// 这相当于是一种延时更新的方法，比volatile语义的性能要高一些</span>\n        <span class=\"token class-name\">UnsafeAccess</span><span class=\"token punctuation\">.</span><span class=\"token constant\">UNSAFE</span><span class=\"token punctuation\">.</span><span class=\"token function\">putOrderedLong</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">P_LIMIT_OFFSET</span><span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//获取生产者索引，更新生产者索引</span>\n <span class=\"token comment\">// 读取producerIndex</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span> <span class=\"token function\">lvProducerIndex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// producerIndex本身就用volatile修饰了</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>producerIndex<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n \n    <span class=\"token comment\">// CAS更新producerIndex</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">casProducerIndex</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> expect<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> newValue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// CAS更新</span>\n        <span class=\"token keyword\">return</span> <span class=\"token class-name\">UnsafeAccess</span><span class=\"token punctuation\">.</span><span class=\"token constant\">UNSAFE</span><span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSwapLong</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">P_INDEX_OFFSET</span><span class=\"token punctuation\">,</span> expect<span class=\"token punctuation\">,</span> newValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 读取consumerIndex</span>\n  <span class=\"token keyword\">protected</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span> <span class=\"token function\">lvConsumerIndex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token comment\">// 以volatile的形式加载consumerIndex</span>\n      <span class=\"token comment\">// 此时会从内存读取最新的值</span>\n      <span class=\"token keyword\">return</span> <span class=\"token class-name\">UnsafeAccess</span><span class=\"token punctuation\">.</span><span class=\"token constant\">UNSAFE</span><span class=\"token punctuation\">.</span><span class=\"token function\">getLongVolatile</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">C_INDEX_OFFSET</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 修改数组对应偏移量的值</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> <span class=\"token keyword\">void</span> <span class=\"token function\">soElement</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> buffer<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> offset<span class=\"token punctuation\">,</span> <span class=\"token class-name\">E</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// 比使用下标更新数组元素有两个优势</span>\n        <span class=\"token comment\">// 1. 使用Unsafe操作内存更新更快</span>\n        <span class=\"token comment\">// 2. 使用putOrderedObject会直接更新到主内存，而使用下标不会立马更新到主内存</span>\n        <span class=\"token class-name\">UnsafeAccess</span><span class=\"token punctuation\">.</span><span class=\"token constant\">UNSAFE</span><span class=\"token punctuation\">.</span><span class=\"token function\">putOrderedObject</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">,</span> offset<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"/../img/MPSC.png\" alt=\"MPSC\"></p>\n<ol>\n<li>初始时，两个线程拿到的 <code>pIndex</code> 都等于producerIndex为0，小于 producerLimit ；</li>\n<li>接着，两个线程都会尝试 CAS 更新 producerIndex + 1 ，必然只有一个线程能更新成功，另一个失败；</li>\n<li>假设 Thread1 CAS 操作成功，那么它拿到的 <code>pIndex</code> 为0，Thread2 失败后就会重新更新 producerIndex ，然后更新成功，拿到 <code>pIndex</code> 为1；</li>\n<li>最后，根据 <code>pIndex</code> 进行位运算，得到数组对应的下标，然后通过 <code>UNSAFE.putOrderedObject()</code> 方法将数据写入到数组中。</li>\n</ol>\n<h3 id=\"获取元素\"><a href=\"#获取元素\" class=\"headerlink\" title=\"获取元素\"></a>获取元素</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//无CAS</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">E</span> <span class=\"token function\">poll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// 读取consumerIndex的值</span>\n        <span class=\"token keyword\">long</span> cIndex <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">lpConsumerIndex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 计算在数组中的偏移量</span>\n        <span class=\"token keyword\">long</span> offset <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">calcElementOffset</span><span class=\"token punctuation\">(</span>cIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 获取存储元素的数组</span>\n        <span class=\"token class-name\">E</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> buffer <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>buffer<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 取元素，通过StoreStore写入队列，通过LoadLoad取出来的元素是最新值</span>\n        <span class=\"token class-name\">E</span> e <span class=\"token operator\">=</span> <span class=\"token class-name\">UnsafeRefArrayAccess</span><span class=\"token punctuation\">.</span><span class=\"token function\">lvElement</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">,</span> offset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span> <span class=\"token operator\">==</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">// 元素入队是先更新了producerIndex的值，再把更新元素到数组中</span>\n            <span class=\"token comment\">// 如果在两者之间，进行了消费，则此处是无法获取到元素的</span>\n            <span class=\"token comment\">// 所以需要进入下面的判断</span>\n            <span class=\"token comment\">// 判断consumerIndex是否等于producerIndex</span>\n            <span class=\"token comment\">// 只有两者不相等，才可以再消费元素</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cIndex <span class=\"token operator\">==</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">lvProducerIndex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token comment\">// 使用死循环来取元素，直到取到为止</span>\n            <span class=\"token keyword\">do</span> <span class=\"token punctuation\">&#123;</span>\n                e <span class=\"token operator\">=</span> <span class=\"token class-name\">UnsafeRefArrayAccess</span><span class=\"token punctuation\">.</span><span class=\"token function\">lvElement</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">,</span> offset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">// 更新取出的位置元素为null</span>\n        <span class=\"token class-name\">UnsafeRefArrayAccess</span><span class=\"token punctuation\">.</span><span class=\"token function\">spElement</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">,</span> offset<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span><span class=\"token punctuation\">)</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 修改consumerIndex的索引为新值，使用StoreStore屏障，直接更新到主内存</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">soConsumerIndex</span><span class=\"token punctuation\">(</span>cIndex <span class=\"token operator\">+</span> <span class=\"token number\">1L</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 返回出队的元素</span>\n        <span class=\"token keyword\">return</span> e<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>因为只有一个消费者线程，所以整个 poll() 的过程没有 CAS 操作。</p>\n<p>poll() 方法核心思路是获取消费者索引 consumerIndex，然后根据 consumerIndex 计算得出数组对应的偏移量，然后将数组对应位置的元素取出并返回，最后将 consumerIndex 移动到环形数组下一个位置。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">protected</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span> <span class=\"token function\">lpConsumerIndex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n       <span class=\"token comment\">// 直接返回消费者索引</span>\n       <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>consumerIndex<span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">&#125;</span>\n   <span class=\"token comment\">// 保存消费者索引值</span>\n   <span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">soConsumerIndex</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> l<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n       <span class=\"token comment\">// 这个方法会加StoreStore屏障</span>\n       <span class=\"token comment\">// 会把最新值直接更新到主内存中，但其它线程不会立即可见</span>\n       <span class=\"token comment\">// 其它线程需要使用volatile语义才能读取到最新值</span>\n       <span class=\"token comment\">// 这相当于是一种延时更新的方法，比volatile语义的性能要高一些</span>\n       <span class=\"token class-name\">UnsafeAccess</span><span class=\"token punctuation\">.</span><span class=\"token constant\">UNSAFE</span><span class=\"token punctuation\">.</span><span class=\"token function\">putOrderedLong</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">C_INDEX_OFFSET</span><span class=\"token punctuation\">,</span> l<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> <span class=\"token keyword\">void</span> <span class=\"token function\">spElement</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> buffer<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> offset<span class=\"token punctuation\">,</span> <span class=\"token class-name\">E</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// 更新buffer在offset处的元素值</span>\n        <span class=\"token class-name\">UnsafeAccess</span><span class=\"token punctuation\">.</span><span class=\"token constant\">UNSAFE</span><span class=\"token punctuation\">.</span><span class=\"token function\">putObject</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">,</span> offset<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n \n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">E</span> <span class=\"token function\">lvElement</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> buffer<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> offset<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// 获取buffer在offset处的元素值</span>\n        <span class=\"token keyword\">return</span> <span class=\"token class-name\">UnsafeAccess</span><span class=\"token punctuation\">.</span><span class=\"token constant\">UNSAFE</span><span class=\"token punctuation\">.</span><span class=\"token function\">getObjectVolatile</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">,</span> offset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//计算偏移量</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">long</span> <span class=\"token function\">calcElementOffset</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> index<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> mask<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// REF_ARRAY_BASE，基础地址，数组在内存中的地址</span>\n        <span class=\"token comment\">// REF_ELEMENT_SHIFT，可以简单地看作一个元素占用多少字节</span>\n        <span class=\"token comment\">// 64位系统中一个引用对象占用64位，也就是8字节，但是压缩模式下占用4字节</span>\n        <span class=\"token comment\">// index &amp; mask 计算数组下标</span>\n        <span class=\"token comment\">// 比如数组大小为4，mask就为3时，4&amp;3=100&amp;011=0</span>\n        <span class=\"token keyword\">return</span> <span class=\"token constant\">REF_ARRAY_BASE</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>index <span class=\"token operator\">&amp;</span> mask<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token constant\">REF_ELEMENT_SHIFT</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ol>\n<li>Unsafe 方法<ol>\n<li>**putOrderedXxx()**，使用 StoreStore 屏障，会把最新值更新到主内存，但不会立即失效其它缓存行中的数据，是一种延时更新机制；</li>\n<li>**putXxxVolatile()**，使用 StoreLoad 屏障，会把最新值更新到主内存，同时会把其它缓存行的数据失效，或者说会刷新其它缓存行的数据；</li>\n<li>**putXxx(obj, offset)**，不使用任何屏障，更新对象对应偏移量的值；</li>\n<li>**getXxxVolatile()**，使用 LoadLoad 屏障，会从主内存获取最新值；</li>\n<li>**getXxx(obj, offset)**，不使用任何屏障，读取对象对应偏移量的值；</li>\n</ol>\n</li>\n</ol>\n<p>总结：</p>\n<h4 id=\"MPSC实现高并发和高性能使用了哪些方法？\"><a href=\"#MPSC实现高并发和高性能使用了哪些方法？\" class=\"headerlink\" title=\"MPSC实现高并发和高性能使用了哪些方法？\"></a><em><strong>MPSC实现高并发和高性能使用了哪些方法？</strong></em></h4><ol>\n<li>LazySet 延迟更新机制：在更新producerLimit，消费者索引，和环形数组元素时使用StoreStore屏障，虽然写操作结果有纳秒级的延迟，但是由于没有立刻读取的操作，所以没有问题，且提升了性能</li>\n<li>使用偏移量来更新数组元素，比下标性能更好</li>\n<li>使用UNSAFE方法来直接操作内存</li>\n<li>使用long型变量填充来避免伪共享问题</li>\n</ol>\n","feature":true,"text":"MpscQueueMpsc来自JCTools，即JAVA的高并发增强包，主要提供了一些 JDK 缺失的并发数据结构 Spsc 单生产者单消费者 Mpsc 多生产者单消费者 Spmc 单生产者多消费者 Mpmc 多生产者多消费者 Mpsc 的全称是 Multi Producer S...","link":"","photos":[],"count_time":{"symbolsCount":"8.4k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"netty","slug":"netty","count":3,"path":"api/tags/netty.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#MpscQueue\"><span class=\"toc-text\">MpscQueue</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#MpscArrayQueue%E4%B8%BA%E4%BE%8B\"><span class=\"toc-text\">MpscArrayQueue为例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BC%AA%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">伪共享问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#MPSC%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">MPSC方法解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%A0%E5%85%A5%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">加入元素</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">获取元素</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#MPSC%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E6%80%A7%E8%83%BD%E4%BD%BF%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F\"><span class=\"toc-text\">MPSC实现高并发和高性能使用了哪些方法？</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"下一个更大元素","uid":"50b4378888e6118830afe84cb7b95b4c","slug":"下一个更大元素","date":"2022-11-24T05:39:19.000Z","updated":"2022-11-24T06:30:35.102Z","comments":true,"path":"api/articles/下一个更大元素.json","keywords":null,"cover":[],"text":"556.下一个更大元素 III给你一个正整数 n ，请你找出符合条件的最小整数，其由重新排列 n 中存在的每位数字组成，并且其值大于 n 。如果不存在这样的正整数，则返回 -1 。 注意 ，返回的整数应当是一个 32 位整数 ，如果存在满足题意的答案，但不是 32 位整数 ，同样...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"LeetCode初见","slug":"LeetCode初见","count":10,"path":"api/tags/LeetCode初见.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}