{"title":"netty——reactor线程模型简述","uid":"0bdbdbbdfc4f649a26dfdf23cf4f1d34","slug":"netty项目记录——react线程模型简述","date":"2022-10-22T09:16:43.000Z","updated":"2022-10-23T09:26:13.439Z","comments":true,"path":"api/articles/netty项目记录——react线程模型简述.json","keywords":null,"cover":[],"content":"<h1 id=\"BIO\"><a href=\"#BIO\" class=\"headerlink\" title=\"BIO\"></a>BIO</h1><p>Block IO:同步阻塞IO，一般传统的JDK内置的Socket编程就是BIO。其底层流程是：</p>\n<ol>\n<li>创建socket接口，号为x</li>\n<li>使用bind函数将接口号与端口号进行绑定</li>\n<li>进行listen监听事件或者是read读事件，且会一直阻塞在该命令，直到有客户端连接或者发送数据</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>如果是在单线程环境下，由于是阻塞地获取结果，只能有一个客户端连接</li>\n<li>而如果是在多线程环境下，需要不断地新建线程来接收客户端，这样会浪费大量的空间</li>\n</ol>\n<p><img src=\"/../img/react1.jpg\" alt=\"react1\"></p>\n<h4 id=\"特点：面向流的，阻塞的\"><a href=\"#特点：面向流的，阻塞的\" class=\"headerlink\" title=\"特点：面向流的，阻塞的\"></a>特点：面向流的，阻塞的</h4><p>java1.4以前的io模型，一连接对一个线程，原始的IO是面向流的，不存在缓存的概念。</p>\n<p>Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。</p>\n<p>此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区</p>\n<p>Java IO的各种流是阻塞的，这意味着当一个线程调用read或 write方法时，该线程被阻塞，直到有一些数据被读取，或数据完全写入，该线程在此期间不能再干任何事情了。</p>\n<h1 id=\"NIO\"><a href=\"#NIO\" class=\"headerlink\" title=\"NIO\"></a>NIO</h1><p>NonBlock IO:非阻塞IO</p>\n<p><code>Java NIO 全称 java non-blocking IO，是指JDK 1.4 及以上版本提供的新API（New IO）。从 JDK1.4 开始，Java 提供了一系列改进的输入/输出的新特性，为所有的原始类型（boolean类型除外）提供缓存支持的数据容器，使用它可以提供同步非阻塞式的高伸缩性网络。</code></p>\n<p>NIO 有三大核心部分：Channel(通道) ， Buffer(缓冲区) ,Selector(选择器) </p>\n<p><img src=\"/../img/reactor2.png\" alt=\"reactor2\"></p>\n<h2 id=\"selector\"><a href=\"#selector\" class=\"headerlink\" title=\"selector\"></a>selector</h2><p>实现循环监听通道信号的组件</p>\n<p>一个selector 对应一个线程， 多个channel以事件的方式注册于selector，代表一个进程便可以处理多个连接</p>\n<p>selector 会根据不同的事件，在各个通道上切换，只有在连接&#x2F;通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，避免了多线程之间的上下文切换导致的开销</p>\n<h3 id=\"channel\"><a href=\"#channel\" class=\"headerlink\" title=\"channel\"></a>channel</h3><p>NIO的通道类似于流，但有些区别如下：</p>\n<ol>\n<li>通道可以同时进行读写，而流只能读或者只能写</li>\n<li>通道可以实现异步读写数据</li>\n<li>通道可以从缓冲读数据，也可以写数据到缓冲</li>\n</ol>\n<p>channel 是双向的, 可以返回底层操作系统的情况, 比如Linux ，底层的操作系统通道就是双向的</p>\n<h3 id=\"buffer\"><a href=\"#buffer\" class=\"headerlink\" title=\"buffer\"></a>buffer</h3><p>Buffer 就是一个内存块 ，底层是有一个数组</p>\n<p>channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer</p>\n<p>数据的读取写入是通过Buffer, 这个和BIO不同 , BIO 中要么是输入流，或者是输出流，不能双向</p>\n<p>但是NIO的Buffer 是可以读也可以写, 需要 flip 方法切换</p>\n<h4 id=\"特点：面向块，非阻塞\"><a href=\"#特点：面向块，非阻塞\" class=\"headerlink\" title=\"特点：面向块，非阻塞\"></a>特点：面向块，非阻塞</h4><p>NIO是面向缓冲区的。数据被读取到缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性。</p>\n<p>Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。</p>\n<p>通俗理解：NIO是可以做到用一个线程来处理多个操作的。假设有10000个请求过来,根据实际情况，可以分配50或者100个线程来处理。selector会不断循环监听channel，如果通道中没有数据即没有请求时它可以去处理别的通道或者做其他的事情，如果通道中有数据它就会选择这个通道然后进行处理，实现了一个线程处理多个连接。</p>\n<h1 id=\"reactor线程模型\"><a href=\"#reactor线程模型\" class=\"headerlink\" title=\"reactor线程模型\"></a>reactor线程模型</h1><p>reactor就是IO多路复用（NIO）+线程池的结合优化版</p>\n<p>reactor线程模型：主要有四个角色</p>\n<ol>\n<li>Reactor：把IO事件分配给对应的handler处理，就是IO多路复用的select实现，即轮询监听</li>\n<li>Acceptor：处理客户端连接事件，创建Handler对象</li>\n<li>Handler：将自身与事件绑定，执行非阻塞读、写任务，负责channel的读入，业务处理完成后，负责将结果写出channel</li>\n<li>worker：用来处理handler传来的业务的线程</li>\n</ol>\n<p>其中1，2，3存放于主线程中，也称为bossGroup</p>\n<p>4存放于从线程，也就是线程池中，也称为workerGroup</p>\n<p>单reactor-多线程</p>\n<p><img src=\"/../img/reactor3.png\" alt=\"reactor3\"></p>\n<p>主从reactor-多线程</p>\n<p>这种模型下是把Reactor线程拆分了mainReactor和subReactor两个部分</p>\n<p>mainReactor只处理连接事件，读写事件交给subReactor来处理。业务逻辑还是由线程池来处理</p>\n<p><img src=\"/../img/reactor4.png\" alt=\"reactor4\"></p>\n","text":"BIOBlock IO:同步阻塞IO，一般传统的JDK内置的Socket编程就是BIO。其底层流程是： 创建socket接口，号为x 使用bind函数将接口号与端口号进行绑定 进行listen监听事件或者是read读事件，且会一直阻塞在该命令，直到有客户端连接或者发送数据 缺点：...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"netty高并发项目","slug":"netty高并发项目","count":1,"path":"api/tags/netty高并发项目.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#BIO\"><span class=\"toc-text\">BIO</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%89%B9%E7%82%B9%EF%BC%9A%E9%9D%A2%E5%90%91%E6%B5%81%E7%9A%84%EF%BC%8C%E9%98%BB%E5%A1%9E%E7%9A%84\"><span class=\"toc-text\">特点：面向流的，阻塞的</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#NIO\"><span class=\"toc-text\">NIO</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#selector\"><span class=\"toc-text\">selector</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#channel\"><span class=\"toc-text\">channel</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#buffer\"><span class=\"toc-text\">buffer</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%89%B9%E7%82%B9%EF%BC%9A%E9%9D%A2%E5%90%91%E5%9D%97%EF%BC%8C%E9%9D%9E%E9%98%BB%E5%A1%9E\"><span class=\"toc-text\">特点：面向块，非阻塞</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#reactor%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">reactor线程模型</span></a></li></ol>","author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"mySQL","uid":"de0127f4fce15732bd481675d6959d45","slug":"mySQL","date":"2022-10-25T14:02:31.000Z","updated":"2022-10-27T09:32:18.031Z","comments":true,"path":"api/articles/mySQL.json","keywords":null,"cover":[],"text":"MYSQL关系型数据库，插件式的存储引擎，这种架构可以根据业务的需求和实际需要选择合适的存储引擎。 客户端通过协议与服务器连接，发送查询语句，先检查缓存是否命中，若命中直接返回，否则进行语句解析 预处理，检查语句是否有语法错误，查询优化（是否会使用索引扫描），生成查询计划，启动查...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"数据库基础","slug":"数据库基础","count":2,"path":"api/tags/数据库基础.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"线程和协程","uid":"911607c17b916d6cafeabb37f57539b9","slug":"协程","date":"2022-10-20T08:53:01.000Z","updated":"2022-10-25T14:00:01.012Z","comments":true,"path":"api/articles/协程.json","keywords":null,"cover":[],"text":"一个程序开多少线程合适CPU密集型一个完整的请求，IO操作可以在很短的时间内完成，CPU的运算时间占大部分，线程等待时间接近0 单核CPU：一个CPU对应一个线程，且IO时间短，所以不适合使用多线程。若使用多线程，会造成线程竞争，造成不必要的浪费 多核：如果是多核CPU，就可以最...","link":"","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"面试突击","slug":"面试突击","count":7,"path":"api/tags/面试突击.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}