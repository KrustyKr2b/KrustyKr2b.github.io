{"title":"HashMap","uid":"a7e90bf30b292f0f6e0827bd156cab5e","slug":"HashMap","date":"2022-10-30T14:05:57.000Z","updated":"2022-11-21T07:34:56.365Z","comments":true,"path":"api/articles/HashMap.json","keywords":null,"cover":[],"content":"<h1 id=\"HashCode\"><a href=\"#HashCode\" class=\"headerlink\" title=\"HashCode\"></a><code>HashCode</code></h1><p>HashCode()，在未被重写前，即object类中，是一个Native方法，默认返回JVM生成的随机数，是一个独特值，可以看作是对象的身份ID</p>\n<p>而在String类中，HashCode被重写</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n       <span class=\"token keyword\">int</span> h <span class=\"token operator\">=</span> hash<span class=\"token punctuation\">;</span>\n       <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> value<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n           <span class=\"token keyword\">char</span> val<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n\n           <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> value<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n               h <span class=\"token operator\">=</span> <span class=\"token number\">31</span> <span class=\"token operator\">*</span> h <span class=\"token operator\">+</span> val<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n           <span class=\"token punctuation\">&#125;</span>\n           hash <span class=\"token operator\">=</span> h<span class=\"token punctuation\">;</span>\n       <span class=\"token punctuation\">&#125;</span>\n       <span class=\"token keyword\">return</span> h<span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><em><strong>为什么使用31作为乘数？？？</strong></em></p>\n<ol>\n<li>31是一个不大不小的奇质数，如果选择偶数计算，会导致乘积运算时的数据溢出。如果选择一个很小的数，那么<code>hashcode</code>会分布在一个很小的范围内，容易造成哈希值的冲突；如果选择一个很大的数，那么可能会超出整型变量的范围。</li>\n<li>在二进制中31等于2&lt;&lt;5-1，那么<code>31*i</code>即为<code>（i&lt;&lt;5）-i</code>，这种乘积运算可以直接通过位移来提升性能，JVM也支持这种优化方式</li>\n<li>不止31，33，37，39，41也可以作为乘数，当我们使用超过50,000个 单词来计算<code>hashcode</code>，这5个乘数都得到的哈希值冲突都小于7，31最小。同时hash的目的就是让数据尽可能分散排布，而以31作为乘数得到的结果分布最为均匀。</li>\n</ol>\n<h3 id=\"HashMap如何计算索引值\"><a href=\"#HashMap如何计算索引值\" class=\"headerlink\" title=\"HashMap如何计算索引值\"></a>HashMap如何计算索引值</h3><h4 id=\"第一步：计算hash\"><a href=\"#第一步：计算hash\" class=\"headerlink\" title=\"第一步：计算hash\"></a>第一步：计算hash</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token function\">hash</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> h<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token number\">0</span> <span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">=</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">^</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">>>></span> <span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//将key的hashCode值 与 key的hashCode值的高16位(无符号右移)，进行^异或运算，得到一个hash值</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>原理：引入扰动函数</p>\n<p>扰动函数就是为了增大随机性，减少碰撞，在引入扰动函数后散列表的数据分布更加均匀</p>\n<h4 id=\"第二步：计算索引\"><a href=\"#第二步：计算索引\" class=\"headerlink\" title=\"第二步：计算索引\"></a>第二步：计算索引</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//n为数组长度从</span>\nindex <span class=\"token operator\">=</span> hash <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>一般的散列算法是以取余%来计算散列值的，但是CPU在做 &#x2F;除 或 %取余运算时，效率是很低的。</p>\n<p>所以使用位运算<code>与</code>，可以实现相同的结果，而且效率更高。</p>\n<h2 id=\"HashMap的容量\"><a href=\"#HashMap的容量\" class=\"headerlink\" title=\"HashMap的容量\"></a>HashMap的容量</h2><p>HashMap的初始化容量通常设置为2的幂次方大小，未指定大小时<strong>默认初始化为16</strong>，</p>\n<p>这与<code>hash &amp; (n-1)</code>密切相关，<strong>2次幂大小的数与运算与取余运算的效果相同</strong></p>\n<p>要减一，即n-1，我们才能获得一个01111这样的值（<strong>在和hash进行与运算的时候才可以获得范围合法的索引</strong>）</p>\n<p>若指定一个奇数作为capacity，就会调用<code>tableSizeFor()</code></p>\n<p>若传入17，向正方向寻找一个最接近17的2的幂次方，即为32</p>\n<p>通过位移运算+或运算将17的每一位都改为1，然后再加1，最后就可以得到32</p>\n<h3 id=\"扩容\"><a href=\"#扩容\" class=\"headerlink\" title=\"扩容\"></a>扩容</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//负载因子</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">float</span> <span class=\"token constant\">DEFAULT_LOAD_FACTOR</span> <span class=\"token operator\">=</span> <span class=\"token number\">0.75f</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>负载因子就是一个阈值，当数据量超过这个阈值后，便要进行扩容</p>\n<p>因为<code>hashcode</code>的特性，一个散列表地址可能对应多个元素，所以即使元素数量大于散列表地址数量，也可能出现无法把散列表占满的情况，在这种情况下，某些位置会出现碰撞，这降低了<code>HashMap</code>的性能</p>\n<p>所以当散列表的位置使用到一定程度时，就需要进行扩容，默认0.75，也就是当使用3&#x2F;4后，就进行扩容</p>\n<p><em><strong>为什么扩容时会直接乘以2</strong>：</em></p>\n<ol>\n<li>以2倍扩容的方式扩容，元素在新表中的位置要么不动，要么原脚标位+扩容长度（二的幂次方偏移量），这样会使扩容的效率大大提高（<strong>JDK1.8后扩容不用重新rehash</strong>）</li>\n<li>可以使元素均匀的散布hashmap中，减少hash碰撞</li>\n</ol>\n<h3 id=\"转换红黑树的条件\"><a href=\"#转换红黑树的条件\" class=\"headerlink\" title=\"转换红黑树的条件\"></a><em>转换红黑树的条件</em></h3><ol>\n<li>链表长度大于8</li>\n<li>Entry数组大于64</li>\n</ol>\n<h3 id=\"HashCode-和equals-的关系，如何使用？\"><a href=\"#HashCode-和equals-的关系，如何使用？\" class=\"headerlink\" title=\"HashCode()和equals()的关系，如何使用？\"></a><em>HashCode()和equals()的关系，如何使用？</em></h3><ol>\n<li>equals()来自Object()类，默认使用&#x3D;&#x3D;来比较地址值，判断引用指向是否是一个对象。通过重写该方法来定义新的规则，比如String类中的equals方法就是逐个比较字符串的字符</li>\n<li>HashCode()来自Object()类，这是一个本地方法，在没有被重写时默认返回对象在堆内存上的独特值，可以认为是对象在堆内存中的身份证号，具有唯一性。重写HashCode后，可以返回计算而出的哈希值，即散列算法，用于确定元素的桶位置，例如HashMap</li>\n<li>如何使用：查找一个元素，当调用散列算法后，快速定位到相应位置，若该桶内有元素，则调用equals()，由于哈希碰撞的存在，HashCode()相等时，不一定就是相应的元素，所以必须调用equals()来判断是否为要查找的元素</li>\n</ol>\n<h3 id=\"x3D-x3D-和equals的区别\"><a href=\"#x3D-x3D-和equals的区别\" class=\"headerlink\" title=\"&#x3D;&#x3D;和equals的区别\"></a><em>&#x3D;&#x3D;和equals的区别</em></h3><p>&#x3D;&#x3D;：若比较的是基本数据类型，则比较的是数值是否相等；如果比较的是引用数据类型，则比较的是地址值</p>\n<p>equals()：用来比较引用指向的对象地址是否相等。不可用于基本数据类型的比较。</p>\n<p>在Object类中，equals就是由&#x3D;&#x3D;来实现的，可以认为equals在被重写前，两者作用是相等的</p>\n<h3 id=\"为何重写equals后一定要重写hashcode\"><a href=\"#为何重写equals后一定要重写hashcode\" class=\"headerlink\" title=\"为何重写equals后一定要重写hashcode?\"></a><em>为何重写equals后一定要重写hashcode?</em></h3><p>根据hashcode的规则，两个对象相等其哈希值一定相等</p>\n<p>所以当重写equals后比如在String类中，两个字面量相同的字符串对象equals后一定返回true</p>\n<p>但是如果不重写hashcode，默认返回JVM生成的独特值，此时两个对象的hashcode可能不会相等，与上文说的规则相矛盾。所以必须重写hashcode来符合这个规则</p>\n<h3 id=\"HashMap为什么是线程不安全的\"><a href=\"#HashMap为什么是线程不安全的\" class=\"headerlink\" title=\"HashMap为什么是线程不安全的\"></a><em>HashMap为什么是线程不安全的</em></h3><ol>\n<li>JDK1.7可能造成死循环：由于resize时的数据迁移采用头插法（当时的人觉得比较高效），而头插法会导致链表顺序颠倒（因为先插入的元素在后面），当线程A未完成transfer操作时被挂起，而线程B成功完成了transfer操作，线程A再次获取时间片后继续执行transfer，由于头插法导致链表顺序颠倒，便有可能导致生成环形链表。</li>\n<li>JDK1.8可能造成数据丢失：假设两个线程A、B都在进行put操作，并且hash函数计算出的插入下标是相同的，当线程A执行过程中由于时间片耗尽导致被挂起，而线程B得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程A获得时间片，由于之前已经进行了hash碰撞的判断，所有此时不会再进行判断，而是直接进行插入，这就导致了线程B插入的数据被线程A覆盖了，从而线程不安全。</li>\n</ol>\n<h3 id=\"HashMap如何保证线程安全\"><a href=\"#HashMap如何保证线程安全\" class=\"headerlink\" title=\"HashMap如何保证线程安全\"></a><em>HashMap如何保证线程安全</em></h3><ol>\n<li>Collections.synchronizedMap()方法传入HashMap的引用变量，返回一个新的Map，这个新的Map就是线程安全的，返回的并不是HashMap，而是map的一种实现。该方法封装了所有不安全的HashMap方法，使用了synchronized方法来进行互斥，和HashTable差不多，该方法使用代理模式new了一个新的类，这个类实现了Map接口。该方法的优点：实现简单；缺点：加锁的粒度较大，性能比较差。被synchronizedMap()包裹的map是可以传入null 键的。而concurrentHashmap不可以。</li>\n<li>使用ConcurrentHashMap，使用了新的锁机制，把hashmap拆分成了多个独立的块，这样在高并发的情况下减少了锁冲突的可能。使用的是NonfairSync，这个特性调用CAS指令来保证原子性和互斥性。如果多个线程恰好操作到同一个segment，只有一个线程得到运行。优点：互斥的代码段小，性能更好，发生锁碰撞的几率低。缺点：代码繁琐。</li>\n</ol>\n<h1 id=\"ConcurrenHashMap和HashTable\"><a href=\"#ConcurrenHashMap和HashTable\" class=\"headerlink\" title=\"ConcurrenHashMap和HashTable\"></a>ConcurrenHashMap和HashTable</h1><p>HashTable它的每一个方法都是使用了synchronized同步锁机制，将整个入口锁起来，在多线程的情况下，他整个数组结构的入口就只能一条线程执行完成之后其他线程才能进入，无论下标是否相同，是否存在hash碰撞。</p>\n<p>而ConcurrenHashMap由JDK1.5引入，降低了锁粒度且保证了线程安全</p>\n<p>HashEntry内的成员变量value等都是<strong>volatile类型</strong>的，这样就保证别的线程对value值的修改，get方法可以马上看到</p>\n<p>在JDK1.7之前，在初始化ConcurrentHashMap的时候，会初始化一个Segment数组,容量为<strong>16</strong>，Segment内部有一个table数组，存储entry数组+链表的结构</p>\n<p>每个Segment都继承了ReentrantLock类，也就是说每个Segment类本身就是一个锁，使用了分段锁的机制，降低了锁粒度。</p>\n<p>在查找时，定位segment和定位table后，依次扫描这个table元素下的的链表，要么找到元素，要么返回null。</p>\n<p>在JDK1.8之后，引入红黑树且取消了segment设计。使用synchronize关键字，为每一个node对象加同步锁，将锁的粒度将到最低。</p>\n<h1 id=\"TreeMap和HashMap\"><a href=\"#TreeMap和HashMap\" class=\"headerlink\" title=\"TreeMap和HashMap\"></a>TreeMap和HashMap</h1><p><em><strong>为什么HashMap是无序的？</strong></em></p>\n<p>在对HashMap元素进行遍历的时候，是以数组下标为顺序，若该slot下存在链表和红黑树，则向下遍历，直到遍历完该slot下的所有元素。</p>\n<p>众所周知，出现哈希冲突而存放在链表中的元素是不会按照顺序排放的，所以HashMap无序。</p>\n<p>而<strong>TreeMap</strong> 的底层数据结构是一棵红黑树，红黑树上的元素都是有顺序的</p>\n<p><em><strong>TreeMap如何实现排序？</strong></em></p>\n<p>当使用无参构造时<code>TreeMap treeMap = new TreeMap();</code>，默认是升序的</p>\n<p>但是TreeMap的构造方法可以传入一个Comparator对象，重写其中的Compare方法就可以定于以何种规则排序key</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//按照key字母顺序排序</span>\n<span class=\"token class-name\">TreeMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> treeMap <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TreeMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Comparator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">compare</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> o1<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> o2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span>o1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span>o2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//Compare方法的原理：返回-1，无需交换元素，返回1，交换元素</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>HashMap：适用于Map插入，删除，定位元素；</p>\n<p>TreeMap：适用于按自然顺序或自定义顺序遍历键（key）,性能不如HashMap</p>\n<h1 id=\"LinkedHashMap和HashMap\"><a href=\"#LinkedHashMap和HashMap\" class=\"headerlink\" title=\"LinkedHashMap和HashMap\"></a>LinkedHashMap和HashMap</h1><p><img src=\"/../img/linkedHashmap.png\" alt=\"linkedHashmap\"></p>\n<p>简单的说，LinkedHashMap其实就是在HashMap的基础上再维护了一个双向链表，来保持顺序性</p>\n<p>这个顺序默认是<strong>插入顺序</strong>，可以将其看作是实现hashmap查找效率的链表</p>\n<p>可以通过设置accessOrder设置为访问顺序</p>\n<p>accessOrder默认为false，当设置为true时，会在每次get或put后将元素移动至双向链表尾部（LRU）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//使用linkedHashMap模拟实现LRU</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">LRUCache</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> cap<span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">LinkedHashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> cache <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedHashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">LRUCache</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> capacity<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>cap <span class=\"token operator\">=</span> capacity<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token comment\">//加入链表尾部</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">makeRecently</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">int</span> val <span class=\"token operator\">=</span> cache<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        cache<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        cache<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>cache<span class=\"token punctuation\">.</span><span class=\"token function\">containsKey</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">makeRecently</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> cache<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    \n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> key<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>cache<span class=\"token punctuation\">.</span><span class=\"token function\">containsKey</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            cache<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">makeRecently</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>cache<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">>=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>cap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">//找到链表头部的key,就是最久未使用的key,调用一次next()就是第一个元素</span>\n            <span class=\"token keyword\">int</span> toBeRemoved <span class=\"token operator\">=</span> cache<span class=\"token punctuation\">.</span><span class=\"token function\">keySet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">iterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            cache<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>toBeRemoved<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        cache<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","text":"HashCodeHashCode()，在未被重写前，即object类中，是一个Native方法，默认返回JVM生成的随机数，是一个独特值，可以看作是对象的身份ID 而在String类中，HashCode被重写 public int hashCode() &#123; int h ...","link":"","photos":[],"count_time":{"symbolsCount":"5.7k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":7,"path":"api/tags/Java基础知识.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#HashCode\"><span class=\"toc-text\">HashCode</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HashMap%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E7%B4%A2%E5%BC%95%E5%80%BC\"><span class=\"toc-text\">HashMap如何计算索引值</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E8%AE%A1%E7%AE%97hash\"><span class=\"toc-text\">第一步：计算hash</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E8%AE%A1%E7%AE%97%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">第二步：计算索引</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HashMap%E7%9A%84%E5%AE%B9%E9%87%8F\"><span class=\"toc-text\">HashMap的容量</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%A9%E5%AE%B9\"><span class=\"toc-text\">扩容</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BD%AC%E6%8D%A2%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\">转换红黑树的条件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HashCode-%E5%92%8Cequals-%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F\"><span class=\"toc-text\">HashCode()和equals()的关系，如何使用？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#x3D-x3D-%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">&#x3D;&#x3D;和equals的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BD%95%E9%87%8D%E5%86%99equals%E5%90%8E%E4%B8%80%E5%AE%9A%E8%A6%81%E9%87%8D%E5%86%99hashcode\"><span class=\"toc-text\">为何重写equals后一定要重写hashcode?</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84\"><span class=\"toc-text\">HashMap为什么是线程不安全的</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HashMap%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">HashMap如何保证线程安全</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ConcurrenHashMap%E5%92%8CHashTable\"><span class=\"toc-text\">ConcurrenHashMap和HashTable</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#TreeMap%E5%92%8CHashMap\"><span class=\"toc-text\">TreeMap和HashMap</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#LinkedHashMap%E5%92%8CHashMap\"><span class=\"toc-text\">LinkedHashMap和HashMap</span></a></li></ol>","author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"计算机网络","uid":"293c17b4d2a4292133cc4d1ffd7f8725","slug":"计算机网络","date":"2022-10-31T06:51:13.000Z","updated":"2022-11-20T08:28:21.063Z","comments":true,"path":"api/articles/计算机网络.json","keywords":null,"cover":[],"text":"计算机网络的分层模型OSI七层模型 应用层：计算机上的网络应用，传输应用报文，如HTTP，SMTP 表示层：用于处理交换信息的表示格式（处理语法和处理语义），格式变换，数据加密解密，数据压缩等功能 会话层：向表示层建立连接，并传输有序的数据，也就是建立同步SYN 运输层：负责两个...","link":"","photos":[],"count_time":{"symbolsCount":"9.8k","symbolsTime":"9 mins."},"categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","count":1,"path":"api/tags/计算机基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"买股票问题","uid":"6841591cdd97dd7e1d719dfd22576c72","slug":"买股票问题","date":"2022-10-30T13:19:55.000Z","updated":"2022-10-30T13:38:02.967Z","comments":true,"path":"api/articles/买股票问题.json","keywords":null,"cover":null,"text":"121. 买卖股票的最佳时机你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。 输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"LeetCode初见","slug":"LeetCode初见","count":9,"path":"api/tags/LeetCode初见.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}