{"title":"HashMap","uid":"a7e90bf30b292f0f6e0827bd156cab5e","slug":"HashMap","date":"2022-10-30T14:05:57.000Z","updated":"2022-10-31T06:15:48.697Z","comments":true,"path":"api/articles/HashMap.json","keywords":null,"cover":null,"content":"<h1 id=\"HashCode\"><a href=\"#HashCode\" class=\"headerlink\" title=\"HashCode\"></a><code>HashCode</code></h1><p>HashCode()，在未被重写前，即object类中，是一个Native方法，默认返回对象在堆中的地址，是一个独特值，可以看作是对象的身份ID</p>\n<p>而在String类中，HashCode被重写</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n       <span class=\"token keyword\">int</span> h <span class=\"token operator\">=</span> hash<span class=\"token punctuation\">;</span>\n       <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> value<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n           <span class=\"token keyword\">char</span> val<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n\n           <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> value<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n               h <span class=\"token operator\">=</span> <span class=\"token number\">31</span> <span class=\"token operator\">*</span> h <span class=\"token operator\">+</span> val<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n           <span class=\"token punctuation\">&#125;</span>\n           hash <span class=\"token operator\">=</span> h<span class=\"token punctuation\">;</span>\n       <span class=\"token punctuation\">&#125;</span>\n       <span class=\"token keyword\">return</span> h<span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>为什么使用31作为乘数？？？</strong></p>\n<ol>\n<li>31是一个不大不小的奇质数，如果选择偶数计算，会导致乘积运算时的数据溢出。如果选择一个很小的数，那么<code>hashcode</code>会分布在一个很小的范围内，容易造成哈希值的冲突；如果选择一个很大的数，那么可能会超出整型变量的范围。</li>\n<li>在二进制中31等于2&lt;&lt;5-1，那么<code>31*i</code>即为<code>（i&lt;&lt;5）-i</code>，这种乘积运算可以直接通过位移来提升性能，JVM也支持这种优化方式</li>\n<li>不止31，33，37，39，41也可以作为乘数，当我们使用超过50,000个 单词来计算<code>hashcode</code>，这5个乘数都得到的哈希值冲突都小于7，31最小。同时hash的目的就是让数据尽可能分散排布，而以31作为乘数得到的结果分布最为均匀。</li>\n</ol>\n<h3 id=\"HashMap如何计算索引值\"><a href=\"#HashMap如何计算索引值\" class=\"headerlink\" title=\"HashMap如何计算索引值\"></a>HashMap如何计算索引值</h3><h4 id=\"第一步：计算hash\"><a href=\"#第一步：计算hash\" class=\"headerlink\" title=\"第一步：计算hash\"></a>第一步：计算hash</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token function\">hash</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> h<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token number\">0</span> <span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">=</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">^</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">>>></span> <span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//将key的hashCode值 与 key的hashCode值的高16位(无符号右移)，进行^异或运算，得到一个hash值</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>原理：引入扰动函数</p>\n<p>扰动函数就是为了增大随机性，减少碰撞，在引入扰动函数后散列表的数据分布更加均匀</p>\n<h4 id=\"第二步：计算索引\"><a href=\"#第二步：计算索引\" class=\"headerlink\" title=\"第二步：计算索引\"></a>第二步：计算索引</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//n为数组长度从</span>\nindex <span class=\"token operator\">=</span> hash <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>一般的散列算法是以取余%来计算散列值的，但是CPU在做 &#x2F;除 或 %取余运算时，效率是很低的。</p>\n<p>所以使用位运算<code>与</code>，可以实现相同的结果，而且效率更高。</p>\n<h2 id=\"HashMap的容量\"><a href=\"#HashMap的容量\" class=\"headerlink\" title=\"HashMap的容量\"></a>HashMap的容量</h2><p>HashMap的初始化容量通常设置为2的幂次方大小，未指定大小时<strong>默认初始化为16</strong>，</p>\n<p>这与<code>hash &amp; (n-1)</code>密切相关，<strong>2次幂大小的数与运算与取余运算的效果相同</strong></p>\n<p>要减一，即n-1，我们才能获得一个01111这样的值（<strong>在和hash进行与运算的时候才可以获得范围合法的索引</strong>）</p>\n<p>若指定一个奇数作为capacity，就会调用<code>tableSizeFor()</code></p>\n<p>若传入17，向正方向寻找一个最接近17的2的幂次方，即为32</p>\n<p>通过位移运算+或运算将17的每一位都改为1，然后再加1，最后就可以得到32</p>\n<h3 id=\"扩容\"><a href=\"#扩容\" class=\"headerlink\" title=\"扩容\"></a>扩容</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//负载因子</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">float</span> <span class=\"token constant\">DEFAULT_LOAD_FACTOR</span> <span class=\"token operator\">=</span> <span class=\"token number\">0.75f</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>负载因子就是一个阈值，当数据量超过这个阈值后，便要进行扩容</p>\n<p>因为<code>hashcode</code>的特性，一个散列表地址可能对应多个元素，所以即使元素数量大于散列表地址数量，也可能出现无法把散列表占满的情况，在这种情况下，某些位置会出现碰撞，这降低了<code>HashMap</code>的性能</p>\n<p>所以当散列表的位置使用到一定程度时，就需要进行扩容，默认0.75，也就是当使用3&#x2F;4后，就进行扩容</p>\n<p><strong>为什么扩容时会直接乘以2</strong>：</p>\n<ol>\n<li>以2倍扩容的方式扩容，元素在新表中的位置要么不动，要么原脚标位+扩容长度（二的幂次方偏移量），这样会使扩容的效率大大提高（<strong>JDK1.8后扩容不用重新rehash</strong>）</li>\n<li>可以使元素均匀的散布hashmap中，减少hash碰撞</li>\n</ol>\n<h3 id=\"转换红黑树的条件\"><a href=\"#转换红黑树的条件\" class=\"headerlink\" title=\"转换红黑树的条件\"></a>转换红黑树的条件</h3><ol>\n<li>链表长度大于8</li>\n<li>Entry数组大于64</li>\n</ol>\n","feature":true,"text":"HashCodeHashCode()，在未被重写前，即object类中，是一个Native方法，默认返回对象在堆中的地址，是一个独特值，可以看作是对象的身份ID 而在String类中，HashCode被重写 public int hashCode() &#123; int h =...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":12,"path":"api/tags/Java基础知识.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#HashCode\"><span class=\"toc-text\">HashCode</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HashMap%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E7%B4%A2%E5%BC%95%E5%80%BC\"><span class=\"toc-text\">HashMap如何计算索引值</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E8%AE%A1%E7%AE%97hash\"><span class=\"toc-text\">第一步：计算hash</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E8%AE%A1%E7%AE%97%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">第二步：计算索引</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HashMap%E7%9A%84%E5%AE%B9%E9%87%8F\"><span class=\"toc-text\">HashMap的容量</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%A9%E5%AE%B9\"><span class=\"toc-text\">扩容</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BD%AC%E6%8D%A2%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\">转换红黑树的条件</span></a></li></ol></li></ol></li></ol>","author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"计算机网络","uid":"293c17b4d2a4292133cc4d1ffd7f8725","slug":"计算机网络","date":"2022-10-31T06:51:13.000Z","updated":"2022-10-31T12:42:47.400Z","comments":true,"path":"api/articles/计算机网络.json","keywords":null,"cover":[],"text":"计算机网络的分层模型OSI七层模型 应用层：计算机上的网络应用，传输应用报文，如HTTP，SMTP 表示层：用于处理交换信息的表示格式（处理语法和处理语义），格式变换，数据加密解密，数据压缩等功能 会话层：向表示层建立连接，并传输有序的数据，也就是建立同步SYN 运输层：负责两个...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","count":1,"path":"api/tags/计算机基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"买股票问题","uid":"6841591cdd97dd7e1d719dfd22576c72","slug":"买股票问题","date":"2022-10-30T13:19:55.000Z","updated":"2022-10-30T13:38:02.967Z","comments":true,"path":"api/articles/买股票问题.json","keywords":null,"cover":null,"text":"121. 买卖股票的最佳时机你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。 输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"LeetCode初见","slug":"LeetCode初见","count":8,"path":"api/tags/LeetCode初见.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}