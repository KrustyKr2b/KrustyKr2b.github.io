{"title":"JVM相关知识","uid":"d819bd760b595babeef6cadb7a50d452","slug":"Java随想","date":"2022-09-12T04:37:43.000Z","updated":"2022-10-25T03:19:36.771Z","comments":true,"path":"api/articles/Java随想.json","keywords":null,"cover":[],"content":"<h1 id=\"JAVA内存区域讲解\"><a href=\"#JAVA内存区域讲解\" class=\"headerlink\" title=\"JAVA内存区域讲解\"></a>JAVA内存区域讲解</h1><p>运行时数据区域分为两部分：线程共享和线程私有</p>\n<h2 id=\"线程共享区域：\"><a href=\"#线程共享区域：\" class=\"headerlink\" title=\"线程共享区域：\"></a>线程共享区域：</h2><ol>\n<li><p>堆：是虚拟机内存的最大的一块，此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存，注意是“几乎”，JDK1.7之后，当方法中的对象引用没有被返回或者未被外部使用，就会直接在栈上分配内存。同时，堆也是垃圾收集器管理的主要区域，所以也被称为GC堆。</p>\n</li>\n<li><p>JDK1.8之前：方法区（运行时常量池）；JDK1.8之后：无，将方法区移至本地内存。方法区是运行时数据区域的一个逻辑区域，在不同虚拟上方法区的实现是不同的，当虚拟机要使用一个类时，它需要读取并解析class文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的类信息，<strong>字段信息，方法信息，常量，静态变量</strong>，即时编译器编译后的代码缓存。</p>\n<p>方法区有两种具体实现：永久代permanent gen和元空间metaspace。前者拥有一个由本身JVM设置的大小上限，无法调整，而在8版本之后，转而使用元空间，后者使用的是计算机的直接内存，溢出的概率更小。</p>\n<p>方法区包含运行时常量池和字符串常量池，后者是为了减少string类的内存消耗而专门开辟的，可以避免字符串的重复创建。方法区是一个公共且抽象的概念，在不同虚拟机上可以有不同的实现。</p>\n<p><img src=\"/../img/MethodArea.png\" alt=\"MethodArea\"></p>\n<p><img src=\"/../img/MethodArea1.png\" alt=\"MethodArea1\"></p>\n</li>\n</ol>\n<p><img src=\"/../img/MethodArea2.png\" alt=\"MethodArea2\"></p>\n<h2 id=\"线程私有区域：\"><a href=\"#线程私有区域：\" class=\"headerlink\" title=\"线程私有区域：\"></a>线程私有区域：</h2><ol>\n<li>虚拟机栈：由一个个栈帧组成，栈帧内包含：<strong>局部变量表</strong>（八大原始类型，对象引用），<strong>操作数栈</strong>（作为方法调用的中转站，存放中间计算结果，实现CPU的寄存器的功能），<strong>动态链接</strong>（当一个方法需要调用其他方法时，动态链接就是未来将符号引用转换为调用方法的直接引用），<strong>方法返回地址</strong>。方法调用的数据通过栈进行传递，每一个方法没调用时都会有一个对应的栈帧被压入，每一个方法调用结束后，都会有一个栈帧被弹出。当函数调用陷入无限循环，或者压栈太多，导致线程请求的栈的深度超过JAVA虚拟机栈的最大深度时，就会抛出,stackoverflow。栈帧的弹出：return语句，异常抛出，随方法的调用而创建，随方法的结束而销毁，所以无论方法是否正常完成还是异常完成，都可以视为方法结束。</li>\n<li>本地方法栈：和虚拟机栈十分相似，但是本地方法是由c++编写的，所以这个栈是为native方法服务的，同样也会创建栈帧，同样也会抛出栈溢出的错误。</li>\n<li>程序计数器PC：一块较小的内存空间，就是一个计数器，可以看作是当前线程执行的字节码的行号指示器，字节码解释器通过改变PC的值来选取下一条要执行的字节码指令，从而实现循环，跳转，异常处理等功能。每个线程都需要一个独立的PC，PC也是唯一一个不会出现outofmemory的内存区域。执行native方法时PC为空。</li>\n</ol>\n<h2 id=\"JAVA堆详解\"><a href=\"#JAVA堆详解\" class=\"headerlink\" title=\"JAVA堆详解\"></a>JAVA堆详解</h2><p>堆分为三部分：新生代，老年代，永久代（JDK8移除，功能由元空间代替实现）</p>\n<h3 id=\"新生代Young-Gen\"><a href=\"#新生代Young-Gen\" class=\"headerlink\" title=\"新生代Young Gen\"></a>新生代Young Gen</h3><p>新生代用来存放新生的对象，一般占据1&#x2F;3。新生代中存放着大量刚刚创建的对象，但是大部分对象的存活时间都很短，所以会进行频繁的GC。新生代又分为三个部分eden，from，to。这三个部分默认为8：1：1</p>\n<p>为什么要分配为8：1：1</p>\n<p>因为大部分对象都是朝生夕死，所以Eden区就设置大一些，存活区就设置小一些</p>\n<p><strong>Eden区：</strong>Java新创建的对象绝大部分会分配在Eden区（如果对象太大，则直接分配到老年代）。当Eden区内存不够的时候，就会触发MinorGC（新生代采用的是<strong>复制算法</strong>），对新生代进行一次垃圾回收。</p>\n<p><strong>SurvivorFrom区和SurvivorTo区：</strong>在GC开始的时候，对象只会存在于Eden区和名为From的Survivor区，To区是空的，一次MinorGc过后，Eden区和SurvivorFrom区存活的对象会移动到SurvivorTo区中，然后会清空Eden区和SurvivorFrom区，并对存活的对象的年龄+1，如果对象的年龄达到15，则直接分配到老年代。MinorGC完成后，SurvivorFrom区和SurvivorTo区的功能进行互换。下一次MinorGC时，会把SurvivorTo区和Eden区存活的对象放入SurvivorFrom区中，并计算对象存活的年龄。</p>\n<h3 id=\"老年代Old-Gen\"><a href=\"#老年代Old-Gen\" class=\"headerlink\" title=\"老年代Old Gen\"></a>老年代Old Gen</h3><p>老年代用于存放生命周期较长的内存对象，老年代比较稳定，不会频繁的进行MajorGC。</p>\n<p>而在MaiorGC之前才会先进行一次MinorGc，使得新生的对象进入老年代而导致空间不够才会触发。当无法找到足够大的连续空间分配给新创建的较大对象也会提前触发一次MajorGC进行垃圾回收腾出空间。</p>\n<p>在老年代中，MajorGC采用了标记—清除算法：首先扫描一次所有老年代里的对象，标记出存活的对象，然后回收没有标记的对象。MajorGC的耗时比较长。因为要扫描再回收。MajorGC会产生内存碎片，当老年代也没有内存分配给新来的对象的时候，就会抛出OOM（Out of Memory）异常。</p>\n<h3 id=\"永久代Permanent-Gen（方法区）\"><a href=\"#永久代Permanent-Gen（方法区）\" class=\"headerlink\" title=\"永久代Permanent Gen（方法区）\"></a>永久代Permanent Gen（方法区）</h3><p>永久代中包含了虚拟机中可以通过反射获取到的数据，比如Class对象和Method对象。JVM用于描述应用程序中用到的类和方法的元数据，如类的层级信息(包名，父类名，修饰符，接口)，方法的编译信息（参数，返回值，修饰符）及字节码，常量，静态变量就存储在永久代中，如果有类不再需要使用，空间会被释放留给其他类，full GC会进行永久代的回收</p>\n<p>不同的java虚拟机之间可能会进行类共享，因此又分为只读区和读写区</p>\n<p>永久代是有大小上限的，默认为64M，在堆内存中划出一块连续的空间分配给永久代</p>\n<h3 id=\"元空间Meta-Space\"><a href=\"#元空间Meta-Space\" class=\"headerlink\" title=\"元空间Meta Space\"></a>元空间Meta Space</h3><p>JDK8开始，永久代被彻底删除，替换为元空间，JVM忽略了permsize这个参数，也就是没有outOfMemoryError异常。</p>\n<p>字符串常量池和静态变量也转移到了堆内存，因为字符串在永久代中容易造成性能问题</p>\n<p>元空间使用本地内存来存储类的元数据，所以不再归JVM管理</p>\n<p>为什么要抛弃永久代：</p>\n<ol>\n<li>永久代的大小在启动时就会固定好，很难进行调优修改</li>\n<li>元空间使用堆外内存，不由JVM管理，由OS来管理，所以可以不暂停GC的情况下释放类数据</li>\n<li>元空间的每个类加载器都有专门的存储空间</li>\n<li>充分利用了java语言规范的好处：类及相关的元数据的生命周期与类加载器一致</li>\n<li>省略了GC的扫描和压缩的时间</li>\n<li>元空间里面对象的位置是固定的，无需堆内存内GC时将对象不断移动</li>\n<li>元空间只进行线性分配，指针碰撞+OS本地内存&#x3D;大小上限提升，分配内存更迅捷</li>\n</ol>\n<h1 id=\"GC\"><a href=\"#GC\" class=\"headerlink\" title=\"GC\"></a>GC</h1><p>堆内有大量的对象，所以需要GC来不断处理，以保证堆内存空间的合理使用</p>\n<p>并行（Parallel）：多个GC线程并行工作，用户线程等待</p>\n<p>并发（Concurrent）：用户线程和垃圾GC线程同时进行</p>\n<p>如何判断一个对象能否被删除</p>\n<p>被虚拟机栈，本地方法栈，静态变量，字符串常量引用的对象，不能被GC</p>\n<p>若可以被删除：打上标记</p>\n<ol>\n<li>标记清理算法：扫描一遍全部对象，删除带标记的对象，容易产生内存碎片</li>\n<li>标记整理算法：扫描一遍全部对象，删除带标记的对象，清理后需要紧凑，不断移动对象，代价比较大</li>\n<li>复制算法：分为1区和2区，无需删除的对象被紧凑复制到2区，然后清空1区，需要两倍的内存</li>\n</ol>\n<img src=\"../img/GC.png\" alt=\"GC\" style=\"zoom:150%;\" />\n\n<h2 id=\"新生代的GC\"><a href=\"#新生代的GC\" class=\"headerlink\" title=\"新生代的GC\"></a>新生代的GC</h2><p>垃圾回收器：（全部都是复制算法，参考上文）</p>\n<ol>\n<li>Serial：最基本，历史最悠久的收集器。单线程，简单，适合于单CPU环境，没有线程交互的开销，所以可以全力进行垃圾回收。需要Stop The World，但是效率不高</li>\n<li>ParNew：其实就是多线程版的Serial，适合于多CPU环境，同样需要Stop The World</li>\n<li>Parallel Scavenge：吞吐量优先收集器，同样是并行的。PS自带GC自适应调节策略：动态设置Eden和存活区的比例，新生代的大小，晋升老年代的对象年龄。虚拟机会根据运行状态信息来动态调整以获取最优的吞吐量和响应时间。</li>\n</ol>\n<h2 id=\"老年代的GC\"><a href=\"#老年代的GC\" class=\"headerlink\" title=\"老年代的GC\"></a>老年代的GC</h2><ol>\n<li>CMS：回收停顿时间优先收集器，基于标记清除算法，并发（Concurrent），低停顿。将整个GC过程拉长，初始标记-&gt;并发标记-&gt;重新标记-&gt;并发清除。并发标记和并发清除是可以和用户线程同时进行的，另外两个阶段需要Stop The World。对CPU资源敏感，因为需要并发，所以若CPU资源不够，性能会急剧下降</li>\n<li>Serial Old：老年代版本Serial，标记整理</li>\n<li>Parallel Old：老年代版本的Parallel，标记整理</li>\n</ol>\n<h2 id=\"G1收集器\"><a href=\"#G1收集器\" class=\"headerlink\" title=\"G1收集器\"></a>G1收集器</h2><p>一款面向服务端应用的垃圾收集器，基于复制算法，基本步骤和CMS差不多，但是解决了CMS存在的问题</p>\n<p>步骤：</p>\n<ol>\n<li>初始标记：单线程+Stop The World，只扫描和GC root直接关联的对象</li>\n<li>并发标记：并发，进行GC root tracing，在初始标记的基础上继续向下追溯标记，标记出所有存活对象，用户线程可并发</li>\n<li>重新标记：Stop The World，修正并发标记期间因为用户线程的运行而造成的标记变动</li>\n<li>并发清除：并发进行回收</li>\n</ol>\n<p>特点：</p>\n<ol>\n<li>并行+并发：G1能充分利用多CPU来缩短停顿时间</li>\n<li>分代收集：G1可以独自管理整个堆</li>\n<li>空间整合：G1不会产生碎片</li>\n<li>可预测的停顿：G1能够建立可预测的停顿时间模型，能让使用者明确指定在一个时间段内，消耗在GC上的时间不超过N毫秒，原理：复制算法优先处理垃圾多的区域，可控</li>\n</ol>\n<h2 id=\"垃圾收集器如何选择呢\"><a href=\"#垃圾收集器如何选择呢\" class=\"headerlink\" title=\"垃圾收集器如何选择呢\"></a>垃圾收集器如何选择呢</h2><p>Client模式下的虚拟机：Serial</p>\n<p>注重高吞吐量以及CPU资源敏感：Parallel Scavenge +Parallel Old</p>\n<p>最小化Stop The World时间：G1或者ParNew+CMS</p>\n<h1 id=\"类文件结构解析\"><a href=\"#类文件结构解析\" class=\"headerlink\" title=\"类文件结构解析\"></a>类文件结构解析</h1><p>字节码：.class扩展名</p>\n<ol>\n<li>魔数：magic number：每个class文件的头4个字节被称为魔数（CAFEBABE）唯一作用便是确定这个文件是否为一个能被虚拟机接收的class文件</li>\n<li>class文件版本号：小版本号+大版本号。高版本的JVM可以执行低版本的class文件</li>\n<li>常量池：常量池计数器+常量池数据区。计数器从1开始，若有某些指向常量池的索引值需要表达“不引用常量池中的项目”这一含义，则可以将索引值设为0。常量池数据区中主要存储两大常量：<strong>字面量：即文本字符串，或者被final修饰的常量等</strong>。<strong>符号引用：package，接口的全名，方法名称或描述符，字段名称或描述符等等</strong>。与c不同的是，java在编译时，不会有连接这一步骤，而是会在虚拟机加载class文件时进行动态连接，虚拟机在进行类加载时，将会从常量池中获得对应的符号引用，在类创建时或运行时解析，并翻译到具体的内存地址中。常量池中的每一项都是一个表。常量池可以看作是class文件里的资源仓库，占用空间最大。</li>\n<li>访问标志：用于识别类或者接口的访问信息，比如class是类还是接口，public还是abstract，是否被final修饰等</li>\n<li>索引集合：当前类，父类，接口索引集合</li>\n<li>字段表集合：描述接口或类中声明的变量，不包括方法内声明的局部变量。字段计数器+字段表数据区</li>\n<li>方法表集合：方法计数器+方法数据区</li>\n</ol>\n<h1 id=\"类加载过程\"><a href=\"#类加载过程\" class=\"headerlink\" title=\"类加载过程\"></a>类加载过程</h1><h3 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h3><p>加载主要完成下面三件事情</p>\n<ol>\n<li>通过全类名获取定义此类的二进制字节流</li>\n<li>将字节流代表的静态数据结构转换为方法区的运行时数据结构</li>\n<li>在内存中生成一个代表该类的class对象，作为方法区数据的访问入口</li>\n</ol>\n<h3 id=\"连接——验证\"><a href=\"#连接——验证\" class=\"headerlink\" title=\"连接——验证\"></a>连接——验证</h3><ol>\n<li>文件格式验证：是否符合class文件格式的规范（CAFEBABE），主次版本号是否在虚拟机的处理范围内，常量池中的的常量是否都可以支持</li>\n<li>元数据验证：对字节码的信息进行语义分析，保证描述的信息符合java的语言规范，比如这个类是否有父类，这个类是否继承了不被允许继承的类</li>\n<li>字节码验证：这是最为复杂的一个阶段，通过数据流和控制流的分析，确定程序语义是合法，符合逻辑的，比如确保任意时刻操作数栈都能配合工作</li>\n<li>符号引用验证：确保解析动作能正确执行</li>\n</ol>\n<h3 id=\"连接——准备\"><a href=\"#连接——准备\" class=\"headerlink\" title=\"连接——准备\"></a>连接——准备</h3><p>这个阶段会正式为变量分配内存并设置初始变量，仅包括类变量,static</p>\n<h3 id=\"连接——解析\"><a href=\"#连接——解析\" class=\"headerlink\" title=\"连接——解析\"></a>连接——解析</h3><p>将常量池里的符号引用替换为直接引用，主要针对，接口，字段，类方法。符号引用就是用一组符号来描述目标，可以是任何字面量；直接引用就是直接指向目标的指针，偏移量</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>这是类加载的最后一步，执行初始化方法<clinit>，在这一步，JVM才真正开始执行类中定义的java程序代码</p>\n<h1 id=\"HOTSPOT虚拟机对象创建的过程\"><a href=\"#HOTSPOT虚拟机对象创建的过程\" class=\"headerlink\" title=\"HOTSPOT虚拟机对象创建的过程\"></a>HOTSPOT虚拟机对象创建的过程</h1><h4 id=\"类加载检测\"><a href=\"#类加载检测\" class=\"headerlink\" title=\"类加载检测\"></a>类加载检测</h4><p>虚拟机遇到new指令时，首先检查这条指令的参数是否能在常量池中定位到这个类的引用，检查这个符号引用代表的类是否已经被加载过，解析，或初始化。若没有，则先执行相应的类加载过程。</p>\n<h4 id=\"分配内存\"><a href=\"#分配内存\" class=\"headerlink\" title=\"分配内存\"></a>分配内存</h4><p>为新对象分配内存，所需内存大小在类加载完成后就可以确定，分配内存的任务等同于将一块确定大小的内存从堆中划分出来。</p>\n<ol>\n<li>指针碰撞：堆内存规整，将用过的内存和没用过的内存整合到两边，中间有一个分界指针，只需要将指针移动相应大小即可完成分配。</li>\n<li>空闲列表：堆内存不规整，虚拟机会维护一个列表，列表中会记录哪些内存块是可用的，寻找到一块满足大小的内存分配后，更新列表。</li>\n</ol>\n<h4 id=\"初始化零值\"><a href=\"#初始化零值\" class=\"headerlink\" title=\"初始化零值\"></a>初始化零值</h4><p>当内存分配后，需要将分配到的内存空间都初始化为0值，这一步保证了对象的字段在java代码中可以不赋值就能直接被使用，程序能访问这些字段的数据类型对应的0值</p>\n<h4 id=\"设置对象头\"><a href=\"#设置对象头\" class=\"headerlink\" title=\"设置对象头\"></a>设置对象头</h4><p>这个对象是哪个类的实例，对象的hashcode，如何才能找到类的元数据信息，等信息处理后放入对象头中、</p>\n<h4 id=\"执行init方法\"><a href=\"#执行init方法\" class=\"headerlink\" title=\"执行init方法\"></a>执行init方法</h4><p>在虚拟机的视角来看，对象的创建已经完成，但是对于java程序来说，对象创建才刚刚开始，在init之前所有的字段都是零值，init之后便会将对象按照程序员的意愿进行初始化，一个真正可用的对象才算真正创建。</p>\n","text":"JAVA内存区域讲解运行时数据区域分为两部分：线程共享和线程私有 线程共享区域： 堆：是虚拟机内存的最大的一块，此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存，注意是“几乎”，JDK1.7之后，当方法中的对象引用没有被返回或者未被外部使用，就会直...","link":"","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":3,"path":"api/tags/Java基础知识.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JAVA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AE%B2%E8%A7%A3\"><span class=\"toc-text\">JAVA内存区域讲解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%8C%BA%E5%9F%9F%EF%BC%9A\"><span class=\"toc-text\">线程共享区域：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%E5%8C%BA%E5%9F%9F%EF%BC%9A\"><span class=\"toc-text\">线程私有区域：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JAVA%E5%A0%86%E8%AF%A6%E8%A7%A3\"><span class=\"toc-text\">JAVA堆详解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B0%E7%94%9F%E4%BB%A3Young-Gen\"><span class=\"toc-text\">新生代Young Gen</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%80%81%E5%B9%B4%E4%BB%A3Old-Gen\"><span class=\"toc-text\">老年代Old Gen</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B0%B8%E4%B9%85%E4%BB%A3Permanent-Gen%EF%BC%88%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%89\"><span class=\"toc-text\">永久代Permanent Gen（方法区）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%83%E7%A9%BA%E9%97%B4Meta-Space\"><span class=\"toc-text\">元空间Meta Space</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#GC\"><span class=\"toc-text\">GC</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B0%E7%94%9F%E4%BB%A3%E7%9A%84GC\"><span class=\"toc-text\">新生代的GC</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%80%81%E5%B9%B4%E4%BB%A3%E7%9A%84GC\"><span class=\"toc-text\">老年代的GC</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#G1%E6%94%B6%E9%9B%86%E5%99%A8\"><span class=\"toc-text\">G1收集器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%91%A2\"><span class=\"toc-text\">垃圾收集器如何选择呢</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">类文件结构解析</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">类加载过程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%A0%E8%BD%BD\"><span class=\"toc-text\">加载</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9E%E6%8E%A5%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81\"><span class=\"toc-text\">连接——验证</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9E%E6%8E%A5%E2%80%94%E2%80%94%E5%87%86%E5%A4%87\"><span class=\"toc-text\">连接——准备</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9E%E6%8E%A5%E2%80%94%E2%80%94%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">连接——解析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">初始化</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#HOTSPOT%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">HOTSPOT虚拟机对象创建的过程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A3%80%E6%B5%8B\"><span class=\"toc-text\">类加载检测</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98\"><span class=\"toc-text\">分配内存</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9B%B6%E5%80%BC\"><span class=\"toc-text\">初始化零值</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%A4%B4\"><span class=\"toc-text\">设置对象头</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%89%A7%E8%A1%8Cinit%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">执行init方法</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"子集排列问题sucks","uid":"e0c4de6a72c616ec823d805c53472b1a","slug":"子集排列问题sucks","date":"2022-09-13T05:14:49.000Z","updated":"2022-10-13T13:40:03.754Z","comments":true,"path":"api/articles/子集排列问题sucks.json","keywords":null,"cover":null,"text":"回溯算法解决所有子集排列问题形式一：元素无重复，且不可复选，即nums中所有元素均唯一，且最多使用一次 /* 组合/子集问题回溯算法框架 */ //使用start参数来避免复选 void backtrack(int[] nums, int start) &#123; // 回溯算...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"算法归纳","slug":"算法归纳","count":2,"path":"api/tags/算法归纳.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"JAVA的字符串","uid":"b8307bc7cc4dad51e597289f7dfa286e","slug":"Java的字符串","date":"2022-08-14T04:57:02.000Z","updated":"2022-10-13T08:13:50.657Z","comments":true,"path":"api/articles/Java的字符串.json","keywords":null,"cover":null,"text":"String&amp;StringBuilderString的底层数据结构是数组char value[] public final class String implements java.io.Serializable, Comparable&lt;String>, CharS...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":3,"path":"api/tags/Java基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}