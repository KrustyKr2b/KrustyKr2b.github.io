{"title":"Java基础知识汇总","uid":"2e8864ab557e295b3f55e14c06a19e33","slug":"JAVA基础知识汇总","date":"2022-11-13T07:48:43.000Z","updated":"2022-11-22T04:40:24.250Z","comments":true,"path":"api/articles/JAVA基础知识汇总.json","keywords":null,"cover":null,"content":"<h3 id=\"Object类中有哪些方法\"><a href=\"#Object类中有哪些方法\" class=\"headerlink\" title=\"Object类中有哪些方法\"></a><em>Object类中有哪些方法</em></h3><ol>\n<li><strong>equals</strong>()：未被重写前，由&#x3D;&#x3D;来实现，比较引用数据类型的引用地址是否相同</li>\n<li>HashCode()：本地方法，未被重写前返回对象在堆上的唯一地址值，可以看作是对象的身份ID</li>\n<li>clone()：实现了cloneable接口才可以调用该方法，实现对象的浅复制</li>\n<li>getClass()：final修饰，获取运行时的类型</li>\n<li>toString()：若参数为变量，则返回对应变量的string对象，若参数为一个对象，则返回堆内存对象的地址</li>\n<li><strong>finalize</strong>()：在GC准备释放对象所占用的内存空间之前，它将首先调用finalize()方法，finalize()方法中一般用于释放非Java 资源（如打开的文件资源、数据库连接等）,或是调用native方法时分配的内存(比如C语言的malloc()）。</li>\n<li>wait()：使线程阻塞等待</li>\n<li>notify()：唤醒等待的线程</li>\n<li>nofityAll()：唤醒在该对象上等待的所有线程</li>\n</ol>\n<h3 id=\"JAVA的八大数据类型\"><a href=\"#JAVA的八大数据类型\" class=\"headerlink\" title=\"JAVA的八大数据类型\"></a><em>JAVA的八大数据类型</em></h3><p>可以分为四个大类：整型，字符型，浮点型，布尔型</p>\n<ol>\n<li>boolean：JVM中并没有提供boolean专用的字节码指令，在编译后会以int型来表示，<strong>4字节</strong>。boolean[]会以byte数组来表示，<strong>1字节</strong></li>\n<li>char：可以赋值单字符以及整型数值，表示数字的取值范围为0~65536，<strong>2字节</strong></li>\n<li>byte：范围为-128 - 128，1字节</li>\n<li>short：范围为：-32768-32768，2字节</li>\n<li>int：范围为：-2,147,483,648-2,147,483,647，4字节</li>\n<li>long：范围为；-2^63-2^63-1，8字节</li>\n<li>float：单精度浮点数，4字节</li>\n<li>double：双精度浮点数，8字节</li>\n</ol>\n<h3 id=\"接口和抽象类有哪些区别\"><a href=\"#接口和抽象类有哪些区别\" class=\"headerlink\" title=\"接口和抽象类有哪些区别\"></a><em>接口和抽象类有哪些区别</em></h3><p>相同点：</p>\n<ol>\n<li>不能被实例化</li>\n<li>可以将抽象类和接口类型作为引用类型</li>\n<li>一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部实现</li>\n</ol>\n<p>不同点：</p>\n<ol>\n<li>抽象类中可以定义构造器，可以有抽象方法和具体方法，抽象类中可以定义成员变量，一个类只能继承一个抽象类，抽象类中可以包含静态方法，抽象类中的成员可以由private,protected,public修饰</li>\n<li>接口中的成员全部都是由public修饰，不能定义构造器，只能有抽象方法，不能有静态方法，一个类可以实现多个接口</li>\n</ol>\n<p>除了语法上的异同之外，两者还有语义上的不同。抽象类适合描述某一更具体的概念，比如狗<strong>是</strong>一种<strong>动物</strong>，而不能说狗<strong>实现</strong>了动物的<strong>接口</strong>。接口则用于描述多个事物的共同特征，比如鸟<strong>实现了</strong>flyable接口，这个flyable就是一种<strong>行为特征</strong>，当然也可以描述其他的特征。</p>\n<h3 id=\"String-StringBuilder-StringBuffer的区别\"><a href=\"#String-StringBuilder-StringBuffer的区别\" class=\"headerlink\" title=\"String,StringBuilder,StringBuffer的区别\"></a><em>String,StringBuilder,StringBuffer的区别</em></h3><ol>\n<li>String的底层是一个由final修饰的char型数组，String是静态只读的，当改变变量的值时，其实只是改变了引用对象的指向，指向了新创建的字符串，而原字符串仍存在于字符串常量池。</li>\n<li>StringBuffer（JDK1.0引入）：引用对象指向一个空间，包含一个可自行扩容的char型数组和字符串长度计数变量Count，StringBuffer的所有方法均被synchronized修饰。扩容时会开辟一块新的空间用于创建更大的数组，并将原数据复制过去，并改变引用对象的指向。</li>\n<li>StringBuilder(JDK1.5引入)：取消了synchronized方法修饰，所以效率更高，但是线程不安全。</li>\n</ol>\n<h3 id=\"Object-o-new-Object-在内存中占用多少个字节？\"><a href=\"#Object-o-new-Object-在内存中占用多少个字节？\" class=\"headerlink\" title=\"Object o = new Object()在内存中占用多少个字节？\"></a><em><code>Object o = new Object()</code>在内存中占用多少个字节？</em></h3><p>一个对象在内存中的存储布局：<code>markword</code>：8字节，<strong>锁信息+HashCode+GC信息</strong>；<code>classPointer</code>:4字节；对齐：保证大小能<strong>被8整除</strong>；数据段：即对象内声明的变量</p>\n<p>所以一个空对象<strong>最小为16字节</strong></p>\n<h3 id=\"对象如何定位？\"><a href=\"#对象如何定位？\" class=\"headerlink\" title=\"对象如何定位？\"></a><em>对象如何定位？</em></h3><p><code>HotSpot</code>虚拟机默认使用直接定位：指针直接指向堆内存内的对象，对象内的<code>classPointer</code>指向方法区内的class。优点：直接访问快；缺点：GC时，若需要移动对象，则指针也需要改变</p>\n<p>句柄方式（间接方式）：指针指向另一个结构体，该结构体内有两个指针，分别指向堆内存和方法区。优点：对象小，GC时无需改动指针。缺点：比直接访问更慢</p>\n<h3 id=\"对象的创建过程\"><a href=\"#对象的创建过程\" class=\"headerlink\" title=\"对象的创建过程\"></a><em>对象的创建过程</em></h3><p>new指令：申请内存空间，为成员变量设立默认值</p>\n<p><code>invokespecial</code>汇编码：调用构造方法，为成员变量设定初始值</p>\n<p><code>astore</code>汇编码：建立引用，让指针指向堆</p>\n<h3 id=\"面向对象有哪些特征\"><a href=\"#面向对象有哪些特征\" class=\"headerlink\" title=\"面向对象有哪些特征\"></a><em>面向对象有哪些特征</em></h3><p>面向对象是一种编程思想，即万物皆可归类抽象，万物皆可对象；有三大特征</p>\n<ol>\n<li>封装：类与外界的封装关系，即隐藏类内部的实现机制，对外部而言，它的内部细节是隐藏的，只暴露了自身的访问方法。使用者按照既定的方式来调用方法，不必关心方法的内部实现，便于使用，增强了代码的可维护性。</li>\n<li>继承：类与类的关系，即从已有的类中派生出新的类，即子类与父类，也可以称作超类和基类。从多个类中抽象出一个基类，使其具备多个类的共同特性，使用extends关键字继承某个类后，就具备了父类的属性，并扩展新的属性。在父类中使用private关键字来限制不会被继承。</li>\n<li>多态：多个类的关系，必备的三个要素：继承，重写，父类引用指向子类对象</li>\n</ol>\n<h3 id=\"ArrayList与LinkedList的区别\"><a href=\"#ArrayList与LinkedList的区别\" class=\"headerlink\" title=\"ArrayList与LinkedList的区别\"></a><em>ArrayList与LinkedList的区别</em></h3><ol>\n<li>ArrayList是基于索引的数据接口，底层是数组，可以在常数级的复杂度对元素进行随机访问。而LinkedList是基于Node对象列表的形式存储数据，底层是一个双向链表，查找元素是O（n）。因此LinkedList的插入，添加，删除操作，总体上会更快，因为不是数组，不需要移动元素，重新计算索引和大小，但是LinkedList更占内存，因为每一个node都会封装前驱指针和后继指针。</li>\n<li>如果你需要经常随机访问数据，更加推荐使用ArrayList；如果需要经常插入删除元素，推荐使用LinkedList。</li>\n<li>多提一嘴：其实总体上ArrayList性能其实更加优越一些。第一，LinkedList的每一个node都有指针，更占内存，第二：虽然LinkedList的头插效率很高，但是尾插效率却不见得十分高效，因为数组的尾插无需进行拷贝和移位，而链表则需要创建node对象。并且有人测试过，在数据量较大时，链表的中间插入仍会比ArrayList耗时更多。Joshua Bloch自己都不用LinkedList，以俺还是无脑选择ArrayList~</li>\n</ol>\n<h3 id=\"多线程环境下，操作long和double类型为什么不安全？\"><a href=\"#多线程环境下，操作long和double类型为什么不安全？\" class=\"headerlink\" title=\"多线程环境下，操作long和double类型为什么不安全？\"></a><em>多线程环境下，操作long和double类型为什么不安全？</em></h3><p>JAVA内存模型要求，变量的读取和写入必须是原子操作，但对于非volatile类型的long和double变量，JVM允许将64位的<strong>读操作或写操作分解成两个32位的操作</strong>。当读取一个非volatile类型的long时，如果读操作和写操作在不同的线程中执行，那么很可能读取到<strong>某个值的高32位和另一个值的低32位</strong>。就是说，在多线程环境下，使用共享且可变的long和double变量是不安全的，必须用关键字volatile声明或者用锁保护起来。但是如果在64bit的操作环境下，读写就可以是原子操作。</p>\n<h3 id=\"什么是线程安全？\"><a href=\"#什么是线程安全？\" class=\"headerlink\" title=\"什么是线程安全？\"></a><em><strong>什么是线程安全？</strong></em></h3><p>当多个线程访问某个类时，这个类始终能表现出正确的行为，那么就称这个类是线程安全的。具体说，就是当多个线程访问某个类时，不管运行时环境采用何种调度方式将这些线程交替进行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类时线程安全的。</p>\n<h3 id=\"Int和Integer的区别\"><a href=\"#Int和Integer的区别\" class=\"headerlink\" title=\"Int和Integer的区别\"></a><em><strong>Int和Integer的区别</strong></em></h3><ol>\n<li>Integer是int的包装类，int则是java的一种基本的数据类型；</li>\n<li>Integer变量必须实例化之后才能使用，而int变量不需要实例化；</li>\n<li>Integer实际是对象的引用，当new一个Integer时，实际上生成一个指针指向对象，而int则直接存储数值</li>\n<li>Integer的默认值是null，而int的默认值是0。</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//直接存储值</span>\n<span class=\"token class-name\">Integer</span> b <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//无new创建Integer对象时，这种操作等于：Integer.valueOf(1);</span>\n<span class=\"token class-name\">Integer</span> c <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//指向堆内存中的对象</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>包装类的缓存机制</strong></p>\n<p>若使用valueOf方法，则会调用缓存IntegerCache，这是一个静态内部类，会直接缓存-127到128的Integer对象。</p>\n<p>因此，在valueOf方法中，如果值在-127-128之间，都会直接返回缓存中的该对象而不会重新生成对象。</p>\n<p>如果超过这个范围就会直接在堆上创建一个新的对象</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">public static Integer valueOf(int i) &#123;\n     if (i &gt;&#x3D; IntegerCache.low &amp;&amp; i &lt;&#x3D; IntegerCache.high)\n         return IntegerCache.cache[i + (-IntegerCache.low)];\n     return new Integer(i);&#x2F;&#x2F;超过范围\n &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>Byte，Short，Long的缓存范围都是-128-127，Character的缓存范围是0-127，除了Integer，其他的缓存范围都是固定的</p>\n","text":"Object类中有哪些方法 equals()：未被重写前，由&#x3D;&#x3D;来实现，比较引用数据类型的引用地址是否相同 HashCode()：本地方法，未被重写前返回对象在堆上的唯一地址值，可以看作是对象的身份ID clone()：实现了cloneable接口才可以调用该...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":7,"path":"api/tags/Java基础知识.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Object%E7%B1%BB%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">Object类中有哪些方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JAVA%E7%9A%84%E5%85%AB%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">JAVA的八大数据类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">接口和抽象类有哪些区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#String-StringBuilder-StringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">String,StringBuilder,StringBuffer的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Object-o-new-Object-%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%AD%97%E8%8A%82%EF%BC%9F\"><span class=\"toc-text\">Object o &#x3D; new Object()在内存中占用多少个字节？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%EF%BC%9F\"><span class=\"toc-text\">对象如何定位？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">对象的创建过程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E5%BE%81\"><span class=\"toc-text\">面向对象有哪些特征</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ArrayList%E4%B8%8ELinkedList%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">ArrayList与LinkedList的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%8B%EF%BC%8C%E6%93%8D%E4%BD%9Clong%E5%92%8Cdouble%E7%B1%BB%E5%9E%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%9F\"><span class=\"toc-text\">多线程环境下，操作long和double类型为什么不安全？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F\"><span class=\"toc-text\">什么是线程安全？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Int%E5%92%8CInteger%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">Int和Integer的区别</span></a></li></ol>","author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"周赛笔记11/13/2022","uid":"6ba55d3e12601017e69aa7613dde8806","slug":"周赛笔记11-13-2022","date":"2022-11-13T08:22:18.000Z","updated":"2022-11-13T08:38:26.944Z","comments":true,"path":"api/articles/周赛笔记11-13-2022.json","keywords":null,"cover":[],"text":"6234.最小公倍数为 K 的子数组数目给你一个整数数组 nums 和一个整数 k ，请你统计并返回 nums 的 子数组 中满足 元素最小公倍数为 k 的子数组数目。 子数组 是数组中一个连续非空的元素序列。数组的最小公倍数 是可被所有数组元素整除的最小正整数。 示例 1 ： ...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"LeetCode初见","slug":"LeetCode初见","count":10,"path":"api/tags/LeetCode初见.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"NIO select poll和epoll","uid":"2a1374b017f253762c103f23513f4420","slug":"NIO-select-poll和epoll","date":"2022-11-02T05:45:40.000Z","updated":"2022-11-30T08:22:04.956Z","comments":true,"path":"api/articles/NIO-select-poll和epoll.json","keywords":null,"cover":[],"text":"套接字编程Socket，表示进程间网络通信的特殊文件类型。本质是内核借助缓冲区形成的伪文件。Linux将套接字封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。 在TCP&#x2F;IP协议中，“IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程。 “...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[],"tags":[{"name":"网络编程基础知识","slug":"网络编程基础知识","count":1,"path":"api/tags/网络编程基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}