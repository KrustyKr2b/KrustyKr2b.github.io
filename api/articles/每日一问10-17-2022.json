{"title":"每日一问10/17/2022","uid":"626084d3a58b4f97f22000ce81567720","slug":"每日一问10-17-2022","date":"2022-10-17T13:16:32.000Z","updated":"2022-10-18T12:32:16.702Z","comments":true,"path":"api/articles/每日一问10-17-2022.json","keywords":null,"cover":[],"content":"<h3 id=\"Q1-String-StringBuilder-StringBuffer的区别\"><a href=\"#Q1-String-StringBuilder-StringBuffer的区别\" class=\"headerlink\" title=\"Q1:String,StringBuilder,StringBuffer的区别\"></a>Q1:String,StringBuilder,StringBuffer的区别</h3><p>答：</p>\n<ol>\n<li>String的底层是一个由final修饰的char型数组，String是静态只读的，当改变变量的值时，其实只是改变了引用对象的指向，指向了新创建的字符串，而原字符串仍存在于字符串常量池。</li>\n<li>StringBuffer（JDK1.0引入）：引用对象指向一个空间，包含一个可自行扩容的char型数组和字符串长度计数变量Count，StringBuffer的所有方法均被synchronized修饰。扩容时会开辟一块新的空间用于创建更大的数组，并将原数据复制过去，并改变引用对象的指向。</li>\n<li>StringBuilder(JDK1.5引入)：取消了synchronized方法修饰，所以效率更高，但是线程不安全。</li>\n</ol>\n<h3 id=\"Q2-HashMap如何保证线程安全\"><a href=\"#Q2-HashMap如何保证线程安全\" class=\"headerlink\" title=\"Q2:HashMap如何保证线程安全\"></a>Q2:HashMap如何保证线程安全</h3><p>答：</p>\n<ol>\n<li>Collections.synchronizedMap()方法传入HashMap的引用变量，返回一个新的Map，这个新的Map就是线程安全的，返回的并不是HashMap，而是map的一种实现。该方法封装了所有不安全的HashMap方法，使用了synchronized方法来进行互斥。该方法使用代理模式new了一个新的类，这个类实现了Map接口。该方法的优点：实现简单；缺点：加锁的粒度较大，性能比较差；</li>\n<li>使用ConcurrentHashMap，使用了新的锁机制，把hashmap拆分成了多个独立的块，这样在高并发的情况下减少了锁冲突的可能。使用的是NonfairSync，这个特性调用CAS指令来保证原子性和互斥性。如果多个线程恰好操作到同一个segment，只有一个线程得到运行。优点：互斥的代码段小，性能更好，发生锁碰撞的几率低。缺点：代码繁琐。</li>\n</ol>\n<h3 id=\"Q3：JAVA类加载器是啥\"><a href=\"#Q3：JAVA类加载器是啥\" class=\"headerlink\" title=\"Q3：JAVA类加载器是啥\"></a>Q3：JAVA类加载器是啥</h3><p>答：</p>\n<ol>\n<li>Bootstrap类加载器：即引导类加载器，由C++语言实现，无父类。主要加载的是JVM自身需要的类，是虚拟机自身的一部分，它负责将**<JAVA_HOME>&#x2F;lib路径下的核心类库**或-Xbootclasspath参数指定的路径下的jar包加载到内存中，虚拟机按照文件名识别jar包，处于安全考虑，启动类加载器只加载包名为java,javax,sun等开头的jar包，即使将不符合要求的jar包丢入lib目录下也没法被识别。</li>\n<li>Extention类加载器：即扩展类加载器，是指sun公司实现的ExtClassLoader类，由Java语言实现，父类加载器为null，是Launcher中的静态内部类，它负责加载**<JAVA_HOME>&#x2F;lib&#x2F;ext目录**或者由系统变量-Djava.ext.dir指定位路径中的类库，开发者可以直接使用标准扩展类加载器。</li>\n<li>Application类加载器：即应用程序加载器，是指sun公司实现的appClassLoader，父类加载器为扩展类加载器。<strong>它负责加载class-path指定路径下的库类</strong>，也就是我们经常用到的classpath，一般情况下该类加载是程序中默认的类加载器。</li>\n<li>Custom自定义类加载器：负责加载用户自定义路径下的类包，父类加载器为应用程序加载器</li>\n</ol>\n<p>类加载器的三大特征：</p>\n<ol>\n<li>委托性：即双亲委派机制，当类A被加载时，首先会委托给父类加载器。引导类加载器会在lib目录下查找是否存在，找到便加载，未找到便回到扩展类加载器。扩展类加载器会在&#x2F;lib&#x2F;ext目录下查找，找到便加载，未找到便回到应用程序加载器。应用程序加载器会在classPath路径下查找，找到则加载，未找到则抛出ClassNotFoundException异常</li>\n<li>可见性：父类加载器加载的类可以被子类观察到，但是子类加载的类对父类不可见</li>\n<li>一个类只可以被加载一次</li>\n</ol>\n<p>双亲委派机制：</p>\n<img src=\"../img/classLoader.png\" alt=\"classLoader\" style=\"zoom: 67%;\" />\n","feature":true,"text":"Q1:String,StringBuilder,StringBuffer的区别答： String的底层是一个由final修饰的char型数组，String是静态只读的，当改变变量的值时，其实只是改变了引用对象的指向，指向了新创建的字符串，而原字符串仍存在于字符串常量池。 Stri...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"面试突击","slug":"面试突击","count":3,"path":"api/tags/面试突击.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Q1-String-StringBuilder-StringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">Q1:String,StringBuilder,StringBuffer的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Q2-HashMap%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">Q2:HashMap如何保证线程安全</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Q3%EF%BC%9AJAVA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%98%AF%E5%95%A5\"><span class=\"toc-text\">Q3：JAVA类加载器是啥</span></a></li></ol>","author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>大三艰苦找实习的初阶技术人</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"微软面试题——24点游戏","uid":"8420d36b5907c1ed250973ab1271d588","slug":"微软面试题——24点游戏","date":"2022-10-16T11:58:26.000Z","updated":"2022-10-16T12:04:42.945Z","comments":true,"path":"api/articles/微软面试题——24点游戏.json","keywords":null,"cover":null,"text":"给定一个长度为4的整数数组 cards 。你有 4 张卡片，每张卡片上都包含一个范围在 [1,9] 的数字。您应该使用运算符 [&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;] 和括号 &#39;(&#39; 和 &#39;)...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"LeetCode初见","slug":"LeetCode初见","count":5,"path":"api/tags/LeetCode初见.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>大三艰苦找实习的初阶技术人</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}