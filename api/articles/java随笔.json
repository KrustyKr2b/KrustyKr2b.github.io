{"title":"JVM随笔","uid":"1a1bb15f69c32b83456560735cf8e617","slug":"java随笔","date":"2022-10-12T04:37:43.000Z","updated":"2022-10-12T05:11:48.041Z","comments":true,"path":"api/articles/java随笔.json","keywords":null,"cover":null,"content":"<h1 id=\"JAVA内存区域讲解\"><a href=\"#JAVA内存区域讲解\" class=\"headerlink\" title=\"JAVA内存区域讲解\"></a>JAVA内存区域讲解</h1><p>运行时数据区域分为两部分：线程共享和线程私有</p>\n<p>线程共享区域：</p>\n<ol>\n<li>堆：是虚拟机内存的最大的一块，此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存，注意是“几乎”，JDK1.7之后，当方法中的对象引用没有被返回或者未被外部使用，就会直接在栈上分配内存。同时，堆也是垃圾收集器管理的主要区域，所以也被称为GC堆。</li>\n<li>JDK1.8之前：方法区（运行时常量池）；JDK1.8之后：无，将方法区移至本地内存。方法区是运行时数据区域的一个逻辑区域，在不同虚拟上方法区的实现是不同的，当虚拟机要使用一个类时，它需要读取并解析class文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的类信息，字段信息，方法信息，常量，静态变量，即时编译器编译后的代码缓存。方法区有两种具体实现：永久代permanent gen和元空间metaspace。前者拥有一个由本身JVM设置的大小上限，无法调整，而在8版本之后，转而使用元空间，后者使用的是计算机的直接内存，溢出的概率更小。方法区包含运行时常量池和字符串常量池，后者是为了减少string类的内存消耗而专门开辟的，可以避免字符串的重复创建。方法区是一个公共且抽象的概念，在不同虚拟机上可以有不同的实现。</li>\n</ol>\n<p>线程私有区域：</p>\n<ol>\n<li>虚拟机栈：由一个个栈帧组成，栈帧内包含：局部变量表（存放可以编译器可以被识别的各种数据类型），操作数栈（作为方法调用的中转站，存放中间计算结果），动态链接（当一个方法需要调用其他方法时，动态链接就是未来将符号引用转换为调用方法的直接引用），方法返回地址。除了本地方法，其他所有方法的调用都是通过栈来实现。方法调用的数据通过栈进行传递，每一个方法没调用时都会有一个对应的栈帧被压入，每一个方法调用结束后，都会有一个栈帧被弹出。当函数调用陷入无限循环，或者压栈太多，导致线程请求的栈的深度超过JAVA虚拟机栈的最大深度时，就会抛出,stackoverflow。栈帧的弹出：return语句，异常抛出，随方法的调用而创建，随方法的结束而销毁，所以无论方法是否正常完成还是异常完成，都可以视为方法结束。</li>\n<li>本地方法栈：和虚拟机栈十分相似，但是本地方法是由c++编写的，所以这个栈是为native方法服务的，同样也会创建栈帧，同样也会抛出栈溢出的错误。</li>\n<li>程序计数器PC：一块较小的内存空间，就是一个计数器，可以看作是当前线程执行的字节码的行号指示器，字节码解释器通过改变PC的值来选取下一条要执行的字节码指令，从而实现循环，跳转，异常处理等功能。每个线程都需要一个独立的PC，PC也是唯一一个不会出现outofmemory的内存区域。</li>\n</ol>\n<h1 id=\"类文件结构解析\"><a href=\"#类文件结构解析\" class=\"headerlink\" title=\"类文件结构解析\"></a>类文件结构解析</h1><p>字节码：.class扩展名</p>\n<ol>\n<li>魔数：magic number：每个class文件的头4个字节被称为魔数（CAFEBABE）唯一作用便是确定这个文件是否为一个能被虚拟机接收的class文件</li>\n<li>class文件版本号：小版本号+大版本号。高版本的JVM可以执行低版本的class文件</li>\n<li>常量池数量，常量池，常量池计数器从1开始，若有某些指向常量池的索引值需要表达“不引用常量池中的项目”这一含义，则可以将索引值设为0。常量池中主要存储两大常量：字面量：即文本字符串，或者被final修饰的常量等。符号引用：package，接口的全名，方法名称或描述符，字段名称或描述符等等。与c不同的是，java在编译时，不会有连接这一步骤，而是会在虚拟机加载class文件时进行动态连接，虚拟机在进行类加载时，将会从常量池中获得对应的符号引用，在类创建时或运行时解析，并翻译到具体的内存地址中。常量池中的每一项都是一个表。常量池可以看作是class文件里的资源仓库，占用空间最大。</li>\n<li>访问标志：用于识别类或者接口的访问信息，比如class是类还是接口，public还是abstract，是否被final修饰等</li>\n<li>索引集合：当前类，父类，接口索引集合</li>\n<li>字段表集合：描述接口或类中声明的变量，不包括方法内声明的局部变量</li>\n<li>方法表集合</li>\n</ol>\n<h1 id=\"类加载过程\"><a href=\"#类加载过程\" class=\"headerlink\" title=\"类加载过程\"></a>类加载过程</h1><h3 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h3><p>加载主要完成下面三件事情</p>\n<ol>\n<li>通过全类名获取定义此类的二进制字节流</li>\n<li>将字节流代表的静态数据结构转换为方法区的运行时数据结构</li>\n<li>在内存中生成一个代表该类的class对象，作为方法区数据的访问入口</li>\n</ol>\n<h3 id=\"连接——验证\"><a href=\"#连接——验证\" class=\"headerlink\" title=\"连接——验证\"></a>连接——验证</h3><ol>\n<li>文件格式验证：是否符合class文件格式的规范（CAFEBABE），主次版本号是否在虚拟机的处理范围内，常量池中的的常量是否都可以支持</li>\n<li>元数据验证：对字节码的信息进行语义分析，保证描述的信息符合java的语言规范，比如这个类是否有父类，这个类是否继承了不被允许继承的类</li>\n<li>字节码验证：这是最为复杂的一个阶段，通过数据流和控制流的分析，确定程序语义是合法，符合逻辑的，比如确保任意时刻操作数栈都能配合工作</li>\n<li>符号引用验证：确保解析动作能正确执行</li>\n</ol>\n<h3 id=\"连接——准备\"><a href=\"#连接——准备\" class=\"headerlink\" title=\"连接——准备\"></a>连接——准备</h3><p>这个阶段会正式为变量分配内存并设置初始变量，仅包括类变量,static</p>\n<h3 id=\"连接——解析\"><a href=\"#连接——解析\" class=\"headerlink\" title=\"连接——解析\"></a>连接——解析</h3><p>将常量池里的符号引用替换为直接引用，主要针对，接口，字段，类方法。符号引用就是用一组符号来描述目标，可以是任何字面量；直接引用就是直接指向目标的指针，偏移量</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>这是类加载的最后一步，执行初始化方法<clinit>，在这一步，JVM才真正开始执行类中定义的java程序代码</p>\n<h1 id=\"HOTSPOT虚拟机对象创建的过程\"><a href=\"#HOTSPOT虚拟机对象创建的过程\" class=\"headerlink\" title=\"HOTSPOT虚拟机对象创建的过程\"></a>HOTSPOT虚拟机对象创建的过程</h1><h4 id=\"类加载检测\"><a href=\"#类加载检测\" class=\"headerlink\" title=\"类加载检测\"></a>类加载检测</h4><p>虚拟机遇到new指令时，首先检查这条指令的参数是否能在常量池中定位到这个类的引用，检查这个符号引用代表的类是否已经被加载过，解析，或初始化。若没有，则先执行相应的类加载过程。</p>\n<h4 id=\"分配内存\"><a href=\"#分配内存\" class=\"headerlink\" title=\"分配内存\"></a>分配内存</h4><p>为新对象分配内存，所需内存大小在类加载完成后就可以确定，分配内存的任务等同于将一块确定大小的内存从堆中划分出来。</p>\n<ol>\n<li>指针碰撞：堆内存规整，将用过的内存和没用过的内存整合到两边，中间有一个分界指针，只需要将指针移动相应大小即可完成分配。</li>\n<li>空闲列表：堆内存不规整，虚拟机会维护一个列表，列表中会记录哪些内存块是可用的，寻找到一块满足大小的内存分配后，更新列表。</li>\n</ol>\n<h4 id=\"初始化零值\"><a href=\"#初始化零值\" class=\"headerlink\" title=\"初始化零值\"></a>初始化零值</h4><p>当内存分配后，需要将分配到的内存空间都初始化为0值，这一步保证了对象的字段在java代码中可以不赋值就能直接被使用，程序能访问这些字段的数据类型对应的0值</p>\n<h4 id=\"设置对象头\"><a href=\"#设置对象头\" class=\"headerlink\" title=\"设置对象头\"></a>设置对象头</h4><p>这个对象是哪个类的实例，对象的hashcode，如何才能找到类的元数据信息，等信息处理后放入对象头中、</p>\n<h4 id=\"执行init方法\"><a href=\"#执行init方法\" class=\"headerlink\" title=\"执行init方法\"></a>执行init方法</h4><p>在虚拟机的视角来看，对象的创建已经完成，但是对于java程序来说，对象创建才刚刚开始，在init之前所有的字段都是零值，init之后便会将对象按照程序员的意愿进行初始化，一个真正可用的对象才算真正创建。</p>\n","feature":true,"text":"JAVA内存区域讲解运行时数据区域分为两部分：线程共享和线程私有 线程共享区域： 堆：是虚拟机内存的最大的一块，此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存，注意是“几乎”，JDK1.7之后，当方法中的对象引用没有被返回或者未被外部使用，就会直...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"java基础知识","slug":"java基础知识","count":1,"path":"api/tags/java基础知识.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JAVA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AE%B2%E8%A7%A3\"><span class=\"toc-text\">JAVA内存区域讲解</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">类文件结构解析</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">类加载过程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%A0%E8%BD%BD\"><span class=\"toc-text\">加载</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9E%E6%8E%A5%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81\"><span class=\"toc-text\">连接——验证</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9E%E6%8E%A5%E2%80%94%E2%80%94%E5%87%86%E5%A4%87\"><span class=\"toc-text\">连接——准备</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9E%E6%8E%A5%E2%80%94%E2%80%94%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">连接——解析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">初始化</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#HOTSPOT%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">HOTSPOT虚拟机对象创建的过程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A3%80%E6%B5%8B\"><span class=\"toc-text\">类加载检测</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98\"><span class=\"toc-text\">分配内存</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9B%B6%E5%80%BC\"><span class=\"toc-text\">初始化零值</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%A4%B4\"><span class=\"toc-text\">设置对象头</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%89%A7%E8%A1%8Cinit%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">执行init方法</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>大三艰苦找实习的初阶技术人</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"java数据结构","uid":"2a473625323531f98aaeb9003828b3f4","slug":"Java数据结构","date":"2022-10-12T05:41:02.000Z","updated":"2022-10-12T05:44:44.461Z","comments":true,"path":"api/articles/Java数据结构.json","keywords":null,"cover":null,"text":"HashCodehashcode是一种编码方式，在java中，每一个对象都会有一个hashcode，而java可以以此来识别每一个对象 哈希，也可以翻译为“散列”，就是将任意长度的输入，通过散列算法，变换为固定长度的输出，该输出值就是散列值。这是一种压缩映射，不同的输入可能会得到...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"13 mins."},"categories":[],"tags":[],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>大三艰苦找实习的初阶技术人</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{}}