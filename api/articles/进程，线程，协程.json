{"title":"进程，线程和协程详解","uid":"27f3741f94599209904dbbf8d63cd0fd","slug":"进程，线程，协程","date":"2022-10-20T08:53:01.000Z","updated":"2022-11-22T08:14:57.357Z","comments":true,"path":"api/articles/进程，线程，协程.json","keywords":null,"cover":[],"content":"<h1 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>an instance of a computer program that is being executed</p>\n<p>进程是程序的一次执行，是一个程序及其数据，运行环境，在处理机上运行时所发生的活动。</p></blockquote>\n<p>与程序不同的是，进程具有动态性和生命周期，是系统进行资源分配和调度的独立单位。</p>\n<p>进程的结构：</p>\n<ol>\n<li>控制块</li>\n<li>数据段</li>\n<li>程序段</li>\n</ol>\n<h1 id=\"线程的Linux实现\"><a href=\"#线程的Linux实现\" class=\"headerlink\" title=\"线程的Linux实现\"></a>线程的Linux实现</h1><p>而在windows中，线程被抽象为一种比进程更轻量级的可以独立处理事件的单元，支持真线程的系统一定要有线程控制块：TCB，操作系统既要进行进程管理，又要进行线程管理，设计层面是比较复杂的。windows上一定会有相关线程操作的系统调用接口。</p>\n<p>而在Linux中却不一样，从内核的角度来看，并没有线程这个概念，Linux把所有的线程都当作进程来处理，内核也并没有定义独特的调度算法和数据结构来实现线程，线程就是一个与父进程共享资源的进程而已，Linux在创建线程时，会直接创建进程并分配task_struct，同时指定共享资源，所以对于内核来说，它就是进程，线程在Linux中是一个实现进程共享资源的机制。</p>\n<p>在 Linux 中每一个进程都由 task_struct 数据结构来定义。task_struct 就是我们通常所说的 PCB，当我们调用 fork()  时，系统会为我们产生一个 task_struct 结构。然后从父进程，那里继承一些数据，并将PCB插入任务队列中，以待进行进程管理。</p>\n<p>对于线程来说，需要在clone()中指定共享资源</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span>CLONE_VM <span class=\"token operator\">|</span> CLONE_FS <span class=\"token operator\">|</span> CLONE_FILES <span class=\"token operator\">|</span> CLONE_SIGHAND<span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//VM：共享地址空间</span>\n<span class=\"token comment\">//FS：共享文件系统信息</span>\n<span class=\"token comment\">//FILES:共享打开的文件</span>\n<span class=\"token comment\">//SIGHAND：共享阻断信号</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>而一个普通的fork()就是</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span>SIGCHLD<span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"内核线程\"><a href=\"#内核线程\" class=\"headerlink\" title=\"内核线程\"></a>内核线程</h2><p>内核需要经常在后台处理操作，这些任务可以交给内核线程来处理。内核线程就是独立运行在内核空间的标准进程。</p>\n<p>内核线程没有独立的地址空间。其指向地址空间的mm指针设置为null，只存在于内核空间</p>\n<p>task_struct结构中的mm指针：指向进程所拥有的内存描述符</p>\n<p><strong>多线程的优点：并发性提高，占用资源比进程更少。</strong></p>\n<p><strong>多线程缺点：存在大量临界资源，势必会造成各种互斥。编程难度提高，线程的调度和同步需要更多额外的开销。</strong></p>\n<h2 id=\"线程的通信方式\"><a href=\"#线程的通信方式\" class=\"headerlink\" title=\"线程的通信方式\"></a>线程的通信方式</h2><h3 id=\"管道：\"><a href=\"#管道：\" class=\"headerlink\" title=\"管道：\"></a>管道：</h3><p>分为匿名管道和命名管道，实质是一个缓冲区，管道的作用正如其名，需要通信的两个进程在管道的两端，进程利用管道传递信息。管道对于管道两端的进程而言，就是一个文件，但是这个文件比较特殊，它不属于文件系统并且只存在于内存中。</p>\n<h3 id=\"信号signal：\"><a href=\"#信号signal：\" class=\"headerlink\" title=\"信号signal：\"></a>信号signal：</h3><p>信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，进程不必通过任何操作来等待信号的到达。信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件。</p>\n<h3 id=\"信号量Semaphore：\"><a href=\"#信号量Semaphore：\" class=\"headerlink\" title=\"信号量Semaphore：\"></a>信号量Semaphore：</h3><p>信号量实质上就是一个标识可用资源数量的计数器，它的值总是非负整数。而只有0和1两种取值的信号量叫做二进制信号量（或二值信号量），可用用来标识某个资源是否可用。</p>\n<h3 id=\"共享内存\"><a href=\"#共享内存\" class=\"headerlink\" title=\"共享内存:\"></a>共享内存:</h3><p>使得多个进程可以可以直接读写同一块内存空间，是针对其他通信机制运行效率较低而设计的。为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率</p>\n<h3 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列:\"></a>消息队列:</h3><p>消息队列是消息的链表，具有特定的格式,存放在内存中并由消息队列标识符标识，并且允许一个或多个进程向它写入与读取消息</p>\n<h3 id=\"套接字\"><a href=\"#套接字\" class=\"headerlink\" title=\"套接字:\"></a>套接字:</h3><p>不同客户端的进程间的通信方式</p>\n<h1 id=\"用户空间和内核空间\"><a href=\"#用户空间和内核空间\" class=\"headerlink\" title=\"用户空间和内核空间\"></a>用户空间和内核空间</h1><p>操作系统为了支持多个应用同时运行，需要保证不同进程之间相对独立，一个进程的崩溃不会影响其他进程，恶意进程不能读取其他进程的数据。于是内存空间被划分为两部分，<strong>内核空间和用户空间</strong>，内核空间的代码和数据拥有更高的权限，而用户空间的代码不能访问高级别的空间，因此保护了操作系统自身的内存数据。</p>\n<p><strong>用户态</strong>：指进程运行在用户地址空间中的状态，被执行的代码要受到 CPU 的很多检查。进程只能访问地址空间中规定的页面的虚拟地址。</p>\n<p><strong>内核态</strong>：指进程运行在内核地址空间中的状态，此时 CPU 可以执行任何指令。运行的代码也不受任何的限制，可以自由地访问任何有效地址，也可以直接进行端口的访问。所有系统资源的管理都是在内核态去做的，比如创建一个线程需要分配资源，就需要进入内核态，来完成。</p>\n<h2 id=\"什么是进程上下文\"><a href=\"#什么是进程上下文\" class=\"headerlink\" title=\"什么是进程上下文\"></a>什么是进程上下文</h2><p>在Linux中，用户程序装入系统形成一个进程的实质是系统为用户程序提供一个完整的运行环境</p>\n<p>进程的运行环境是由它的程序代码和程序运行所需要的数据结构以及硬件环境组成的，进程的运行环境主要包括：</p>\n<ol>\n<li>进程空间中的代码和数据、各种数据结构、进程堆栈和共享内存区等。</li>\n<li>环境变量：提供进程运行所需的环境信息。</li>\n<li>系统数据：进程空间中的对进程进行管理和控制所需的信息，包括进程任务结构体以及内核堆栈等。</li>\n<li>进程访问设备或者文件时的权限。</li>\n<li>各种硬件寄存器。</li>\n<li>地址转换信息。</li>\n</ol>\n<p>从以上组成情况可以看到，进程的运行环境是动态变化的，尤其是硬件寄存器的值以及进程控制信息是随着进程的运行而不断变化的。在Linux中把系统提供给进程的的处于<strong>动态变化的运行环境总和</strong>称为进程上下文。</p>\n<p>系统中的每一个进程都有自己的上下文。一个正在使用处理器运行的进程称为当前进程(current)。当前进程因时间片用完或者因等待某个事件而阻塞时，进程调度需要把处理器的使用权从当前进程交给另一个进程，这个过程叫做进程切换。</p>\n<p>此时，被调用进程成为当前进程。在进程切换时系统要把当前进程的上下文保存在指定的内存区域（该进程的任务状态段TSS中），然后把下一个使用处理器运行的进程的上下文设置成当前进程的上下文。</p>\n<p>当一个进程经过调度再次使用CPU运行时，系统要恢复该进程保存的上下文。所以，<strong>进程的切换也就是上下文切换</strong>。</p>\n<p>在系统内核为用户进程服务时，通常是进程通过系统调用执行内核代码，此时内核为用户进程服务，可以说内核在代替当前进程执行某种服务。所以可以认为，<strong>内核态就是内核运行在进程上下文中的状态</strong>。</p>\n<p><strong>中断上下文</strong>：硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理。所谓的“中断上下文”，其实也可以看作就是硬<strong>件传递过来的这些参数和内核需要保存的一些其他环境</strong>（主要是当前被打断执行的进程环境）</p>\n<h2 id=\"如何从用户态进入内核态：中断\"><a href=\"#如何从用户态进入内核态：中断\" class=\"headerlink\" title=\"如何从用户态进入内核态：中断\"></a>如何从用户态进入内核态：中断</h2><p>中断是CPU的一个功能：CPU停下工作后，保留现场，自动的转去执行相应的处理程序，CPU的控制权发生改变，处理完该事件后再返回断点继续执行。<strong>避免了CPU的轮询检查</strong>，而是转换为事件驱动，向CPU发送中断事件，强制让CPU来执行中断处理程序。发生中断，CPU会立即进入<strong>内核态</strong>，针对不同的中断信号，采取不同的处理方式。**中断是CPU从用户态进入核心态的唯一途径(如系统调用)**。</p>\n<h3 id=\"硬中断\"><a href=\"#硬中断\" class=\"headerlink\" title=\"硬中断\"></a>硬中断</h3><p>硬中断时由外部事件引起的，具有<strong>随机性和突发性</strong>，比如键盘，鼠标的输入，磁盘的读写，缺页。硬中断的中断号是<strong>由中断控制器提供的</strong>，硬中断是<strong>可以屏蔽</strong>掉的。</p>\n<p>流程如下</p>\n<ol>\n<li><strong>外设</strong> 将中断请求发送给中断控制器；</li>\n<li><strong>中断控制器</strong> 根据中断优先级，有序地将中断号传递给 CPU；</li>\n<li><strong>CPU</strong> 终止执行当前程序流，将 CPU 所有寄存器的数值保存到栈中；</li>\n<li><strong>CPU</strong> 根据中断号，从<strong>中断向量表</strong>中查找中断处理程序的入口地址，执行中断处理程序；</li>\n<li><strong>CPU</strong> 恢复寄存器中的数值，返回原程序流停止位置继续执行。</li>\n</ol>\n<h3 id=\"软中断（被动）\"><a href=\"#软中断（被动）\" class=\"headerlink\" title=\"软中断（被动）\"></a>软中断（被动）</h3><p>CPU的内部事件或者程序引起的中断，如程序故障，电压故障。</p>\n<h3 id=\"软中断（主动）\"><a href=\"#软中断（主动）\" class=\"headerlink\" title=\"软中断（主动）\"></a>软中断（主动）</h3><p>也称作<strong>系统调用</strong>，用户进程<strong>主动要求</strong>进入内核态。用户进程通过系统调用申请操作系统提供服务。</p>\n<p> 系统调用使用的是一个特别的中断实现的。具体是:调用 int $<strong>0x80</strong>的汇编指令，将产生向量为0x80的编程异常（软中断）</p>\n<p>软中断模拟了硬中断的处理过程：</p>\n<ol>\n<li>无</li>\n<li>无</li>\n<li><strong>CPU</strong> 终止执行当前程序流，将 CPU 所有寄存器的数值保存到栈中；</li>\n<li><strong>CPU</strong> 根据中断向量，从中断向量表中查找中断处理程序的入口地址，执行中断处理程序；</li>\n<li><strong>CPU</strong> 恢复寄存器中的数值，返回原程序流停止位置继续执行。</li>\n</ol>\n<h1 id=\"一个程序开多少线程合适\"><a href=\"#一个程序开多少线程合适\" class=\"headerlink\" title=\"一个程序开多少线程合适\"></a>一个程序开多少线程合适</h1><h2 id=\"CPU密集型\"><a href=\"#CPU密集型\" class=\"headerlink\" title=\"CPU密集型\"></a>CPU密集型</h2><p>一个完整的请求，IO操作可以在很短的时间内完成，CPU的运算时间占大部分，线程等待时间接近0</p>\n<ol>\n<li>单核CPU：一个CPU对应一个线程，且IO时间短，所以不适合使用多线程。若使用多线程，会造成线程竞争，造成不必要的浪费</li>\n<li>多核：如果是多核CPU，就可以最大化利用CPU的核心数，使用并发编程来提高效率。理论上的线程数量就等于CPU的核数，但是一般会设置为核数+1，这个额外的线程可以保证线程因为缺页中断或者其他原因暂停而不会导致CPU中断工作</li>\n</ol>\n<h2 id=\"IO密集型\"><a href=\"#IO密集型\" class=\"headerlink\" title=\"IO密集型\"></a>IO密集型</h2><p>一个完整请求，除了CPU的运算操作，还有许多IO操作要做，也就是说，IO操作占很大一部分，等待时间较长。</p>\n<p>理论最佳线程数：CPU核心数 * （1&#x2F;CPU利用率），CPU利用率&#x3D;1+（IO耗时&#x2F;CPU耗时）</p>\n<p>如果几乎全是IO耗时，那么就可以说是2N，但是一般也有一个backup，也就是2N+1</p>\n<h1 id=\"线程的生命周期\"><a href=\"#线程的生命周期\" class=\"headerlink\" title=\"线程的生命周期\"></a>线程的生命周期</h1><h2 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h2><p>当使用new关键字创建了一个线程之后，该线程就处于一个新建状态，此时它和其他java对象一样，仅仅被分配了内存，并初始化了成员变量值。没有线程的动态特征，也不会执行线程的执行体</p>\n<h2 id=\"就绪\"><a href=\"#就绪\" class=\"headerlink\" title=\"就绪\"></a>就绪</h2><p>当调用start方法后，该线程处于就绪状态。JVM会为其创建虚拟机栈和PC，处于这个状态表示线程可以运行了，等待被调度执行</p>\n<h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><p>在就绪状态下，若被OS调度，就会进入运行状态。当时间片用完或者调用线程让步时，回到就绪状态</p>\n<h2 id=\"阻塞\"><a href=\"#阻塞\" class=\"headerlink\" title=\"阻塞\"></a>阻塞</h2><ol>\n<li>等待阻塞：线程执行wait方法，JVM会将其放入等待池中，此时线程会释放持有的锁</li>\n<li>同步阻塞：即被synchronized修饰的代码块被其他线程拿到，本线程获取同步锁失败，就会被JVM放入锁池中</li>\n<li>其他阻塞：线程执行sleep或者join方法，或者发出了IO请求。当sleep超时，join等待线程终止或者等待超时，IO完毕，线程就会重新转入就绪状态</li>\n</ol>\n<p>sleep：线程睡眠，使线程转入阻塞状态一定时间</p>\n<p>wait：线程等待，使线程放入等待池，指导其他线程调用notify或者notifyall方法来唤醒，此时线程会尝试获取锁，若成功，转为就绪状态，若失败，则进入锁池等待锁的释放。</p>\n<p>yield：线程让步，暂停当前正在执行的线程对象，回到就绪状态，把执行机会让给优先级相同或者更高的线程</p>\n<p>join：线程加入，等待其他线程终止，在当前进程中调用另一个指定进程的join方法，则当前进程转入阻塞状态，直到另一个进程运行结束，当前进程再由阻塞转为就绪状态</p>\n<p>notify：线程唤醒，唤醒被wait阻塞的进程</p>\n<h2 id=\"死亡\"><a href=\"#死亡\" class=\"headerlink\" title=\"死亡\"></a>死亡</h2><ol>\n<li>run方法执行完成，线程正常结束</li>\n<li>抛出异常</li>\n<li>直接调用stop方法来结束（容易造成死锁）</li>\n</ol>\n<p><img src=\"/../img/thread.png\" alt=\"thread\"></p>\n<h1 id=\"Coroutine协程\"><a href=\"#Coroutine协程\" class=\"headerlink\" title=\"Coroutine协程\"></a>Coroutine协程</h1><h3 id=\"JVM的1-1模型\"><a href=\"#JVM的1-1模型\" class=\"headerlink\" title=\"JVM的1:1模型\"></a>JVM的1:1模型</h3><p>即JVM层面创建一个线程，就会向OS申请一个线程</p>\n<p>优点：简单，省事</p>\n<p>缺点：重量级大，需要在JVM和OS两个层面都创建等待队列，依赖于OS的线程调度器，对线程的操作如上下文切换，阻塞，唤醒等都需要等待OS的反馈，效率偏低。</p>\n<p><img src=\"/../img/javaThread.png\" alt=\"javaThread\"></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>JDK19的虚拟线程，尝试协程的实现</p>\n<h2 id=\"协程的C-实现解析\"><a href=\"#协程的C-实现解析\" class=\"headerlink\" title=\"协程的C++实现解析\"></a>协程的C++实现解析</h2><p>协程是一个函数的泛化，它允许函数被挂起，稍后再恢复</p>\n<h3 id=\"普通函数\"><a href=\"#普通函数\" class=\"headerlink\" title=\"普通函数\"></a>普通函数</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>一个普通函数可以被认为有两个操作：<strong>调用</strong>和<strong>返回</strong></p></blockquote>\n<h4 id=\"调用Call\"><a href=\"#调用Call\" class=\"headerlink\" title=\"调用Call\"></a>调用Call</h4><p>当调用一个函数时，<strong>调用</strong>操作会创建一个栈帧，<strong>挂起</strong>调用函数的执行，并将执行转交到被调用函数的开始位置</p>\n<p>这个“挂起”步骤通常包括将当前保存在CPU寄存器中的任何值保存到内存中，以便在函数恢复执行时，这些值可以在需要时恢复。根据函数的调用约定，调用方和被调用方可以协调谁保存这些寄存器值，但您仍然可以将它们视为<strong>调用</strong>操作的一部分。</p>\n<h4 id=\"返回Return\"><a href=\"#返回Return\" class=\"headerlink\" title=\"返回Return\"></a>返回Return</h4><p><strong>返回</strong>操作将返回值传递给调用方，并销毁函数的栈帧，然后在调用函数的位置<strong>恢复</strong>调用方的执行。恢复就是回到调用那个时刻的位置，比如设置寄存器重新指向调用者的栈帧。</p>\n<h3 id=\"协程与普通函数\"><a href=\"#协程与普通函数\" class=\"headerlink\" title=\"协程与普通函数\"></a>协程与普通函数</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>而协程泛化了函数的操作且增加了三个额外的操作：挂起，恢复，销毁</p></blockquote>\n<h4 id=\"协程的栈帧\"><a href=\"#协程的栈帧\" class=\"headerlink\" title=\"协程的栈帧\"></a>协程的栈帧</h4><p>协程可以在不销毁栈帧的情况下被挂起，这相当于<strong>打破了一个函数调用在虚拟机栈内的运作规则</strong>（压入-执行-返回-弹出-销毁）</p>\n<p>这意味着我们需要一个额外的数据结构来保存协程的状态，即<strong>堆内存上的协程帧</strong></p>\n<p>协程帧：用于保存操作数，挂起时的恢复点地址，相当于是保存了自身状态的快照</p>\n<h4 id=\"挂起：Suspend\"><a href=\"#挂起：Suspend\" class=\"headerlink\" title=\"挂起：Suspend\"></a>挂起：Suspend</h4><p>挂起操作在函数的当前点挂起协程的执行，并在不破坏栈帧帧的情况下将执行权转交给调用方或恢复调用方。</p>\n<p>C++ Coroutines TS中，这些挂起点是通过<strong>co_await</strong>或<strong>co_yield</strong>关键字来标识的，在挂起协程执行之后，挂起点上的任何对象都仍然是可用的。</p>\n<p><strong>记住，协程的切换不会破坏栈帧，这是协程实现回调的核心</strong></p>\n<p>当挂起时会发生以下操作：</p>\n<ol>\n<li>确保将寄存器中保存的任何值写入协程帧</li>\n<li>将恢复点的地址写入协程帧，以指示在哪个位置挂起，恢复操作就可以知道在哪里恢复协程的执行</li>\n</ol>\n<h4 id=\"恢复：Resume\"><a href=\"#恢复：Resume\" class=\"headerlink\" title=\"恢复：Resume\"></a>恢复：Resume</h4><p>就像普通函数调用一样，这个对resume()的调用将分配一个新的栈帧，并在将执行转交到该函数之前将调用者的返回地址存储在栈帧中。</p>\n<p>但是，它不是将执行转移到函数的开始，而是将执行转移到上次挂起的函数的点。</p>\n<h4 id=\"调用：Call\"><a href=\"#调用：Call\" class=\"headerlink\" title=\"调用：Call\"></a>调用：Call</h4><p>协程所做的第一件事是在堆中分配一个协程帧，并将参数从栈帧复制&#x2F;移动到协程帧，以便参数的生命周期超过第一个挂起点</p>\n<h4 id=\"销毁：Destroy\"><a href=\"#销毁：Destroy\" class=\"headerlink\" title=\"销毁：Destroy\"></a>销毁：Destroy</h4><p><strong>销毁</strong>操作销毁协程帧，而不恢复协程的执行</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>协程常常被认为是轻量级的线程，实际上协程不是进程也不是线程，<strong>而是一个特殊的函数</strong>，这个函数可以在某个地方挂起，并且可以重新在挂起处外继续运行。所以说，协程与进程、线程相比并不是一个维度的概念。</p></blockquote>\n<p><strong>协程不是被操作系统内核所管理的，而是完全由程序所控制，也就是在用户态执行。</strong>这样带来的好处是性能大幅度的提升，因为不会像线程切换那样消耗资源。协程的调度也是通过在用户态里创建一个调度器来模拟内核的调度。</p>\n<p>一个线程也可以包含多个协程。一个线程内可以有多个这样的特殊函数在运行，但是有一点必须明确的是，多个线程或者多个进程可以并行，但是<strong>一个线程内的多个协程绝对是串行的</strong>，因为它仍然是一个函数。</p>\n<p>线程切换过程是由“用户态到内核态到用户态”， 而协程的切换过程只有用户态，即没有陷入内核态，因此切换效率高。</p>\n<p>协程本质上是<strong>异步非阻塞</strong>技术，它是将事件回调进行了包装，让程序员看不到里面的事件循环。</p>\n","text":"进程 an instance of a computer program that is being executed 进程是程序的一次执行，是一个程序及其数据，运行环境，在处理机上运行时所发生的活动。 与程序不同的是，进程具有动态性和生命周期，是系统进行资源分配和调度的独立单位...","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":7,"path":"api/tags/Java基础知识.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B\"><span class=\"toc-text\">进程</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84Linux%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">线程的Linux实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">内核线程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">线程的通信方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%A1%E9%81%93%EF%BC%9A\"><span class=\"toc-text\">管道：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BF%A1%E5%8F%B7signal%EF%BC%9A\"><span class=\"toc-text\">信号signal：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BF%A1%E5%8F%B7%E9%87%8FSemaphore%EF%BC%9A\"><span class=\"toc-text\">信号量Semaphore：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98\"><span class=\"toc-text\">共享内存:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97\"><span class=\"toc-text\">消息队列:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A5%97%E6%8E%A5%E5%AD%97\"><span class=\"toc-text\">套接字:</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%92%8C%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4\"><span class=\"toc-text\">用户空间和内核空间</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87\"><span class=\"toc-text\">什么是进程上下文</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E4%BB%8E%E7%94%A8%E6%88%B7%E6%80%81%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E6%80%81%EF%BC%9A%E4%B8%AD%E6%96%AD\"><span class=\"toc-text\">如何从用户态进入内核态：中断</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A1%AC%E4%B8%AD%E6%96%AD\"><span class=\"toc-text\">硬中断</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BD%AF%E4%B8%AD%E6%96%AD%EF%BC%88%E8%A2%AB%E5%8A%A8%EF%BC%89\"><span class=\"toc-text\">软中断（被动）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BD%AF%E4%B8%AD%E6%96%AD%EF%BC%88%E4%B8%BB%E5%8A%A8%EF%BC%89\"><span class=\"toc-text\">软中断（主动）</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B%E5%90%88%E9%80%82\"><span class=\"toc-text\">一个程序开多少线程合适</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CPU%E5%AF%86%E9%9B%86%E5%9E%8B\"><span class=\"toc-text\">CPU密集型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#IO%E5%AF%86%E9%9B%86%E5%9E%8B\"><span class=\"toc-text\">IO密集型</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">线程的生命周期</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">创建</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%B1%E7%BB%AA\"><span class=\"toc-text\">就绪</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%A1%8C\"><span class=\"toc-text\">运行</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%98%BB%E5%A1%9E\"><span class=\"toc-text\">阻塞</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E4%BA%A1\"><span class=\"toc-text\">死亡</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Coroutine%E5%8D%8F%E7%A8%8B\"><span class=\"toc-text\">Coroutine协程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JVM%E7%9A%841-1%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">JVM的1:1模型</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\"></span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E7%A8%8B%E7%9A%84C-%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">协程的C++实现解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">普通函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B0%83%E7%94%A8Call\"><span class=\"toc-text\">调用Call</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9EReturn\"><span class=\"toc-text\">返回Return</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E7%A8%8B%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">协程与普通函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E7%A8%8B%E7%9A%84%E6%A0%88%E5%B8%A7\"><span class=\"toc-text\">协程的栈帧</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8C%82%E8%B5%B7%EF%BC%9ASuspend\"><span class=\"toc-text\">挂起：Suspend</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%81%A2%E5%A4%8D%EF%BC%9AResume\"><span class=\"toc-text\">恢复：Resume</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B0%83%E7%94%A8%EF%BC%9ACall\"><span class=\"toc-text\">调用：Call</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%94%80%E6%AF%81%EF%BC%9ADestroy\"><span class=\"toc-text\">销毁：Destroy</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li></ol>","author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"netty基础知识","uid":"4fe89795a63627b54cad79ec28758dc1","slug":"netty基础知识","date":"2022-10-22T08:35:26.000Z","updated":"2022-11-15T08:39:49.211Z","comments":true,"path":"api/articles/netty基础知识.json","keywords":null,"cover":[],"text":"Netty和Tomcat有什么区别？Netty是一个基于NIO的异步网络通信框架，性能高，封装了原生NIO，降低了编码复杂度。 Tomcat是一个Web服务器，是一个Servlet容器，内部只运行Servlet程序并处理HTTP请求。 Netty封装的是IO模型，用于处理网络数据...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"netty","slug":"netty","count":2,"path":"api/tags/netty.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"JUC","uid":"696c711dc425c21ecfe6691bc40887b7","slug":"JUC","date":"2022-10-20T06:09:39.000Z","updated":"2022-11-22T05:52:40.800Z","comments":true,"path":"api/articles/JUC.json","keywords":null,"cover":[],"text":"JAVA创建线程的四种方式继承Thread类 定义thread类的子类，并重写run方法，该方法的方法体就是线程需要完成的任务，run方法也称为线程执行体。 创建Thread类的实例，也就是创建了线程对象 启动线程，即调用线程的start方法 实现Runnable接口 定义Run...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"14 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":7,"path":"api/tags/Java基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}