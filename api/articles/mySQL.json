{"title":"MySQL","uid":"838ae74e3a76757d637de803a615bfd9","slug":"mySQL","date":"2022-10-25T14:02:31.000Z","updated":"2022-11-19T12:06:50.114Z","comments":true,"path":"api/articles/mySQL.json","keywords":null,"cover":[],"content":"<h1 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h1><p>关系型数据库，插件式的存储引擎，这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p>\n<ol>\n<li>客户端通过协议与服务器连接，发送查询语句，先检查缓存是否命中，若命中直接返回，否则进行语句解析</li>\n<li>预处理，检查语句是否有语法错误，查询优化（是否会使用索引扫描），生成查询计划，启动查询引擎，开始查询，底层存储引擎调用API获取数据，返回给客户端</li>\n<li>MYSQL默认使用B+树索引</li>\n</ol>\n<h3 id=\"字段选择优先级（由优至劣）\"><a href=\"#字段选择优先级（由优至劣）\" class=\"headerlink\" title=\"字段选择优先级（由优至劣）\"></a>字段选择优先级（由优至劣）</h3><ol>\n<li>整型</li>\n<li>time：定长运算快</li>\n<li>enum：枚举，能约束值，内部由整型存储</li>\n<li>char：定长，需要考虑字符集</li>\n<li>varchar：不定长，考虑字符集的转换与排序的校对集，速度慢</li>\n<li>text：无法使用内存临时表</li>\n</ol>\n<p><em><strong>定长优先。能选整型就不要选字符串，够用就行，不要富余分配空间，尽量避免使用Null</strong></em></p>\n<p>varchar最多可以定义65535个字节</p>\n<h3 id=\"事务的ACID\"><a href=\"#事务的ACID\" class=\"headerlink\" title=\"事务的ACID\"></a>事务的ACID</h3><ol>\n<li>原子性：要么全部成功，要么全部失败。由undo_log来保证</li>\n<li>一致性：数据库总是从一个状态转移到另一个状态</li>\n<li>隔离性：最终提交前，其他事务不可见，MVCC</li>\n<li>持久性：事务一旦提交，修改将会永久保存到数据库中，内存+redo_log</li>\n</ol>\n<h2 id=\"范式\"><a href=\"#范式\" class=\"headerlink\" title=\"范式\"></a>范式</h2><h3 id=\"1NF-第一范式\"><a href=\"#1NF-第一范式\" class=\"headerlink\" title=\"1NF(第一范式)\"></a>1NF(第一范式)</h3><p>属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。<strong>1NF 是所有关系型数据库的最基本要求</strong> ，也就是说关系型数据库中创建的表一定满足第一范式</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>如果关系表中的属性不可再细分且属性列不可重复，该关系满足第1范式</strong></p></blockquote>\n<h3 id=\"2NF-第二范式\"><a href=\"#2NF-第二范式\" class=\"headerlink\" title=\"2NF(第二范式)\"></a>2NF(第二范式)</h3><p>2NF 在 1NF 的基础之上，消除了非主属性对于码的部分函数依赖。如下图所示，展示了第一范式到第二范式的过渡。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>第二范式要求关系表中所有数据都要和关系表的主键有完全函数依赖（即属性不能只和主键有部分依赖关系）</strong></p></blockquote>\n<h3 id=\"3NF-第三范式\"><a href=\"#3NF-第三范式\" class=\"headerlink\" title=\"3NF(第三范式)\"></a>3NF(第三范式)</h3><p>3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。符合 3NF 要求的数据库设计，<strong>基本</strong>上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>每一个非主属性既不部分依赖于码也不传递依赖于码</strong></p></blockquote>\n<ul>\n<li>1NF：属性不可再分。</li>\n<li>2NF：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。</li>\n<li>3NF：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖</li>\n</ul>\n<h3 id=\"四种隔离级别\"><a href=\"#四种隔离级别\" class=\"headerlink\" title=\"四种隔离级别\"></a>四种隔离级别</h3><ol>\n<li>read uncommitted：所有事务都可以看见未提交的结果，产生脏读</li>\n<li>read committed：一个事务从开始到提交前，任何数据改变都是不可见的，产生不可重复读问题</li>\n<li>repeatable read：<code>MySQL</code>默认的隔离级别，解决不可重复读问题，保证同一事物的多个实例在并发读取事务时，会读取到同样的数据行，产生幻读问题（<code>InnoDB</code>的MVCC解决了幻读问题）</li>\n<li>serializable：最高级别的隔离，强制事务排序，不可能相互冲突，其实就是加锁，效率低</li>\n</ol>\n<h2 id=\"存储引擎\"><a href=\"#存储引擎\" class=\"headerlink\" title=\"存储引擎\"></a>存储引擎</h2><p><code>MyISAM</code>和<code>InnoDB</code>的区别是什么</p>\n<ol>\n<li><code>InnoDB</code>：支持事务，支持外键，聚集索引：文件存储于主键索引的叶子节点上，所以主键索引效率很高，但是辅助索引需要进行回表，并且主键不能过大，因为辅助索引也会存储主键，所以过大的主键会影响索引的大小。最小粒度锁为行锁</li>\n<li><code>MyISAM</code>：不支持事务，不支持外键，非聚集索引，索引保存的是数据文件的指针，主键索引和辅助索引独立。会创建一个单独的变量保存整个表的行数，读取表行数的速度更快。最小粒度锁为表锁，并发性能不好。</li>\n</ol>\n<h2 id=\"基础架构\"><a href=\"#基础架构\" class=\"headerlink\" title=\"基础架构\"></a>基础架构</h2><p><img src=\"/../img/13526879-3037b144ed09eb88.png\" alt=\"13526879-3037b144ed09eb88\"></p>\n<p>MySQL 主要由下面几部分构成：</p>\n<ul>\n<li><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li>\n<li><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 SQL 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件</p>\n<p><strong>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</strong></p></blockquote>\n<ul>\n<li><p><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</p>\n</li>\n<li><p><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</p>\n</li>\n<li><p><strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。</p>\n</li>\n<li><p><strong>日志模块：</strong>在server层是binlog归档日志模块</p>\n</li>\n<li><p><strong>插件式存储引擎</strong> ： 主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎</p>\n</li>\n<li><p><strong>查询语句的执行流程如下：权限校验（如果命中缓存）—&gt;查询缓存—&gt;分析器—&gt;优化器—&gt;权限校验—&gt;执行器—&gt;引擎</strong></p>\n</li>\n<li><p><strong>更新语句执行流程如下：分析器—-&gt;权限校验—-&gt;执行器—&gt;引擎—redo log(prepare 状态)—&gt;binlog—&gt;redo log(commit状态)</strong></p>\n</li>\n</ul>\n<h1 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h1><p><em><strong>为什么要有索引</strong></em></p>\n<p>一般的应用系统读写比例大约在10：1左右，而且数据的插入和更新出现性能问题的几率小于查询。在生产环境中，最容易出现问题的就是查询操作，因此对查询性能的优化就显得十分重要。</p>\n<p>索引的本质就是一个满足某种查找算法的数据结构，常见的有BST，AVL，红黑树，Btree，B+树等等</p>\n<p>这些结构以某种方式指向数据（索引结点指向数据记录物理地址的指针）</p>\n<ol>\n<li>索引大大减少了服务器需要扫描的数据量，提高了检索效率</li>\n<li>避免排序，减少CPU消耗</li>\n<li>将随机IO转换为顺序IO</li>\n</ol>\n<p>索引也是一张表，保存了主键和索引，指向了实体表，也需要占用内存。索引存储于外存，所以索引的查询也需要磁盘IO开销,访问外存的时间成本大约是内存的十万倍</p>\n<p>虽然提高了查询速度，但是在对实体表进行更新时，索引也需要进行相应的维护更新，而索引的维护也需要开销，降低了更新表的速度</p>\n<h3 id=\"HASH索引\"><a href=\"#HASH索引\" class=\"headerlink\" title=\"HASH索引\"></a>HASH索引</h3><p>Memory引擎默认Hash索引</p>\n<p>等值查询很快，计算的hash值与对应的行指针一并存入表中，哈希碰撞的元素以链表的形式相连。也不支持排序，以及模糊查询，并且由于散列算法，键值对的存储是无序的，所以不支持范围查询。</p>\n<h3 id=\"B-树索引\"><a href=\"#B-树索引\" class=\"headerlink\" title=\"B+树索引\"></a>B+树索引</h3><p><code>InnoDB</code>，<code>MyISAM</code>默认是B+树</p>\n<p>考虑到IO时十分高昂的操作，且数据库动辄百万级数据量，所以当一次IO时，常常以页作为单位来读取数据，当读取一页的数据至内存缓冲区时，实际上才发生了一次IO，所以控制IO的次数对于索引效率的提升，至关重要。</p>\n<p>B+树的特点：</p>\n<ol>\n<li>除叶子结点外的子节点：只起到索引的作用，仅存储指针，不存储信息</li>\n<li>所有信息存储于叶子结点，所有叶子结点在底部链接形成一个双向链表（范围查询）</li>\n</ol>\n<p>在<code>InnoDB</code>中，叶子节点的容量默认为一页16KB</p>\n<p><strong>叶子节点结构(聚簇索引为例)：页目录（主键）+用户数据区域（单向链表，通过主键排序，在插入数据的时候便会排序）</strong></p>\n<p><strong>非叶子节点结构：页指针+指向的该页的最小主键值</strong></p>\n<h3 id=\"MYSQL的各种索引\"><a href=\"#MYSQL的各种索引\" class=\"headerlink\" title=\"MYSQL的各种索引\"></a><strong>MYSQL的各种索引</strong></h3><ol>\n<li>主键索引：一张表一个主键索引，通常与表一起创建。</li>\n<li>唯一索引：如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。这么做的好处：一是简化了MySQL对这个索引的管理工作，这个索引也因此而变得更有效率；二是MySQL会在有新记录插入数据表时，如果字段的值已经出现过了，MySQL将拒绝插入那条新记录。也就是说，唯一索引可以保证数据记录的唯一性。事实上，在许多场合，人们创建唯一索引的目的往往不是为了提高访问速度，而只是为了避免数据出现重复。</li>\n<li>普通索引：建立在普通字段上的索引，唯一任务是加快对数据的访问速度。因此，应该只为那些最经常出现在查询条件（WHEREc）或排序条件（ORDERBY）中的数据列创建索引。只要有可能，就应该选择一个数据最整齐、最紧凑的数据列（如一个整数类型的数据列）来创建索引。</li>\n<li>复合索引：字符类型字段的前几个字符建立，可以覆盖多个数据列，遵循最左匹配原则，可能会因为order by失效。</li>\n</ol>\n<p>三星索引：衡量一个索引是否达到最佳表现的三个维度</p>\n<ol>\n<li>第一星：where后面的等值谓词，可以匹配索引列的顺序：意义在于谓索匹配的越多，索引片越窄，最终扫描的数据行也是越小。把 <strong>WHERE 后的等值条件列作为索引最开头的列，如此，必须扫描的索引片宽度就会缩至最短。</strong></li>\n<li>第二星：order by的排序是否和索引的顺序一致：意义在于避免进行额外的排序，增加消耗。<strong>将 ORDER BY 列加入到索引中，保持列的顺序</strong></li>\n<li>第三星：select的字段是否都为索引列：意义在于避免每一个索引行查询，都需要去聚簇索引进行一次随机IO查询。<strong>将查询语句中剩余的列都加入到索引中。</strong></li>\n</ol>\n<p><em><strong>普通索引和唯一索引有什么区别？</strong></em></p>\n<p><strong>概念上的不同</strong>：普通索引可以重复。而唯一索引和主键一样，不可以重复，但在一张表里面只能有一个主键，不能为空，唯一索引可有多个。唯一索引可有一条记录为null。在学校，一般用学号做主键，身份证号作为唯一索引</p>\n<p><strong>查询实现的不同</strong>：若查询语句为</p>\n<pre class=\"line-numbers language-SQL\" data-language=\"SQL\"><code class=\"language-SQL\">select id from T where k&#x3D;4<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>普通索引：查找到满足条件的第一个记录后，继续查找下个记录，直到碰到第一个不满足k&#x3D;4的记录。</p>\n<p>唯一索引：查到第一个满足条件的，就停止搜索。</p>\n<p>若重复数据很多，普通索引多了一次“查找和判断下一条记录”的操作，可能会多次IO，但是总体性能其实差别不大</p>\n<p><strong>更新性能不同</strong>：往表中插入一个新记录，<code>InnoDB</code>会有什么反应？</p>\n<p>若在内存中，普通索引直接插入，而唯一索引会判断一次是否有冲突，再插入。判断的性能消耗可以不计</p>\n<p>若不在内存中，普通索引会将数据记录在change buffer；唯一索引会将数据页读入内存再插入。众所周知数据库的IO成本很高，所以普通索引更新数据的性能是要更优的。</p>\n<p><strong>总结：若更新性能优先级更高，选择普通索引。</strong></p>\n<h3 id=\"主键索引-聚簇索引\"><a href=\"#主键索引-聚簇索引\" class=\"headerlink\" title=\"主键索引(聚簇索引)\"></a>主键索引(聚簇索引)</h3><p><img src=\"/../img/B+tree.png\" alt=\"B+tree\"></p>\n<h3 id=\"二级索引-辅助索引\"><a href=\"#二级索引-辅助索引\" class=\"headerlink\" title=\"二级索引(辅助索引)\"></a><strong>二级索引(辅助索引)</strong></h3><p>同样是B+树，以非主键而是以自定义规则的索引，以满足不同的查询需求，属于非聚集索引。</p>\n<p>叶子节点的用户数据区不再存储完整记录，而是存储<strong>主键+部分记录</strong>。</p>\n<p>所以使用辅助索引有时候需要进行回表，即部分记录无法满足查询需求，需要使用主键来重新到主键索引查找。</p>\n<h3 id=\"联合索引\"><a href=\"#联合索引\" class=\"headerlink\" title=\"联合索引\"></a>联合索引</h3><p>使用表中的多个字段创建索引，就是 <strong>联合索引</strong>，也叫 <strong>组合索引</strong> 或 <strong>复合索引</strong></p>\n<p><em><strong>什么情况下设置了复合索引，但不会使用？</strong></em></p>\n<ol>\n<li>没有符合最左匹配原则</li>\n<li>字段进行了隐私数据类型转化</li>\n<li>引擎估算走辅助索引的时间反而比全表扫描的时间更长</li>\n</ol>\n<p><em><strong>什么是最左匹配原则？</strong></em></p>\n<p>对于复合索引，若有字段123，若查询时省略字段1，则无法使用索引。</p>\n<p>因为数据库依据联合索引最左的字段来构建 B+ 树，叶子节点的排序是以字段123的顺序进行的，只有先确定了前一个（左侧的值）后，才能确定下一个值。a有序，b才能有序，若a省略，则无法有序查找bc。</p>\n<p>所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据</p>\n<p><em><strong>非聚簇索引的优缺点？</strong></em></p>\n<p>优点：<strong>更新代价比聚集索引要小</strong> 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的</p>\n<p>缺点：</p>\n<ol>\n<li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li>\n<li><strong>可能会二次查询(回表)</strong> :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询</li>\n</ol>\n<p><em><strong>聚簇索引的优缺点？</strong></em></p>\n<p>优点：聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据</p>\n<p>缺点：</p>\n<ol>\n<li><strong>依赖于有序的数据</strong> ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li>\n<li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚集索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的</li>\n</ol>\n<p><em><strong>MYSQL默认使用B+树，为啥要用B+树，不用B树？</strong></em></p>\n<p>因为两者都是存储于磁盘，而IO是花销很大的操作，InnoDB每次申请磁盘空间时都会申请若干条连续的磁盘块来组成一页，并放入内存，读取索引，放回磁盘，不断重复，直到找到数据。</p>\n<p>所以如果每次申请到的数据都能有助于定位到所需数据，这将会减少IO次数，提高查询效率。</p>\n<p>对于B树，因为B树的每一个结点都会存储键，指针和数据，每个磁盘块的信息存储能力有限，树的高度也会更高，增加了IO次数，所以B树的查询效率波动很大。</p>\n<p>而B+树的非叶子结点只存储键，所以B+树的非叶子结点可以存储更多的信息，降低了树高度，平均一次IO可以获取更多索引，所以B+树更适合外存索引，且查询效率更稳定</p>\n<p>其中在 MySQL 底层对 B+ 树进行进一步优化：</p>\n<p><strong>叶子节之间是双向链表，节点内部是单向链表，且在链表的头结点和尾节点也是循环指向的</strong>。（范围查询的关键）</p>\n<p><em><strong>为什么不用红黑树？</strong></em></p>\n<p>无论是二叉树还是红黑树，都会因为树的深度过深而导致IO次数变多，效率不高</p>\n<p><em><strong><code>InnoDB</code>一颗高度为3的B+树可以存放多少行数据？</strong></em></p>\n<p><code>InnoDB</code>的一页大小为16k，若一行数据的大小为1k，那么可以存储16行数据</p>\n<p>若主键ID为<code>bigint</code>型，8字节，指针为6字节，总大小为14字节，那么一页可以存储1170个指针</p>\n<p>所以数据量大约为1170  * 1170 *  16&#x3D; 大约两千万</p>\n<h1 id=\"MySQL的锁\"><a href=\"#MySQL的锁\" class=\"headerlink\" title=\"MySQL的锁\"></a>MySQL的锁</h1><h2 id=\"按锁的属性分\"><a href=\"#按锁的属性分\" class=\"headerlink\" title=\"按锁的属性分\"></a>按锁的属性分</h2><p>共享锁：即读锁</p>\n<p>排他锁：即写锁</p>\n<h3 id=\"按锁的粒度分\"><a href=\"#按锁的粒度分\" class=\"headerlink\" title=\"按锁的粒度分\"></a>按锁的粒度分</h3><p>行级锁：锁住一行或者多行记录</p>\n<p>表级锁：给整个表加锁</p>\n<p>页级锁：介于行级锁和表锁的一种锁，一次锁定相邻的一组记录</p>\n<p>记录锁：行级锁的一种，锁住一条记录，避免数据在查询时被修改的不可重复读问题</p>\n<p>间隙锁：行级锁的一种，只出现在Repeatable read的事务中，解决了幻读的问题</p>\n<p>临键锁：<code>InnoDB</code>的行锁默认算法，就是记录锁和间隙锁的结合版，会锁住查询的记录，同时也会锁住范围内的所有间隙空间</p>\n<h3 id=\"按锁的状态分\"><a href=\"#按锁的状态分\" class=\"headerlink\" title=\"按锁的状态分\"></a>按锁的状态分</h3><p>意向共享锁</p>\n<p>意向排他锁</p>\n<h1 id=\"MySQL的主从同步\"><a href=\"#MySQL的主从同步\" class=\"headerlink\" title=\"MySQL的主从同步\"></a>MySQL的主从同步</h1><p>MySQL内建的复制功能是构建大型，高性能应用程序的基础。</p>\n<p>将MySQL的数据分布到多个系统上去，这种分布的机制，是通过将MySQL的某一台主机的数据复制到其它主机（slave）上，并重新执行一遍来实现。</p>\n<p>复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。</p>\n<p>主服务器将更新写入二进制日志文件，并维护文件的一个索引以跟踪日志循坏，这些日志可以记录发送到从服务器的更新。</p>\n<p>当一个从服务器连接主服务器时，它通知主服务器从服务器在日志中读取的最后一次成功更新的位置。从服务器接收从那时起发生的任何更新，然后封锁并等待主服务器通知的更新。</p>\n<h2 id=\"MySQL支持哪些复制\"><a href=\"#MySQL支持哪些复制\" class=\"headerlink\" title=\"MySQL支持哪些复制\"></a>MySQL支持哪些复制</h2><ol>\n<li>基于语句的复制：在主服务器上执行的sql语句，在从服务器上执行同样的语句。MySQL默认采用基于语句的复制，效率比较高。一旦发现没法精确复制时，会自动选着基于行的复制。</li>\n<li>基于行的复制：把改变的内容复制过去，而不是把命令在从服务器上执行一遍。从MySQL 5.0开始支持</li>\n<li>混合类型的复制：默认采用基于语句的复制，一旦发现基于语句的无法精确复制时，就会采用基于行的复制</li>\n</ol>\n<h2 id=\"为什么需要主从同步\"><a href=\"#为什么需要主从同步\" class=\"headerlink\" title=\"为什么需要主从同步\"></a>为什么需要主从同步</h2><ol>\n<li>若出现锁表不能读的情况，此时可以使用主从复制，让主库负责写，从库负责读，这样就不影响业务的正常运行</li>\n<li>当IO频率越来越大时，业务量越来越大时，单机已无法满足，此时多库的处理可以提高IO的性能</li>\n</ol>\n<h1 id=\"日志（bin-log，redo-log和undo-log）\"><a href=\"#日志（bin-log，redo-log和undo-log）\" class=\"headerlink\" title=\"日志（bin log，redo log和undo log）\"></a>日志（bin log，redo log和undo log）</h1><p><code>MySQL</code> 日志 主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。其中，比较重要的还要属二进制日志 <code>binlog</code>（归档日志）和事务日志 <code>redo log</code>（重做日志）和 <code>undo log</code>（回滚日志）</p>\n<p><img src=\"/../img/01.png\" alt=\"01\"></p>\n<h3 id=\"redo-log（重做日志）\"><a href=\"#redo-log（重做日志）\" class=\"headerlink\" title=\"redo log（重做日志）\"></a>redo log（重做日志）</h3><p><code>redo log</code>（重做日志）是<code>InnoDB</code>存储引擎独有的，它让<code>MySQL</code>拥有了崩溃恢复能力</p>\n<p><code>MySQL</code> 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 <code>Buffer Pool</code> 中。</p>\n<p>后续的查询都是先从 <code>Buffer Pool</code> 中找，没有命中再去硬盘加载，减少硬盘 <code>IO</code> 开销，提升性能。</p>\n<p>更新表数据的时候，也是如此，发现 <code>Buffer Pool</code> 里存在要更新的数据，就直接在 <code>Buffer Pool</code> 里更新。</p>\n<p>然后会把“在某个数据页上做了什么修改”记录到<code>redo log buffer</code>里，接着刷盘到 <code>redo log</code> 文件里</p>\n<p><img src=\"/../img/03.png\" alt=\"03\"></p>\n<h4 id=\"刷盘时机\"><a href=\"#刷盘时机\" class=\"headerlink\" title=\"刷盘时机\"></a>刷盘时机</h4><p><code>InnoDB</code> 存储引擎为 <code>redo log</code> 的刷盘策略提供了 <code>innodb_flush_log_at_trx_commit</code> 参数，它支持三种策略：</p>\n<ul>\n<li>设置为 0 的时候，表示每次事务提交时不进行刷盘操作，依靠刷盘线程进行</li>\n<li>设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）</li>\n<li>设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache</li>\n</ul>\n<p><code>innodb_flush_log_at_trx_commit</code> 参数默认为 1 ，也就是说当事务提交时会调用 <code>fsync</code> 对 redo log 进行刷盘</p>\n<p>另外，<code>InnoDB</code> 存储引擎有一个后台线程，每隔<code>1</code> 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存（<code>page cache</code>），然后调用 <code>fsync</code> 刷盘</p>\n<p><strong>也就是说，一个没有提交事务的 <code>redo log</code> 记录，也可能会刷盘</strong></p>\n<p><strong>除了后台线程每秒<code>1</code>次的轮询操作，还有一种情况，当 <code>redo log buffer</code> 占用的空间即将达到 <code>innodb_log_buffer_size</code> 一半的时候，后台线程会主动刷盘</strong></p>\n<p><img src=\"/../img/06.png\" alt=\"06\"></p>\n<ul>\n<li><p>为<code>0</code>时，如果<code>MySQL</code>挂了或宕机可能会有<code>1</code>秒数据的丢失</p>\n</li>\n<li><p>为<code>1</code>时， 只要事务提交成功，<code>redo log</code>记录就一定在硬盘里，不会有任何数据丢失。</p>\n<p>如果事务执行期间<code>MySQL</code>挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失</p>\n</li>\n<li><p>为<code>2</code>时， 只要事务提交成功，<code>redo log buffer</code>中的内容只写入文件系统缓存（<code>page cache</code>）。</p>\n<p>如果仅仅只是<code>MySQL</code>挂了不会有任何数据丢失，因为已经写入主机的内存里了，但是宕机可能会有<code>1</code>秒数据的丢失</p>\n</li>\n</ul>\n<h4 id=\"日志文件组\"><a href=\"#日志文件组\" class=\"headerlink\" title=\"日志文件组\"></a>日志文件组</h4><p>硬盘上存储的 <code>redo log</code> 日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个的<code>redo</code>日志文件大小都是一样的。</p>\n<p>比如可以配置为一组<code>4</code>个文件，每个文件的大小是 <code>1GB</code>，整个 <code>redo log</code> 日志文件组可以记录<code>4G</code>的内容。</p>\n<p>它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写，如下图所示</p>\n<p><img src=\"/../img/10.png\" alt=\"10\"></p>\n<p>在个<strong>日志文件组</strong>中还有两个重要的属性，分别是 <code>write pos、checkpoint</code></p>\n<ol>\n<li><p><strong>write pos</strong> 是当前记录的位置，一边写一边后移</p>\n</li>\n<li><p><strong>checkpoint</strong> 是当前要擦除的位置，也是往后推移</p>\n</li>\n</ol>\n<ul>\n<li>每次刷盘 <code>redo log</code> 记录到<strong>日志文件组</strong>中，<code>write pos</code> 位置就会后移更新。</li>\n</ul>\n<p>每次 <code>MySQL</code> 加载<strong>日志文件组</strong>恢复数据时，会清空加载过的 <code>redo log</code> 记录，并把 <code>checkpoint</code> 后移更新。</p>\n<ul>\n<li><p><code>write pos</code> 和 <code>checkpoint</code> 之间的还空着的部分可以用来写入新的 <code>redo log</code> 记录</p>\n</li>\n<li><p>如果 <code>write pos</code> 追上 <code>checkpoint</code> ，表示<strong>日志文件组</strong>满了，这时候不能再写入新的 <code>redo log</code> 记录，<code>MySQL</code> 得停下来，清空一些记录，把 <code>checkpoint</code> 推进一下</p>\n</li>\n</ul>\n<p><em><strong>为什么不直接把修改后的数据页直接刷盘？而是要记录redo log?</strong></em></p>\n<p>实际上，数据页大小是<code>16KB</code>，刷盘比较耗时，可能就修改了数据页里的几 <code>Byte</code> 数据，没有必要将整个数据页落盘。</p>\n<p>而且数据页刷盘是随机写，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能很差。</p>\n<p>如果是写 <code>redo log</code>，一行记录可能就占几十 <code>Byte</code>，只包含表空间号、数据页号、磁盘文件偏移量、更新值，再加上是顺序写，所以刷盘速度很快。</p>\n<p>所以用 <code>redo log</code> 形式记录修改内容，性能会远远超过刷数据页的方式，这也让数据库的并发能力更强</p>\n<h3 id=\"bin-log（归档日志）\"><a href=\"#bin-log（归档日志）\" class=\"headerlink\" title=\"bin log（归档日志）\"></a>bin log（归档日志）</h3><p><code>redo log</code> 它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 <code>InnoDB</code> 存储引擎。</p>\n<p>而 <code>binlog</code> 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于<code>MySQL Server</code> 层。</p>\n<p>不管用什么存储引擎，只要发生了表数据更新，都会产生 <code>binlog</code> 日志</p>\n<p>bin log的作用：<strong>主从同步</strong></p>\n<p>可以说<code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性</p>\n<p><img src=\"/../img/01-20220305234724956.png\" alt=\"01-20220305234724956\"></p>\n<p><code>binlog</code>会记录所有涉及更新数据的逻辑操作，并且是顺序写</p>\n<h4 id=\"记录格式\"><a href=\"#记录格式\" class=\"headerlink\" title=\"记录格式\"></a>记录格式</h4><p><code>binlog</code> 日志有三种格式，可以通过<code>binlog_format</code>参数指定。</p>\n<ul>\n<li><strong>statement</strong></li>\n<li><strong>row</strong></li>\n<li><strong>mixed</strong></li>\n</ul>\n<p>指定<code>statement</code>，记录的内容是<code>SQL</code>语句原文，比如执行一条<code>update T set update_time=now() where id=1</code>，记录的内容如下</p>\n<p><img src=\"/../img/02-20220305234738688.png\" alt=\"02-20220305234738688\"></p>\n<p>同步数据时，会执行记录的<code>SQL</code>语句，但是有个问题，<code>update_time=now()</code>这里会获取当前系统时间，直接执行会导致与原库的数据不一致。</p>\n<p>为了解决这种问题，我们需要指定为<code>row</code>，记录的内容不再是简单的<code>SQL</code>语句了，还包含操作的具体数据，记录内容如下</p>\n<p><img src=\"/../img/03-20220305234742460.png\" alt=\"03-20220305234742460\"></p>\n<p><code>row</code>格式记录的内容看不到详细信息，要通过<code>mysqlbinlog</code>工具解析出来。</p>\n<p><code>update_time=now()</code>变成了具体的时间<code>update_time=1627112756247</code>，条件后面的@1、@2、@3 都是该行数据第 1 个~3 个字段的原始值（<strong>假设这张表只有 3 个字段</strong>）。</p>\n<p>这样就能保证同步数据的一致性，通常情况下都是指定为<code>row</code>，这样可以为数据库的恢复与同步带来更好的可靠性。</p>\n<p>但是这种格式，需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗<code>IO</code>资源，影响执行速度。</p>\n<p>所以就有了一种折中的方案，指定为<code>mixed</code>，记录的内容是前两者的混合。</p>\n<p><code>MySQL</code>会判断这条<code>SQL</code>语句是否可能引起数据不一致，如果是，就用<code>row</code>格式，否则就用<code>statement</code>格式</p>\n<h4 id=\"写入机制\"><a href=\"#写入机制\" class=\"headerlink\" title=\"写入机制\"></a>写入机制</h4><p><code>binlog</code>的写入时机也非常简单，事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把<code>binlog cache</code>写到<code>binlog</code>文件中。</p>\n<p>因为一个事务的<code>binlog</code>不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code></p>\n<p>我们可以通过<code>binlog_cache_size</code>参数控制单个线程 bin log cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（<code>Swap</code>）</p>\n<p><img src=\"/../img/04-20220305234747840.png\" alt=\"04-20220305234747840\"></p>\n<ul>\n<li><strong>上图的 write，是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快</strong></li>\n<li><strong>上图的 fsync，才是将数据持久化到磁盘的操作</strong></li>\n</ul>\n<p><code>write</code>和<code>fsync</code>的时机，可以由参数<code>sync_binlog</code>控制，默认是<code>0</code>。</p>\n<ul>\n<li><p>为<code>0</code>的时候，表示每次提交事务都只<code>write</code>，由系统自行判断什么时候执行<code>fsync</code></p>\n</li>\n<li><p>虽然性能得到提升，但是机器宕机，<code>page cache</code>里面的 binlog 会丢失。</p>\n<p>为了安全起见，可以设置为<code>1</code>，表示每次提交事务都会执行<code>fsync</code>，就如同 <strong>redo log 日志刷盘流程</strong> 一样</p>\n</li>\n<li><p>最后还有一种折中方式，可以设置为<code>N(N&gt;1)</code>，表示每次提交事务都<code>write</code>，但累积<code>N</code>个事务后才<code>fsync</code></p>\n</li>\n</ul>\n<h3 id=\"两阶段提交\"><a href=\"#两阶段提交\" class=\"headerlink\" title=\"两阶段提交\"></a>两阶段提交</h3><p><strong><code>redo log</code>（重做日志）让<code>InnoDB</code>存储引擎拥有了崩溃恢复能力。</strong></p>\n<p><strong><code>binlog</code>（归档日志）保证了<code>MySQL</code>集群架构的数据一致性</strong></p>\n<p>虽然它们都属于持久化的保证，但是侧重点不同。</p>\n<p>在执行更新语句过程，会记录<code>redo log</code>与<code>binlog</code>两块日志，以基本的事务为单位，<code>redo log</code>在事务执行过程中可以不断写入，而<code>binlog</code>只有在提交事务时才写入（刷盘），所以<code>redo log</code>与<code>binlog</code>的写入时机不一样</p>\n<p><img src=\"/../img/01-20220305234816065.png\" alt=\"01-20220305234816065\"></p>\n<p>如果bin log在写入时出了问题，而redo log无问题，则在MySQL恢复数据时主的值为redo中的操作值，而其他如SQL从的值则会跟随binlog恢复而无改变造成数据不一致的问题</p>\n<p>为了解决两份日志之间的逻辑一致问题，<code>InnoDB</code>存储引擎使用<strong>两阶段提交</strong>方案</p>\n<p>原理很简单，将<code>redo log</code>的写入拆成了两个步骤<code>prepare</code>和<code>commit</code>，这就是<strong>两阶段提交</strong></p>\n<p>使用<strong>两阶段提交</strong>后，写入<code>binlog</code>时发生异常也不会有影响，因为<code>MySQL</code>根据<code>redo log</code>日志恢复数据时，发现<code>redo log</code>还处于<code>prepare</code>阶段，并且没有对应<code>binlog</code>日志，就会回滚该事务</p>\n<p>如果<code>redo log</code>设置<code>commit</code>阶段发生异常，那会不会回滚事务呢？</p>\n<p><img src=\"/../img/06-20220305234907651.png\" alt=\"06-20220305234907651\"></p>\n<p>并不会回滚事务，它会执行上图框住的逻辑，虽然<code>redo log</code>是处于<code>prepare</code>阶段，但是能通过事务<code>id</code>找到对应的<code>binlog</code>日志，所以<code>MySQL</code>认为是完整的，就会提交事务恢复数据</p>\n<h3 id=\"undo-log\"><a href=\"#undo-log\" class=\"headerlink\" title=\"undo log\"></a>undo log</h3><p>我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，在 MySQL 中，恢复机制是通过 <strong>回滚日志（undo log）</strong> 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p>\n<p>另外，<code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，<code>InnoDB</code> 通过数据行的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>MySQL InnoDB 引擎使用 redo log保证事务的持久性，使用 undo log 来保证事务的原子性。</p>\n<p>MySQL数据库的<strong>数据备份、主备、主主、主从</strong>都离不开bin log，需要依靠bin log来同步数据，保证数据一致性</p>\n<p><em><strong>redo log和bin log有什么区别？</strong></em></p>\n<ol>\n<li>层次不同：bin log是在存储引擎的上层产生的，无论是怎么样的存储引擎，对数据库的修改都会产生二进制日志。而redo log是在存储引擎层产生的，innoDB独占，只记录该存储引擎对表的修改，产生时间晚于bin log</li>\n<li>记录内容的不同：MySQL的bin log是逻辑日志，其记录是对应的SQL语句，记录顺序与提交顺序有关，是面向操作者的逻辑顺序。而innoDB存储引擎层面的redo log日志是物理日志，redo log记录的是物理页的修改情况，如空间号、数据页号、磁盘文件偏移量，是面向物理页的顺序。</li>\n<li>记录时机不同：bin log只在每次事务提交的时候一次性写入缓存中的日志文件。而redo log保证在发出事务提交指令时，先向缓存中的redo log写入日志，写入完成后才执行提交动作，两者通过二阶段提交来保证一致性。</li>\n</ol>\n<h1 id=\"MVCC\"><a href=\"#MVCC\" class=\"headerlink\" title=\"MVCC\"></a>MVCC</h1><p>Multi-Version Concurrency Control多版本并发控制，实现对数据库的并发访问，实现读写冲突不加锁，非阻塞并发读。</p>\n<p>数据库的并发有三种场景</p>\n<ol>\n<li>读读：不存在任何问题，不需要并发控制</li>\n<li>读写：有线程安全问题，可能会造成脏读，幻读，不可重复读等问题</li>\n<li>写写：有线程安全问题，可能存在更新丢失的问题</li>\n</ol>\n<p>MVCC的实现原理就是为事务分配单项增长的时间戳，为每个修改保存一个版本，版本与时间戳相关联，解决了脏读，幻读，不可重复读的问题，但是不能解决更新丢失的问题，可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低</p>\n<h3 id=\"当前读\"><a href=\"#当前读\" class=\"headerlink\" title=\"当前读\"></a>当前读</h3><p>也叫锁定读Locking Read，读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁，比如update 、delete 、insert</p>\n<h3 id=\"快照读\"><a href=\"#快照读\" class=\"headerlink\" title=\"快照读\"></a>快照读</h3><p>也叫普通读Consistent Read，就是单纯的select语句，但不包括for update，就是不加锁的非阻塞读，前提是不使用serializable的隔离级别，实现原理即MVCC</p>\n<h2 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h2><h3 id=\"隐藏字段\"><a href=\"#隐藏字段\" class=\"headerlink\" title=\"隐藏字段\"></a>隐藏字段</h3><p>每行记录除了自定义的字段外，还有数据库隐式定义的字段</p>\n<p>DB_TRX_ID<br>6字节，最近修改事务的ID，即创建这条记录或者最后一次修改这条记录的事务ID</p>\n<p>DB_ROLL_PTR</p>\n<p>7字节，回滚指针，指向这条记录的上一个版本，用于配合undolog</p>\n<p>DB_ROW_ID</p>\n<p>6字节，隐藏的主键，如果数据表没有主键，innoDB就会自动生成一个row_id</p>\n<h3 id=\"undo-log-1\"><a href=\"#undo-log-1\" class=\"headerlink\" title=\"undo log\"></a>undo log</h3><p>即回滚日志，即进行插入，更新，删除操作后生成的记录链</p>\n<p>当进行insert时，产生的undo log只在事务回滚的时候需要，可以在事务提交后被丢弃</p>\n<p>当进行update和delete操作时，undo log不仅在事务回滚时需要，在快照读时也需要，所以必须保留，只有在回滚或者快照读不涉及该日志时，undo log才会被purge线程清除（若delete_bit为true，且DB_TRX_ID相对于purge线程的read view可见，那么这条记录就一定可以被清除）</p>\n<p><img src=\"/../img/undolog.png\" alt=\"undolog\"></p>\n<p>由上图可知，不同事物或者相同事物对同一条记录的修改，就会导致该记录的undolog生成一条记录版本的线性链，链首就是最新的旧记录，链尾就是最早的旧记录</p>\n<h3 id=\"Read-View\"><a href=\"#Read-View\" class=\"headerlink\" title=\"Read View\"></a>Read View</h3><p>Read View是实现repeatable read的基础，当事务进行快照读的时候会产生一个读视图，用来对当前事务的可见性进行判断，也就是说，事务会将生成的Read View作为条件来判断当前事务能够看见哪个版本的数据，有可能读到最新的数据，也有可能读到undolog里面的某个版本的数据。</p>\n<h4 id=\"Read-View的可见性算法\"><a href=\"#Read-View的可见性算法\" class=\"headerlink\" title=\"Read View的可见性算法\"></a>Read View的可见性算法</h4><p>Read View的三个全局属性：</p>\n<ol>\n<li>trx_list：事务列表，即视图生成时刻系统正活跃未提交的事务ID</li>\n<li>up_limit_id：记录事务列表中ID最小的ID</li>\n<li>low_limit_id：视图生成时刻系统尚未分配的下一个事务（例如事务123正在活跃，事务4已提交，此时下一个事务ID就是5）</li>\n</ol>\n<p>具体的算法如下</p>\n<ol>\n<li>取出当前最新记录的DB_TRX_ID，即当前事务ID</li>\n<li>比较DB_TRX_ID&lt;up_limit_id，如果小于则说明当前事务能看见DB_TRX_ID所在的记录，如果大于等于就进入下一个判断</li>\n<li>判断DB_TRX_ID&gt;&#x3D;low_limit_id，如果大于等于，代表DB_TRX_ID所在的记录在readView生成后才出现，对于当前事务肯定不可见，如果小于，进入下一个判断</li>\n<li>判断DB_TRX_ID是否在活跃事务列表中，如果在，说明在视图生成时刻，该事务还没有提交，当前事务无法看见。若不在，说明以及提交，修改的结果可以看见（除自己以外的活跃trx_id都不可见）</li>\n</ol>\n<h4 id=\"RC，RR级别下的视图\"><a href=\"#RC，RR级别下的视图\" class=\"headerlink\" title=\"RC，RR级别下的视图\"></a>RC，RR级别下的视图</h4><p>在RR级别下某个事务对记录的第一次快照读会创建一个视图，此后在进行快照读时都会使用同一个视图，所以无论是否有其他事务对记录进行了修改，使用的都是这个视图，修改是不可见的，所以实现了可重复读的级别</p>\n<p>在RC级别下，每次快照读都会生成一个新的视图，所以在RC级别下总是可以看见其他事务的提交</p>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><p>MVCC其实就是在事务进行并发读写时提供一个快照，事务只能看见符合可见性的版本链内的记录，从而实现了并发读写的隔离性。RR的隔离级别解决了幻读问题。</p>\n<h1 id=\"MySQL调优\"><a href=\"#MySQL调优\" class=\"headerlink\" title=\"MySQL调优\"></a>MySQL调优</h1><p>代码优化：</p>\n<ol>\n<li>少使用select*，指定具体字段</li>\n<li>尽量少使用order by排序，而使用联合索引</li>\n<li>减少使用Null，有多个null的可以加默认值</li>\n<li>where后少使用函数运算</li>\n<li>避免超过五个以上的表连接</li>\n</ol>\n<p>SQL：</p>\n<ol>\n<li>对于高频筛选字段可以适当建立索引</li>\n<li>一个表的索引不超过五个</li>\n<li>联合索引，遵守最左匹配原则</li>\n</ol>\n<p><em><strong>如果MySQL出现慢查询，问题在哪？</strong></em></p>\n<ol>\n<li>索引失效或者无索引</li>\n<li>强制查询不存在的字段，此时MySQL会查询整张表</li>\n<li>两张表字符集不一样或者编码不一样，但是需要联表查询</li>\n<li>多线程查询操作，若线程A查询了很大的一块数据，此时server正在返回A的查询结果并占用了所有的IO，线程B的查询性能就会受限</li>\n</ol>\n<p><em><strong>如何解决呢？</strong></em></p>\n<ol>\n<li>一次查询数量过于庞大，拆成多次查询、拼装</li>\n<li>分离冷热数据，将大字段或者是查询频率少的数据分出一张新表</li>\n<li><code>IN</code>子查询影响查询性能，用<code>JOIN</code>方式代替</li>\n<li>用了反向查询（比如<code>NOT IN</code>）或者<code>IN</code>语句参数集太多，可能会导致全表扫描，这种情况尽量拆分语句</li>\n</ol>\n","text":"MySQL关系型数据库，插件式的存储引擎，这种架构可以根据业务的需求和实际需要选择合适的存储引擎。 客户端通过协议与服务器连接，发送查询语句，先检查缓存是否命中，若命中直接返回，否则进行语句解析 预处理，检查语句是否有语法错误，查询优化（是否会使用索引扫描），生成查询计划，启动查...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[],"tags":[{"name":"数据库基础","slug":"数据库基础","count":2,"path":"api/tags/数据库基础.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#MySQL\"><span class=\"toc-text\">MySQL</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%97%E6%AE%B5%E9%80%89%E6%8B%A9%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%88%E7%94%B1%E4%BC%98%E8%87%B3%E5%8A%A3%EF%BC%89\"><span class=\"toc-text\">字段选择优先级（由优至劣）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E5%8A%A1%E7%9A%84ACID\"><span class=\"toc-text\">事务的ACID</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%8C%83%E5%BC%8F\"><span class=\"toc-text\">范式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1NF-%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F\"><span class=\"toc-text\">1NF(第一范式)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2NF-%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F\"><span class=\"toc-text\">2NF(第二范式)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3NF-%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F\"><span class=\"toc-text\">3NF(第三范式)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB\"><span class=\"toc-text\">四种隔离级别</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E\"><span class=\"toc-text\">存储引擎</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">基础架构</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">索引</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HASH%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">HASH索引</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#B-%E6%A0%91%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">B+树索引</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#MYSQL%E7%9A%84%E5%90%84%E7%A7%8D%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">MYSQL的各种索引</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">主键索引(聚簇索引)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95-%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">二级索引(辅助索引)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">联合索引</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#MySQL%E7%9A%84%E9%94%81\"><span class=\"toc-text\">MySQL的锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8C%89%E9%94%81%E7%9A%84%E5%B1%9E%E6%80%A7%E5%88%86\"><span class=\"toc-text\">按锁的属性分</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%89%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6%E5%88%86\"><span class=\"toc-text\">按锁的粒度分</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%89%E9%94%81%E7%9A%84%E7%8A%B6%E6%80%81%E5%88%86\"><span class=\"toc-text\">按锁的状态分</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#MySQL%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">MySQL的主从同步</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#MySQL%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%A4%8D%E5%88%B6\"><span class=\"toc-text\">MySQL支持哪些复制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">为什么需要主从同步</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%97%A5%E5%BF%97%EF%BC%88bin-log%EF%BC%8Credo-log%E5%92%8Cundo-log%EF%BC%89\"><span class=\"toc-text\">日志（bin log，redo log和undo log）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#redo-log%EF%BC%88%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%EF%BC%89\"><span class=\"toc-text\">redo log（重做日志）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%B7%E7%9B%98%E6%97%B6%E6%9C%BA\"><span class=\"toc-text\">刷盘时机</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84\"><span class=\"toc-text\">日志文件组</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#bin-log%EF%BC%88%E5%BD%92%E6%A1%A3%E6%97%A5%E5%BF%97%EF%BC%89\"><span class=\"toc-text\">bin log（归档日志）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">记录格式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%86%99%E5%85%A5%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">写入机制</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4\"><span class=\"toc-text\">两阶段提交</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#undo-log\"><span class=\"toc-text\">undo log</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#MVCC\"><span class=\"toc-text\">MVCC</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BD%93%E5%89%8D%E8%AF%BB\"><span class=\"toc-text\">当前读</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BF%AB%E7%85%A7%E8%AF%BB\"><span class=\"toc-text\">快照读</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">实现原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">隐藏字段</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#undo-log-1\"><span class=\"toc-text\">undo log</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Read-View\"><span class=\"toc-text\">Read View</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Read-View%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">Read View的可见性算法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#RC%EF%BC%8CRR%E7%BA%A7%E5%88%AB%E4%B8%8B%E7%9A%84%E8%A7%86%E5%9B%BE\"><span class=\"toc-text\">RC，RR级别下的视图</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93%EF%BC%9A\"><span class=\"toc-text\">总结：</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#MySQL%E8%B0%83%E4%BC%98\"><span class=\"toc-text\">MySQL调优</span></a></li></ol>","author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Spring","uid":"946249c65165e1a3d66f50e0cb6e89e7","slug":"Spring","date":"2022-10-26T13:17:18.000Z","updated":"2022-11-14T12:54:23.900Z","comments":true,"path":"api/articles/Spring.json","keywords":null,"cover":[],"text":"bean的生命周期Bean的创建分为三个基本步骤 实例化：可以理解为new一个对象，AbstractAutowireCapableBeanFactory中的createBeanInstance方法 属性注入：可以理解为setter方法完成属性注入，AbstractAutowire...","link":"","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"JAVA进阶","slug":"JAVA进阶","count":1,"path":"api/tags/JAVA进阶.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"netty项目记录","uid":"cd132b199d60085bc82ceffbffeca6fd","slug":"netty项目记录——react线程模型简述","date":"2022-10-22T09:16:43.000Z","updated":"2022-11-15T12:38:14.159Z","comments":true,"path":"api/articles/netty项目记录——react线程模型简述.json","keywords":null,"cover":null,"text":"如何编写并启动一个服务端？ public void run() throws Exception&#123; //指定bossGroup，也就是负责处理连接请求的线程 EventLoopGroup bossGroup = new NioEventLoopGroup(1); //指...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"netty","slug":"netty","count":2,"path":"api/tags/netty.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}