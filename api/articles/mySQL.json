{"title":"mySQL","uid":"de0127f4fce15732bd481675d6959d45","slug":"mySQL","date":"2022-10-25T14:02:31.000Z","updated":"2022-10-26T11:02:07.896Z","comments":true,"path":"api/articles/mySQL.json","keywords":null,"cover":null,"content":"<h1 id=\"MYSQL\"><a href=\"#MYSQL\" class=\"headerlink\" title=\"MYSQL\"></a>MYSQL</h1><p>关系型数据库，插件式的存储引擎，这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p>\n<ol>\n<li>客户端通过协议与服务器连接，发送查询语句，先检查缓存是否命中，若命中直接返回，否则进行语句解析</li>\n<li>预处理，检查语句是否有语法错误，查询优化（是否会使用索引扫描），生成查询计划，启动查询引擎，开始查询，底层存储引擎调用API获取数据，返回给客户端</li>\n<li>MYSQL默认使用B+树索引</li>\n</ol>\n<p>四种隔离级别</p>\n<ol>\n<li>read uncommitted：所有事务都可以看见未提交的结果，产生脏读</li>\n<li>read committed：一个事务从开始到提交前，任何数据改变都是不可见的，产生不可重复读问题</li>\n<li>repeatable read：MySQL默认的隔离级别，解决不可重复读问题，保证同一事物的多个实例在并发读取事务时，会读取到同样的数据行，产生幻读问题（InnoDB的MVCC解决了幻读问题）</li>\n<li>serializable：最高级别的隔离，强制事务排序，不可能相互冲突，其实就是加锁，效率低</li>\n</ol>\n<h2 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h2><h2 id=\"为什么要有索引\"><a href=\"#为什么要有索引\" class=\"headerlink\" title=\"为什么要有索引\"></a>为什么要有索引</h2><p>一般的应用系统读写比例大约在10：1左右，而且数据的插入和更新出现性能问题的几率小于查询。在生产环境中，最容易出现问题的就是查询操作，因此对查询性能的优化就显得十分重要</p>\n<h2 id=\"索引的原理\"><a href=\"#索引的原理\" class=\"headerlink\" title=\"索引的原理\"></a>索引的原理</h2><p>索引的本质就是一个满足某种查找算法的数据结构，常见的有BST，AVL，红黑树，Btree，B+树等等</p>\n<p>这些结构以某种方式指向数据（索引结点指向数据记录物理地址的指针）</p>\n<ol>\n<li>索引大大减少了服务器需要扫描的数据量，提高了检索效率</li>\n<li>避免排序，减少CPU消耗</li>\n<li>将随机IO转换为顺序IO</li>\n</ol>\n<p>数据库的索引会复杂很多，因为数据库不仅面临等值查询，还有<strong>范围查询，模糊查询，并值查询</strong>等，并且由于数据库的索引一般存储于外存里，查询时需要将部分数据以页的形式读入内存，访问外存的成本大约是内存的十万倍，所以简单的的搜索树难以满足复杂的应用场景</p>\n<p>索引也是一张表，保存了主键和索引，指向了实体表，也需要占用内存。索引存储于外存，所以索引的查询也需要磁盘IO开销</p>\n<p>虽然提高了查询速度，但是在对实体表进行更新时，索引也需要进行相应的维护更新，而索引的维护也需要开销，降低了更新表的速度</p>\n<p>MySQL主要用到两种索引结构B+树和Hash索引</p>\n<p>InnoDB，MyISAM：默认是B+树</p>\n<p>Memory引擎：默认Hash索引</p>\n<h3 id=\"HASH索引\"><a href=\"#HASH索引\" class=\"headerlink\" title=\"HASH索引\"></a>HASH索引</h3><p>等值查询很快，计算的hash值与对应的行指针一并存入表中，哈希碰撞的元素以链表的形式相连。也不支持排序，以及模糊查询，并且由于散列算法，键值对的存储是无序的，所以不支持范围查询。</p>\n<h3 id=\"B-树索引\"><a href=\"#B-树索引\" class=\"headerlink\" title=\"B+树索引\"></a>B+树索引</h3><p>考虑到IO时十分高昂的操作，且数据库动辄百万级数据量，所以当一次IO时，常常以页作为单位来读取数据，当读取一页的数据至内存缓冲区时，实际上才发生了一次IO，所以控制IO的次数对于索引效率的提升，至关重要。</p>\n<p>B+树的特点：</p>\n<ol>\n<li>除叶子结点外的子节点：只起到索引的作用，仅存储指针，不存储信息</li>\n<li>所有信息存储于叶子结点，所有叶子结点在底部链接形成一个线性链表</li>\n</ol>\n<p>MYSQL默认使用B+树：为啥要用B+树，不用B树：</p>\n<p>因为两者都是存储于磁盘，而IO是花销很大的操作，innoDB每次申请磁盘空间时都会申请若干条连续的磁盘块来组成一页，并放入内存，读取索引，放回磁盘，不断重复，直到找到数据。</p>\n<p>所以如果每次申请到的数据都能有助于定位到所需数据，这将会减少IO次数，提高查询效率。</p>\n<p>对于B树，因为B树的每一个结点都会存储键和数据，每个结点的信息存储能力有限，树的高度也会更高，增加了IO次数，所以B树的查询效率波动很大。</p>\n<p>而B+树的非叶子结点只存储键，所以B+树的非叶子结点可以存储更多的信息，降低了树高度，平均一次IO可以获取更多索引，所以B+树更适合外存索引，且查询效率更稳定</p>\n<p>其中在 MySQL 底层对 B+ 树进行进一步优化：<strong>叶子节之间是双向链表，节点内部是单向链表，且在链表的头结点和尾节点也是循环指向的</strong>。</p>\n<h1 id=\"mySQL的锁的类型\"><a href=\"#mySQL的锁的类型\" class=\"headerlink\" title=\"mySQL的锁的类型\"></a>mySQL的锁的类型</h1><h2 id=\"按锁的属性分\"><a href=\"#按锁的属性分\" class=\"headerlink\" title=\"按锁的属性分\"></a>按锁的属性分</h2><p>共享锁：即读锁</p>\n<p>排他锁：即写锁</p>\n<h3 id=\"按锁的粒度分\"><a href=\"#按锁的粒度分\" class=\"headerlink\" title=\"按锁的粒度分\"></a>按锁的粒度分</h3><p>行级锁：锁住一行或者多行记录</p>\n<p>表级锁：给整个表加锁</p>\n<p>页级锁：介于行级锁和表锁的一种锁，一次锁定相邻的一组记录</p>\n<p>记录锁：行级锁的一种，锁住一条记录，避免数据在查询时被修改的不可重复读问题</p>\n<p>间隙锁：行级锁的一种，只出现在Repeatable read的事务中，解决了幻读的问题</p>\n<p>临键锁：InnoDB的行锁默认算法，就是记录锁和间隙锁的结合版，会锁住查询的记录，同时也会锁住范围内的所有间隙空间</p>\n<h3 id=\"按锁的状态分\"><a href=\"#按锁的状态分\" class=\"headerlink\" title=\"按锁的状态分\"></a>按锁的状态分</h3><p>意向共享锁</p>\n<p>意向排他锁</p>\n<h1 id=\"MySQL的主从同步\"><a href=\"#MySQL的主从同步\" class=\"headerlink\" title=\"MySQL的主从同步\"></a>MySQL的主从同步</h1><p>MySQL内建的复制功能是构建大型，高性能应用程序的基础。</p>\n<p>将MySQL的数据分布到多个系统上去，这种分布的机制，是通过将MySQL的某一台主机的数据复制到其它主机（slave）上，并重新执行一遍来实现。</p>\n<p>复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。</p>\n<p>主服务器将更新写入二进制日志文件，并维护文件的一个索引以跟踪日志循坏，这些日志可以记录发送到从服务器的更新。</p>\n<p>当一个从服务器连接主服务器时，它通知主服务器从服务器在日志中读取的最后一次成功更新的位置。从服务器接收从那时起发生的任何更新，然后封锁并等待主服务器通知的更新。</p>\n<h2 id=\"MySQL支持哪些复制\"><a href=\"#MySQL支持哪些复制\" class=\"headerlink\" title=\"MySQL支持哪些复制\"></a>MySQL支持哪些复制</h2><ol>\n<li>基于语句的复制：在主服务器上执行的sql语句，在从服务器上执行同样的语句。mysql默认采用基于语句的复制，效率比较高。一旦发现没法精确复制时，会自动选着基于行的复制。</li>\n<li>基于行的复制：把改变的内容复制过去，而不是把命令在从服务器上执行一遍。从mysql 5.0开始支持</li>\n<li>混合类型的复制：默认采用基于语句的复制，一旦发现基于语句的无法精确复制时，就会采用基于行的复制</li>\n</ol>\n<h2 id=\"为什么需要主从同步\"><a href=\"#为什么需要主从同步\" class=\"headerlink\" title=\"为什么需要主从同步\"></a>为什么需要主从同步</h2><ol>\n<li>若出现锁表不能读的情况，此时可以使用主从复制，让主库负责写，从库负责读，这样就不影响业务的正常运行</li>\n<li>当IO频率越来越大时，业务量越来越大时，单机已无法满足，此时多库的处理可以提高IO的性能</li>\n</ol>\n","feature":true,"text":"MYSQL关系型数据库，插件式的存储引擎，这种架构可以根据业务的需求和实际需要选择合适的存储引擎。 客户端通过协议与服务器连接，发送查询语句，先检查缓存是否命中，若命中直接返回，否则进行语句解析 预处理，检查语句是否有语法错误，查询优化（是否会使用索引扫描），生成查询计划，启动查...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"数据库基础","slug":"数据库基础","count":2,"path":"api/tags/数据库基础.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#MYSQL\"><span class=\"toc-text\">MYSQL</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">索引</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">为什么要有索引</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">索引的原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HASH%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">HASH索引</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#B-%E6%A0%91%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">B+树索引</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#mySQL%E7%9A%84%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">mySQL的锁的类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8C%89%E9%94%81%E7%9A%84%E5%B1%9E%E6%80%A7%E5%88%86\"><span class=\"toc-text\">按锁的属性分</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%89%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6%E5%88%86\"><span class=\"toc-text\">按锁的粒度分</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%89%E9%94%81%E7%9A%84%E7%8A%B6%E6%80%81%E5%88%86\"><span class=\"toc-text\">按锁的状态分</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#MySQL%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">MySQL的主从同步</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#MySQL%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%A4%8D%E5%88%B6\"><span class=\"toc-text\">MySQL支持哪些复制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">为什么需要主从同步</span></a></li></ol></li></ol>","author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"netty——reactor线程模型简述","uid":"0bdbdbbdfc4f649a26dfdf23cf4f1d34","slug":"netty项目记录——react线程模型简述","date":"2022-10-22T09:16:43.000Z","updated":"2022-10-23T09:26:13.439Z","comments":true,"path":"api/articles/netty项目记录——react线程模型简述.json","keywords":null,"cover":[],"text":"BIOBlock IO:同步阻塞IO，一般传统的JDK内置的Socket编程就是BIO。其底层流程是： 创建socket接口，号为x 使用bind函数将接口号与端口号进行绑定 进行listen监听事件或者是read读事件，且会一直阻塞在该命令，直到有客户端连接或者发送数据 缺点：...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"netty高并发项目","slug":"netty高并发项目","count":1,"path":"api/tags/netty高并发项目.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}