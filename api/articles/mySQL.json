{"title":"mySQL","uid":"de0127f4fce15732bd481675d6959d45","slug":"mySQL","date":"2022-10-25T14:02:31.000Z","updated":"2022-10-27T09:32:18.031Z","comments":true,"path":"api/articles/mySQL.json","keywords":null,"cover":[],"content":"<h1 id=\"MYSQL\"><a href=\"#MYSQL\" class=\"headerlink\" title=\"MYSQL\"></a>MYSQL</h1><p>关系型数据库，插件式的存储引擎，这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p>\n<ol>\n<li>客户端通过协议与服务器连接，发送查询语句，先检查缓存是否命中，若命中直接返回，否则进行语句解析</li>\n<li>预处理，检查语句是否有语法错误，查询优化（是否会使用索引扫描），生成查询计划，启动查询引擎，开始查询，底层存储引擎调用API获取数据，返回给客户端</li>\n<li>MYSQL默认使用B+树索引</li>\n</ol>\n<p>四种隔离级别</p>\n<ol>\n<li>read uncommitted：所有事务都可以看见未提交的结果，产生脏读</li>\n<li>read committed：一个事务从开始到提交前，任何数据改变都是不可见的，产生不可重复读问题</li>\n<li>repeatable read：MySQL默认的隔离级别，解决不可重复读问题，保证同一事物的多个实例在并发读取事务时，会读取到同样的数据行，产生幻读问题（InnoDB的MVCC解决了幻读问题）</li>\n<li>serializable：最高级别的隔离，强制事务排序，不可能相互冲突，其实就是加锁，效率低</li>\n</ol>\n<h2 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h2><h2 id=\"为什么要有索引\"><a href=\"#为什么要有索引\" class=\"headerlink\" title=\"为什么要有索引\"></a>为什么要有索引</h2><p>一般的应用系统读写比例大约在10：1左右，而且数据的插入和更新出现性能问题的几率小于查询。在生产环境中，最容易出现问题的就是查询操作，因此对查询性能的优化就显得十分重要</p>\n<h2 id=\"索引的原理\"><a href=\"#索引的原理\" class=\"headerlink\" title=\"索引的原理\"></a>索引的原理</h2><p>索引的本质就是一个满足某种查找算法的数据结构，常见的有BST，AVL，红黑树，Btree，B+树等等</p>\n<p>这些结构以某种方式指向数据（索引结点指向数据记录物理地址的指针）</p>\n<ol>\n<li>索引大大减少了服务器需要扫描的数据量，提高了检索效率</li>\n<li>避免排序，减少CPU消耗</li>\n<li>将随机IO转换为顺序IO</li>\n</ol>\n<p>数据库的索引会复杂很多，因为数据库不仅面临等值查询，还有<strong>范围查询，模糊查询，并值查询</strong>等，并且由于数据库的索引一般存储于外存里，查询时需要将部分数据以页的形式读入内存，访问外存的成本大约是内存的十万倍，所以简单的的搜索树难以满足复杂的应用场景</p>\n<p>索引也是一张表，保存了主键和索引，指向了实体表，也需要占用内存。索引存储于外存，所以索引的查询也需要磁盘IO开销</p>\n<p>虽然提高了查询速度，但是在对实体表进行更新时，索引也需要进行相应的维护更新，而索引的维护也需要开销，降低了更新表的速度</p>\n<p>MySQL主要用到两种索引结构B+树和Hash索引</p>\n<p>InnoDB，MyISAM：默认是B+树</p>\n<p>Memory引擎：默认Hash索引</p>\n<h3 id=\"HASH索引\"><a href=\"#HASH索引\" class=\"headerlink\" title=\"HASH索引\"></a>HASH索引</h3><p>等值查询很快，计算的hash值与对应的行指针一并存入表中，哈希碰撞的元素以链表的形式相连。也不支持排序，以及模糊查询，并且由于散列算法，键值对的存储是无序的，所以不支持范围查询。</p>\n<h3 id=\"B-树索引\"><a href=\"#B-树索引\" class=\"headerlink\" title=\"B+树索引\"></a>B+树索引</h3><p>考虑到IO时十分高昂的操作，且数据库动辄百万级数据量，所以当一次IO时，常常以页作为单位来读取数据，当读取一页的数据至内存缓冲区时，实际上才发生了一次IO，所以控制IO的次数对于索引效率的提升，至关重要。</p>\n<p>B+树的特点：</p>\n<ol>\n<li>除叶子结点外的子节点：只起到索引的作用，仅存储指针，不存储信息</li>\n<li>所有信息存储于叶子结点，所有叶子结点在底部链接形成一个线性链表</li>\n</ol>\n<p>MYSQL默认使用B+树：为啥要用B+树，不用B树：</p>\n<p>因为两者都是存储于磁盘，而IO是花销很大的操作，innoDB每次申请磁盘空间时都会申请若干条连续的磁盘块来组成一页，并放入内存，读取索引，放回磁盘，不断重复，直到找到数据。</p>\n<p>所以如果每次申请到的数据都能有助于定位到所需数据，这将会减少IO次数，提高查询效率。</p>\n<p>对于B树，因为B树的每一个结点都会存储键和数据，每个结点的信息存储能力有限，树的高度也会更高，增加了IO次数，所以B树的查询效率波动很大。</p>\n<p>而B+树的非叶子结点只存储键，所以B+树的非叶子结点可以存储更多的信息，降低了树高度，平均一次IO可以获取更多索引，所以B+树更适合外存索引，且查询效率更稳定</p>\n<p>其中在 MySQL 底层对 B+ 树进行进一步优化：<strong>叶子节之间是双向链表，节点内部是单向链表，且在链表的头结点和尾节点也是循环指向的</strong>。</p>\n<h1 id=\"mySQL的锁的类型\"><a href=\"#mySQL的锁的类型\" class=\"headerlink\" title=\"mySQL的锁的类型\"></a>mySQL的锁的类型</h1><h2 id=\"按锁的属性分\"><a href=\"#按锁的属性分\" class=\"headerlink\" title=\"按锁的属性分\"></a>按锁的属性分</h2><p>共享锁：即读锁</p>\n<p>排他锁：即写锁</p>\n<h3 id=\"按锁的粒度分\"><a href=\"#按锁的粒度分\" class=\"headerlink\" title=\"按锁的粒度分\"></a>按锁的粒度分</h3><p>行级锁：锁住一行或者多行记录</p>\n<p>表级锁：给整个表加锁</p>\n<p>页级锁：介于行级锁和表锁的一种锁，一次锁定相邻的一组记录</p>\n<p>记录锁：行级锁的一种，锁住一条记录，避免数据在查询时被修改的不可重复读问题</p>\n<p>间隙锁：行级锁的一种，只出现在Repeatable read的事务中，解决了幻读的问题</p>\n<p>临键锁：InnoDB的行锁默认算法，就是记录锁和间隙锁的结合版，会锁住查询的记录，同时也会锁住范围内的所有间隙空间</p>\n<h3 id=\"按锁的状态分\"><a href=\"#按锁的状态分\" class=\"headerlink\" title=\"按锁的状态分\"></a>按锁的状态分</h3><p>意向共享锁</p>\n<p>意向排他锁</p>\n<h1 id=\"MySQL的主从同步\"><a href=\"#MySQL的主从同步\" class=\"headerlink\" title=\"MySQL的主从同步\"></a>MySQL的主从同步</h1><p>MySQL内建的复制功能是构建大型，高性能应用程序的基础。</p>\n<p>将MySQL的数据分布到多个系统上去，这种分布的机制，是通过将MySQL的某一台主机的数据复制到其它主机（slave）上，并重新执行一遍来实现。</p>\n<p>复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。</p>\n<p>主服务器将更新写入二进制日志文件，并维护文件的一个索引以跟踪日志循坏，这些日志可以记录发送到从服务器的更新。</p>\n<p>当一个从服务器连接主服务器时，它通知主服务器从服务器在日志中读取的最后一次成功更新的位置。从服务器接收从那时起发生的任何更新，然后封锁并等待主服务器通知的更新。</p>\n<h2 id=\"MySQL支持哪些复制\"><a href=\"#MySQL支持哪些复制\" class=\"headerlink\" title=\"MySQL支持哪些复制\"></a>MySQL支持哪些复制</h2><ol>\n<li>基于语句的复制：在主服务器上执行的sql语句，在从服务器上执行同样的语句。mysql默认采用基于语句的复制，效率比较高。一旦发现没法精确复制时，会自动选着基于行的复制。</li>\n<li>基于行的复制：把改变的内容复制过去，而不是把命令在从服务器上执行一遍。从mysql 5.0开始支持</li>\n<li>混合类型的复制：默认采用基于语句的复制，一旦发现基于语句的无法精确复制时，就会采用基于行的复制</li>\n</ol>\n<h2 id=\"为什么需要主从同步\"><a href=\"#为什么需要主从同步\" class=\"headerlink\" title=\"为什么需要主从同步\"></a>为什么需要主从同步</h2><ol>\n<li>若出现锁表不能读的情况，此时可以使用主从复制，让主库负责写，从库负责读，这样就不影响业务的正常运行</li>\n<li>当IO频率越来越大时，业务量越来越大时，单机已无法满足，此时多库的处理可以提高IO的性能</li>\n</ol>\n<h1 id=\"MVCC\"><a href=\"#MVCC\" class=\"headerlink\" title=\"MVCC\"></a>MVCC</h1><p>Multi-Version Concurrency Control多版本并发控制，实现对数据库的并发访问，实现读写冲突不加锁，非阻塞并发读。</p>\n<p>数据库的并发有三种场景</p>\n<ol>\n<li>读读：不存在任何问题，不需要并发控制</li>\n<li>读写：有线程安全问题，可能会造成脏读，幻读，不可重复读等问题</li>\n<li>写写：有线程安全问题，可能存在更新丢失的问题</li>\n</ol>\n<p>MVCC的实现原理就是为事务分配单项增长的时间戳，为每个修改保存一个版本，版本与时间戳相关联，解决了脏读，幻读，不可重复读的问题，但是不能解决更新丢失的问题，可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低</p>\n<h3 id=\"当前读\"><a href=\"#当前读\" class=\"headerlink\" title=\"当前读\"></a>当前读</h3><p>也叫锁定读Locking Read，读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁，比如update 、delete 、insert</p>\n<h3 id=\"快照读\"><a href=\"#快照读\" class=\"headerlink\" title=\"快照读\"></a>快照读</h3><p>也叫普通读Consistent Read，就是单纯的select语句，但不包括for update，就是不加锁的非阻塞读，前提是不使用serializable的隔离级别，实现原理即MVCC</p>\n<h2 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h2><h3 id=\"隐藏字段\"><a href=\"#隐藏字段\" class=\"headerlink\" title=\"隐藏字段\"></a>隐藏字段</h3><p>每行记录除了自定义的字段外，还有数据库隐式定义的字段</p>\n<p>DB_TRX_ID<br>6字节，最近修改事务的ID，即创建这条记录或者最后一次修改这条记录的事务ID</p>\n<p>DB_ROLL_PTR</p>\n<p>7字节，回滚指针，指向这条记录的上一个版本，用于配合undolog</p>\n<p>DB_ROW_ID</p>\n<p>6字节，隐藏的主键，如果数据表没有主键，innoDB就会自动生成一个row_id</p>\n<h3 id=\"undolog\"><a href=\"#undolog\" class=\"headerlink\" title=\"undolog\"></a>undolog</h3><p>即回滚日志，即进行插入，更新，删除操作后生成的记录链</p>\n<p>当进行insert时，产生的undolog只在事务回滚的时候需要，可以在事务提交后被丢弃</p>\n<p>当进行update和delete操作时，undolog不仅在事务回滚时需要，在快照读时也需要，所以必须保留，只有在回滚或者快照读不涉及该日志时，undolog才会被purge线程清除（若delete_bit为true，且DB_TRX_ID相对于purge线程的read view可见，那么这条记录就一定可以被清除）</p>\n<p><img src=\"/../img/undolog.png\" alt=\"undolog\"></p>\n<p>由上图可知，不同事物或者相同事物对同一条记录的修改，就会导致该记录的undolog生成一条记录版本的线性链，链首就是最新的旧记录，链尾就是最早的旧记录</p>\n<h3 id=\"Read-View\"><a href=\"#Read-View\" class=\"headerlink\" title=\"Read View\"></a>Read View</h3><p>Read View是实现repeatable read的基础，当事务进行快照读的时候会产生一个读视图，用来对当前事务的可见性进行判断，也就是说，事务会将生成的ReadView作为条件来判断当前事务能够看见哪个版本的数据，有可能读到最新的数据，也有可能读到undolog里面的某个版本的数据。</p>\n<h4 id=\"ReadView的可见性算法\"><a href=\"#ReadView的可见性算法\" class=\"headerlink\" title=\"ReadView的可见性算法\"></a>ReadView的可见性算法</h4><p>ReadView的三个全局属性：</p>\n<ol>\n<li>trx_list：事务列表，即视图生成时刻系统正活跃未提交的事务ID</li>\n<li>up_limit_id：记录事务列表中ID最小的ID</li>\n<li>low_limit_id：视图生成时刻系统尚未分配的下一个事务（例如事务123正在活跃，事务4已提交，此时下一个事务ID就是5）</li>\n</ol>\n<p>具体的算法如下</p>\n<ol>\n<li>取出当前最新记录的DB_TRX_ID，即当前事务ID</li>\n<li>比较DB_TRX_ID&lt;up_limit_id，如果小于则说明当前事务能看见DB_TRX_ID所在的记录，如果大于等于就进入下一个判断</li>\n<li>判断DB_TRX_ID&gt;&#x3D;low_limit_id，如果大于等于，代表DB_TRX_ID所在的记录在readView生成后才出现，对于当前事务肯定不可见，如果小于，进入下一个判断</li>\n<li>判断DB_TRX_ID是否在活跃事务列表中，如果在，说明在视图生成时刻，该事务还没有提交，当前事务无法看见。若不在，说明以及提交，修改的结果可以看见（除自己以外的活跃trx_id都不可见）</li>\n</ol>\n<h4 id=\"RC，RR级别下的视图\"><a href=\"#RC，RR级别下的视图\" class=\"headerlink\" title=\"RC，RR级别下的视图\"></a>RC，RR级别下的视图</h4><p>在RR级别下某个事务对记录的第一次快照读会创建一个视图，此后在进行快照读时都会使用同一个视图，所以无论是否有其他事务对记录进行了修改，使用的都是这个视图，修改是不可见的，所以实现了可重复读的级别</p>\n<p>在RC级别下，每次快照读都会生成一个新的视图，所以在RC级别下总是可以看见其他事务的提交</p>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><p>MVCC其实就是在事务进行并发读写时提供一个快照，事务只能看见符合可见性的版本链内的记录，从而实现了并发读写的隔离性。RR的隔离级别解决了幻读问题。</p>\n","text":"MYSQL关系型数据库，插件式的存储引擎，这种架构可以根据业务的需求和实际需要选择合适的存储引擎。 客户端通过协议与服务器连接，发送查询语句，先检查缓存是否命中，若命中直接返回，否则进行语句解析 预处理，检查语句是否有语法错误，查询优化（是否会使用索引扫描），生成查询计划，启动查...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"数据库基础","slug":"数据库基础","count":2,"path":"api/tags/数据库基础.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#MYSQL\"><span class=\"toc-text\">MYSQL</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">索引</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">为什么要有索引</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">索引的原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HASH%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">HASH索引</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#B-%E6%A0%91%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">B+树索引</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#mySQL%E7%9A%84%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">mySQL的锁的类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8C%89%E9%94%81%E7%9A%84%E5%B1%9E%E6%80%A7%E5%88%86\"><span class=\"toc-text\">按锁的属性分</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%89%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6%E5%88%86\"><span class=\"toc-text\">按锁的粒度分</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%89%E9%94%81%E7%9A%84%E7%8A%B6%E6%80%81%E5%88%86\"><span class=\"toc-text\">按锁的状态分</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#MySQL%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">MySQL的主从同步</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#MySQL%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%A4%8D%E5%88%B6\"><span class=\"toc-text\">MySQL支持哪些复制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">为什么需要主从同步</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#MVCC\"><span class=\"toc-text\">MVCC</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BD%93%E5%89%8D%E8%AF%BB\"><span class=\"toc-text\">当前读</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BF%AB%E7%85%A7%E8%AF%BB\"><span class=\"toc-text\">快照读</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">实现原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">隐藏字段</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#undolog\"><span class=\"toc-text\">undolog</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Read-View\"><span class=\"toc-text\">Read View</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ReadView%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">ReadView的可见性算法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#RC%EF%BC%8CRR%E7%BA%A7%E5%88%AB%E4%B8%8B%E7%9A%84%E8%A7%86%E5%9B%BE\"><span class=\"toc-text\">RC，RR级别下的视图</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93%EF%BC%9A\"><span class=\"toc-text\">总结：</span></a></li></ol></li></ol>","author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Spring","uid":"946249c65165e1a3d66f50e0cb6e89e7","slug":"Spring","date":"2022-10-26T13:17:18.000Z","updated":"2022-11-08T14:06:42.622Z","comments":true,"path":"api/articles/Spring.json","keywords":null,"cover":[],"text":"bean的生命周期Bean的创建分为三个基本步骤 实例化：可以理解为new一个对象，AbstractAutowireCapableBeanFactory中的createBeanInstance方法 属性注入：可以理解为setter方法完成属性注入，AbstractAutowire...","link":"","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"JAVA进阶","slug":"JAVA进阶","count":1,"path":"api/tags/JAVA进阶.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"netty——reactor线程模型简述","uid":"0bdbdbbdfc4f649a26dfdf23cf4f1d34","slug":"netty项目记录——react线程模型简述","date":"2022-10-22T09:16:43.000Z","updated":"2022-10-23T09:26:13.439Z","comments":true,"path":"api/articles/netty项目记录——react线程模型简述.json","keywords":null,"cover":[],"text":"BIOBlock IO:同步阻塞IO，一般传统的JDK内置的Socket编程就是BIO。其底层流程是： 创建socket接口，号为x 使用bind函数将接口号与端口号进行绑定 进行listen监听事件或者是read读事件，且会一直阻塞在该命令，直到有客户端连接或者发送数据 缺点：...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"netty高并发项目","slug":"netty高并发项目","count":1,"path":"api/tags/netty高并发项目.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}