{"title":"MySQL","uid":"838ae74e3a76757d637de803a615bfd9","slug":"mySQL","date":"2022-10-25T14:02:31.000Z","updated":"2022-11-11T08:34:39.367Z","comments":true,"path":"api/articles/mySQL.json","keywords":null,"cover":[],"content":"<h1 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h1><p>关系型数据库，插件式的存储引擎，这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p>\n<ol>\n<li>客户端通过协议与服务器连接，发送查询语句，先检查缓存是否命中，若命中直接返回，否则进行语句解析</li>\n<li>预处理，检查语句是否有语法错误，查询优化（是否会使用索引扫描），生成查询计划，启动查询引擎，开始查询，底层存储引擎调用API获取数据，返回给客户端</li>\n<li>MYSQL默认使用B+树索引</li>\n</ol>\n<h3 id=\"字段选择优先级（由优至劣）\"><a href=\"#字段选择优先级（由优至劣）\" class=\"headerlink\" title=\"字段选择优先级（由优至劣）\"></a>字段选择优先级（由优至劣）</h3><ol>\n<li>整型</li>\n<li>time：定长运算快</li>\n<li>enum：枚举，能约束值，内部由整型存储</li>\n<li>char：定长，需要考虑字符集</li>\n<li>varchar：不定长，考虑字符集的转换与排序的校对集，速度慢</li>\n<li>text：无法使用内存临时表</li>\n</ol>\n<p><em><strong>定长优先。能选整型就不要选字符串，够用就行，不要富余分配空间，尽量避免使用Null</strong></em></p>\n<p>varchar最多可以定义65535个字节</p>\n<h3 id=\"事务的ACID\"><a href=\"#事务的ACID\" class=\"headerlink\" title=\"事务的ACID\"></a>事务的ACID</h3><ol>\n<li>原子性：要么全部成功，要么全部失败。由undo_log来保证</li>\n<li>一致性：数据库总是从一个状态转移到另一个状态</li>\n<li>隔离性：最终提交前，其他事务不可见，MVCC</li>\n<li>持久性：事务一旦提交，修改将会永久保存到数据库中，内存+redo_log</li>\n</ol>\n<p>MYSQL的各种索引</p>\n<ol>\n<li>主键索引：一张表一个主键索引，通常与表一起创建。</li>\n<li>唯一索引：如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。这么做的好处：一是简化了MySQL对这个索引的管理工作，这个索引也因此而变得更有效率；二是MySQL会在有新记录插入数据表时，如果字段的值已经出现过了，MySQL将拒绝插入那条新记录。也就是说，唯一索引可以保证数据记录的唯一性。事实上，在许多场合，人们创建唯一索引的目的往往不是为了提高访问速度，而只是为了避免数据出现重复。</li>\n<li>普通索引：建立在普通字段上的索引，唯一任务是加快对数据的访问速度。因此，应该只为那些最经常出现在查询条件（WHEREc）或排序条件（ORDERBY）中的数据列创建索引。只要有可能，就应该选择一个数据最整齐、最紧凑的数据列（如一个整数类型的数据列）来创建索引。</li>\n<li>复合索引：字符类型字段的前几个字符建立，可以覆盖多个数据列，遵循最左匹配原则，可能会因为order by失效。</li>\n</ol>\n<p>三星索引：衡量一个索引是否达到最佳表现的三个维度</p>\n<ol>\n<li>第一星：where后面的等值谓词，可以匹配索引列的顺序：意义在于谓索匹配的越多，索引片越窄，最终扫描的数据行也是越小。把 <strong>WHERE 后的等值条件列作为索引最开头的列，如此，必须扫描的索引片宽度就会缩至最短。</strong></li>\n<li>第二星：order by的排序是否和索引的顺序一致：意义在于避免进行额外的排序，增加消耗。<strong>将 ORDER BY 列加入到索引中，保持列的顺序</strong></li>\n<li>第三星：select的字段是否都为索引列：意义在于避免每一个索引行查询，都需要去聚簇索引进行一次随机IO查询。<strong>将查询语句中剩余的列都加入到索引中。</strong></li>\n</ol>\n<p><em><strong>普通索引和唯一索引有什么区别？</strong></em></p>\n<p><strong>概念上的不同</strong>：普通索引可以重复。而唯一索引和主键一样，不可以重复，但在一张表里面只能有一个主键，不能为空，唯一索引可有多个。唯一索引可有一条记录为null。在学校，一般用学号做主键，身份证号作为唯一索引</p>\n<p><strong>查询实现的不同</strong>：若查询语句为</p>\n<pre class=\"line-numbers language-SQL\" data-language=\"SQL\"><code class=\"language-SQL\">select id from T where k&#x3D;4<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>普通索引：查找到满足条件的第一个记录后，继续查找下个记录，直到碰到第一个不满足k&#x3D;4的记录。</p>\n<p>唯一索引：查到第一个满足条件的，就停止搜索。</p>\n<p>若重复数据很多，普通索引多了一次“查找和判断下一条记录”的操作，可能会多次IO，但是总体性能其实差别不大</p>\n<p><strong>更新性能不同</strong>：往表中插入一个新记录，<code>InnoDB</code>会有什么反应？</p>\n<p>若在内存中，普通索引直接插入，而唯一索引会判断一次是否有冲突，再插入。判断的性能消耗可以不计</p>\n<p>若不在内存中，普通索引会将数据记录在change buffer；唯一索引会将数据页读入内存再插入。众所周知数据库的IO成本很高，所以普通索引更新数据的性能是要更优的。</p>\n<p><strong>总结：若更新性能优先级更高，选择普通索引。</strong></p>\n<h3 id=\"四种隔离级别\"><a href=\"#四种隔离级别\" class=\"headerlink\" title=\"四种隔离级别\"></a>四种隔离级别</h3><ol>\n<li>read uncommitted：所有事务都可以看见未提交的结果，产生脏读</li>\n<li>read committed：一个事务从开始到提交前，任何数据改变都是不可见的，产生不可重复读问题</li>\n<li>repeatable read：<code>MySQL</code>默认的隔离级别，解决不可重复读问题，保证同一事物的多个实例在并发读取事务时，会读取到同样的数据行，产生幻读问题（<code>InnoDB</code>的MVCC解决了幻读问题）</li>\n<li>serializable：最高级别的隔离，强制事务排序，不可能相互冲突，其实就是加锁，效率低</li>\n</ol>\n<h2 id=\"存储引擎\"><a href=\"#存储引擎\" class=\"headerlink\" title=\"存储引擎\"></a>存储引擎</h2><p><code>MyISAM</code>和<code>InnoDB</code>的区别是什么</p>\n<ol>\n<li><code>InnoDB</code>：支持事务，支持外键，聚集索引：文件存储于主键索引的叶子节点上，所以主键索引效率很高，但是辅助索引需要进行回表，并且主键不能过大，因为辅助索引也会存储主键，所以过大的主键会影响索引的大小。最小粒度锁为行锁</li>\n<li><code>MyISAM</code>：不支持事务，不支持外键，非聚集索引，索引保存的是数据文件的指针，主键索引和辅助索引独立。会创建一个单独的变量保存整个表的行数，读取表行数的速度更快。最小粒度锁为表锁，并发性能不好。</li>\n</ol>\n<h2 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h2><h2 id=\"为什么要有索引\"><a href=\"#为什么要有索引\" class=\"headerlink\" title=\"为什么要有索引\"></a>为什么要有索引</h2><p>一般的应用系统读写比例大约在10：1左右，而且数据的插入和更新出现性能问题的几率小于查询。在生产环境中，最容易出现问题的就是查询操作，因此对查询性能的优化就显得十分重要</p>\n<h2 id=\"索引的原理\"><a href=\"#索引的原理\" class=\"headerlink\" title=\"索引的原理\"></a>索引的原理</h2><p>索引的本质就是一个满足某种查找算法的数据结构，常见的有BST，AVL，红黑树，Btree，B+树等等</p>\n<p>这些结构以某种方式指向数据（索引结点指向数据记录物理地址的指针）</p>\n<ol>\n<li>索引大大减少了服务器需要扫描的数据量，提高了检索效率</li>\n<li>避免排序，减少CPU消耗</li>\n<li>将随机IO转换为顺序IO</li>\n</ol>\n<p>数据库的索引会复杂很多，因为数据库不仅面临等值查询，还有<strong>范围查询，模糊查询，并值查询</strong>等，并且由于数据库的索引一般存储于外存里，查询时磁盘和主存以页为单位交换数据（通常为4k的整数倍），访问外存的时间成本大约是内存的十万倍，所以简单的的搜索树难以满足复杂的应用场景</p>\n<p>索引也是一张表，保存了主键和索引，指向了实体表，也需要占用内存。索引存储于外存，所以索引的查询也需要磁盘IO开销</p>\n<p>虽然提高了查询速度，但是在对实体表进行更新时，索引也需要进行相应的维护更新，而索引的维护也需要开销，降低了更新表的速度</p>\n<p>MySQL主要用到两种索引结构B+树和Hash索引</p>\n<p><code>InnoDB</code>，<code>MyISAM</code>：默认是B+树</p>\n<p>Memory引擎：默认Hash索引</p>\n<h3 id=\"HASH索引\"><a href=\"#HASH索引\" class=\"headerlink\" title=\"HASH索引\"></a>HASH索引</h3><p>等值查询很快，计算的hash值与对应的行指针一并存入表中，哈希碰撞的元素以链表的形式相连。也不支持排序，以及模糊查询，并且由于散列算法，键值对的存储是无序的，所以不支持范围查询。</p>\n<h3 id=\"B-树索引\"><a href=\"#B-树索引\" class=\"headerlink\" title=\"B+树索引\"></a>B+树索引</h3><p>考虑到IO时十分高昂的操作，且数据库动辄百万级数据量，所以当一次IO时，常常以页作为单位来读取数据，当读取一页的数据至内存缓冲区时，实际上才发生了一次IO，所以控制IO的次数对于索引效率的提升，至关重要。</p>\n<p>B+树的特点：</p>\n<ol>\n<li>除叶子结点外的子节点：只起到索引的作用，仅存储指针，不存储信息</li>\n<li>所有信息存储于叶子结点，所有叶子结点在底部链接形成一个双向链表（范围查询）</li>\n</ol>\n<p>在<code>InnoDB</code>中，叶子节点的容量默认为一页16KB</p>\n<p><strong>叶子节点结构：页目录（主键）+用户数据区域（单向链表，通过主键排序，在插入数据的时候便会排序）</strong></p>\n<p><strong>非叶子节点结构：页指针+指向的该页的最小主键值</strong></p>\n<p>主键索引，即聚簇索引结构图：</p>\n<p><img src=\"/../img/B+tree.png\" alt=\"B+tree\"></p>\n<p><strong>复合索引：</strong></p>\n<p>同样是B+树，以非主键而是以自定义规则的索引，以满足不同的查询需求</p>\n<p>叶子节点的用户数据区不再存储完整记录，而是存储<strong>主键+部分记录</strong>。</p>\n<p>所以使用辅助索引有时候需要进行回表，即部分记录无法满足查询需求，需要使用主键来重新到主键索引查找。</p>\n<p><em><strong>什么情况下设置了复合索引，但不会使用？</strong></em></p>\n<ol>\n<li>没有符合最左匹配原则</li>\n<li>字段进行了隐私数据类型转化</li>\n<li>引擎估算走辅助索引的时间反而比全表扫描的时间更长</li>\n</ol>\n<p><em><strong>什么是最左匹配原则？</strong></em></p>\n<p>对于复合索引，若有字段123，若查询时省略字段1，则无法使用索引。</p>\n<p>因为数据库依据联合索引最左的字段来构建 B+ 树，叶子节点的排序是以字段123的顺序进行的，只有先确定了前一个（左侧的值）后，才能确定下一个值。a有序，b才能有序，若a省略，则无法有序查找bc。</p>\n<p><em><strong>MYSQL默认使用B+树，为啥要用B+树，不用B树？</strong></em></p>\n<p>因为两者都是存储于磁盘，而IO是花销很大的操作，InnoDB每次申请磁盘空间时都会申请若干条连续的磁盘块来组成一页，并放入内存，读取索引，放回磁盘，不断重复，直到找到数据。</p>\n<p>所以如果每次申请到的数据都能有助于定位到所需数据，这将会减少IO次数，提高查询效率。</p>\n<p>对于B树，因为B树的每一个结点都会存储键，指针和数据，每个磁盘块的信息存储能力有限，树的高度也会更高，增加了IO次数，所以B树的查询效率波动很大。</p>\n<p>而B+树的非叶子结点只存储键，所以B+树的非叶子结点可以存储更多的信息，降低了树高度，平均一次IO可以获取更多索引，所以B+树更适合外存索引，且查询效率更稳定</p>\n<p>其中在 MySQL 底层对 B+ 树进行进一步优化：</p>\n<p><strong>叶子节之间是双向链表，节点内部是单向链表，且在链表的头结点和尾节点也是循环指向的</strong>。（范围查询的关键）</p>\n<p><em><strong>为什么不用红黑树？</strong></em></p>\n<p>无论是二叉树还是红黑树，都会因为树的深度过深而导致IO次数变多，效率不高</p>\n<p><em><strong><code>InnoDB</code>一颗高度为3的B+树可以存放多少行数据？</strong></em></p>\n<p><code>InnoDB</code>的一页大小为16k，若一行数据的大小为1k，那么可以存储16行数据</p>\n<p>若主键ID为<code>bigint</code>型，8字节，指针为6字节，总大小为14字节，那么一页可以存储1170个指针</p>\n<p>所以数据量大约为1170  * 1170 *  16&#x3D; 大约两千万</p>\n<h1 id=\"MySQL的锁的类型\"><a href=\"#MySQL的锁的类型\" class=\"headerlink\" title=\"MySQL的锁的类型\"></a>MySQL的锁的类型</h1><h2 id=\"按锁的属性分\"><a href=\"#按锁的属性分\" class=\"headerlink\" title=\"按锁的属性分\"></a>按锁的属性分</h2><p>共享锁：即读锁</p>\n<p>排他锁：即写锁</p>\n<h3 id=\"按锁的粒度分\"><a href=\"#按锁的粒度分\" class=\"headerlink\" title=\"按锁的粒度分\"></a>按锁的粒度分</h3><p>行级锁：锁住一行或者多行记录</p>\n<p>表级锁：给整个表加锁</p>\n<p>页级锁：介于行级锁和表锁的一种锁，一次锁定相邻的一组记录</p>\n<p>记录锁：行级锁的一种，锁住一条记录，避免数据在查询时被修改的不可重复读问题</p>\n<p>间隙锁：行级锁的一种，只出现在Repeatable read的事务中，解决了幻读的问题</p>\n<p>临键锁：<code>InnoDB</code>的行锁默认算法，就是记录锁和间隙锁的结合版，会锁住查询的记录，同时也会锁住范围内的所有间隙空间</p>\n<h3 id=\"按锁的状态分\"><a href=\"#按锁的状态分\" class=\"headerlink\" title=\"按锁的状态分\"></a>按锁的状态分</h3><p>意向共享锁</p>\n<p>意向排他锁</p>\n<h1 id=\"MySQL的主从同步\"><a href=\"#MySQL的主从同步\" class=\"headerlink\" title=\"MySQL的主从同步\"></a>MySQL的主从同步</h1><p>MySQL内建的复制功能是构建大型，高性能应用程序的基础。</p>\n<p>将MySQL的数据分布到多个系统上去，这种分布的机制，是通过将MySQL的某一台主机的数据复制到其它主机（slave）上，并重新执行一遍来实现。</p>\n<p>复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。</p>\n<p>主服务器将更新写入二进制日志文件，并维护文件的一个索引以跟踪日志循坏，这些日志可以记录发送到从服务器的更新。</p>\n<p>当一个从服务器连接主服务器时，它通知主服务器从服务器在日志中读取的最后一次成功更新的位置。从服务器接收从那时起发生的任何更新，然后封锁并等待主服务器通知的更新。</p>\n<h2 id=\"MySQL支持哪些复制\"><a href=\"#MySQL支持哪些复制\" class=\"headerlink\" title=\"MySQL支持哪些复制\"></a>MySQL支持哪些复制</h2><ol>\n<li>基于语句的复制：在主服务器上执行的sql语句，在从服务器上执行同样的语句。mysql默认采用基于语句的复制，效率比较高。一旦发现没法精确复制时，会自动选着基于行的复制。</li>\n<li>基于行的复制：把改变的内容复制过去，而不是把命令在从服务器上执行一遍。从mysql 5.0开始支持</li>\n<li>混合类型的复制：默认采用基于语句的复制，一旦发现基于语句的无法精确复制时，就会采用基于行的复制</li>\n</ol>\n<h2 id=\"为什么需要主从同步\"><a href=\"#为什么需要主从同步\" class=\"headerlink\" title=\"为什么需要主从同步\"></a>为什么需要主从同步</h2><ol>\n<li>若出现锁表不能读的情况，此时可以使用主从复制，让主库负责写，从库负责读，这样就不影响业务的正常运行</li>\n<li>当IO频率越来越大时，业务量越来越大时，单机已无法满足，此时多库的处理可以提高IO的性能</li>\n</ol>\n<h1 id=\"MVCC\"><a href=\"#MVCC\" class=\"headerlink\" title=\"MVCC\"></a>MVCC</h1><p>Multi-Version Concurrency Control多版本并发控制，实现对数据库的并发访问，实现读写冲突不加锁，非阻塞并发读。</p>\n<p>数据库的并发有三种场景</p>\n<ol>\n<li>读读：不存在任何问题，不需要并发控制</li>\n<li>读写：有线程安全问题，可能会造成脏读，幻读，不可重复读等问题</li>\n<li>写写：有线程安全问题，可能存在更新丢失的问题</li>\n</ol>\n<p>MVCC的实现原理就是为事务分配单项增长的时间戳，为每个修改保存一个版本，版本与时间戳相关联，解决了脏读，幻读，不可重复读的问题，但是不能解决更新丢失的问题，可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低</p>\n<h3 id=\"当前读\"><a href=\"#当前读\" class=\"headerlink\" title=\"当前读\"></a>当前读</h3><p>也叫锁定读Locking Read，读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁，比如update 、delete 、insert</p>\n<h3 id=\"快照读\"><a href=\"#快照读\" class=\"headerlink\" title=\"快照读\"></a>快照读</h3><p>也叫普通读Consistent Read，就是单纯的select语句，但不包括for update，就是不加锁的非阻塞读，前提是不使用serializable的隔离级别，实现原理即MVCC</p>\n<h2 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h2><h3 id=\"隐藏字段\"><a href=\"#隐藏字段\" class=\"headerlink\" title=\"隐藏字段\"></a>隐藏字段</h3><p>每行记录除了自定义的字段外，还有数据库隐式定义的字段</p>\n<p>DB_TRX_ID<br>6字节，最近修改事务的ID，即创建这条记录或者最后一次修改这条记录的事务ID</p>\n<p>DB_ROLL_PTR</p>\n<p>7字节，回滚指针，指向这条记录的上一个版本，用于配合undolog</p>\n<p>DB_ROW_ID</p>\n<p>6字节，隐藏的主键，如果数据表没有主键，innoDB就会自动生成一个row_id</p>\n<h3 id=\"undolog\"><a href=\"#undolog\" class=\"headerlink\" title=\"undolog\"></a>undolog</h3><p>即回滚日志，即进行插入，更新，删除操作后生成的记录链</p>\n<p>当进行insert时，产生的undolog只在事务回滚的时候需要，可以在事务提交后被丢弃</p>\n<p>当进行update和delete操作时，undolog不仅在事务回滚时需要，在快照读时也需要，所以必须保留，只有在回滚或者快照读不涉及该日志时，undolog才会被purge线程清除（若delete_bit为true，且DB_TRX_ID相对于purge线程的read view可见，那么这条记录就一定可以被清除）</p>\n<p><img src=\"/../img/undolog.png\" alt=\"undolog\"></p>\n<p>由上图可知，不同事物或者相同事物对同一条记录的修改，就会导致该记录的undolog生成一条记录版本的线性链，链首就是最新的旧记录，链尾就是最早的旧记录</p>\n<h3 id=\"Read-View\"><a href=\"#Read-View\" class=\"headerlink\" title=\"Read View\"></a>Read View</h3><p>Read View是实现repeatable read的基础，当事务进行快照读的时候会产生一个读视图，用来对当前事务的可见性进行判断，也就是说，事务会将生成的ReadView作为条件来判断当前事务能够看见哪个版本的数据，有可能读到最新的数据，也有可能读到undolog里面的某个版本的数据。</p>\n<h4 id=\"ReadView的可见性算法\"><a href=\"#ReadView的可见性算法\" class=\"headerlink\" title=\"ReadView的可见性算法\"></a>ReadView的可见性算法</h4><p>ReadView的三个全局属性：</p>\n<ol>\n<li>trx_list：事务列表，即视图生成时刻系统正活跃未提交的事务ID</li>\n<li>up_limit_id：记录事务列表中ID最小的ID</li>\n<li>low_limit_id：视图生成时刻系统尚未分配的下一个事务（例如事务123正在活跃，事务4已提交，此时下一个事务ID就是5）</li>\n</ol>\n<p>具体的算法如下</p>\n<ol>\n<li>取出当前最新记录的DB_TRX_ID，即当前事务ID</li>\n<li>比较DB_TRX_ID&lt;up_limit_id，如果小于则说明当前事务能看见DB_TRX_ID所在的记录，如果大于等于就进入下一个判断</li>\n<li>判断DB_TRX_ID&gt;&#x3D;low_limit_id，如果大于等于，代表DB_TRX_ID所在的记录在readView生成后才出现，对于当前事务肯定不可见，如果小于，进入下一个判断</li>\n<li>判断DB_TRX_ID是否在活跃事务列表中，如果在，说明在视图生成时刻，该事务还没有提交，当前事务无法看见。若不在，说明以及提交，修改的结果可以看见（除自己以外的活跃trx_id都不可见）</li>\n</ol>\n<h4 id=\"RC，RR级别下的视图\"><a href=\"#RC，RR级别下的视图\" class=\"headerlink\" title=\"RC，RR级别下的视图\"></a>RC，RR级别下的视图</h4><p>在RR级别下某个事务对记录的第一次快照读会创建一个视图，此后在进行快照读时都会使用同一个视图，所以无论是否有其他事务对记录进行了修改，使用的都是这个视图，修改是不可见的，所以实现了可重复读的级别</p>\n<p>在RC级别下，每次快照读都会生成一个新的视图，所以在RC级别下总是可以看见其他事务的提交</p>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><p>MVCC其实就是在事务进行并发读写时提供一个快照，事务只能看见符合可见性的版本链内的记录，从而实现了并发读写的隔离性。RR的隔离级别解决了幻读问题。</p>\n","text":"MySQL关系型数据库，插件式的存储引擎，这种架构可以根据业务的需求和实际需要选择合适的存储引擎。 客户端通过协议与服务器连接，发送查询语句，先检查缓存是否命中，若命中直接返回，否则进行语句解析 预处理，检查语句是否有语法错误，查询优化（是否会使用索引扫描），生成查询计划，启动查...","link":"","photos":[],"count_time":{"symbolsCount":"6.7k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"数据库基础","slug":"数据库基础","count":2,"path":"api/tags/数据库基础.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#MySQL\"><span class=\"toc-text\">MySQL</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%97%E6%AE%B5%E9%80%89%E6%8B%A9%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%88%E7%94%B1%E4%BC%98%E8%87%B3%E5%8A%A3%EF%BC%89\"><span class=\"toc-text\">字段选择优先级（由优至劣）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E5%8A%A1%E7%9A%84ACID\"><span class=\"toc-text\">事务的ACID</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB\"><span class=\"toc-text\">四种隔离级别</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E\"><span class=\"toc-text\">存储引擎</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">索引</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">为什么要有索引</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">索引的原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HASH%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">HASH索引</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#B-%E6%A0%91%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">B+树索引</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#MySQL%E7%9A%84%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">MySQL的锁的类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8C%89%E9%94%81%E7%9A%84%E5%B1%9E%E6%80%A7%E5%88%86\"><span class=\"toc-text\">按锁的属性分</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%89%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6%E5%88%86\"><span class=\"toc-text\">按锁的粒度分</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%89%E9%94%81%E7%9A%84%E7%8A%B6%E6%80%81%E5%88%86\"><span class=\"toc-text\">按锁的状态分</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#MySQL%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">MySQL的主从同步</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#MySQL%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%A4%8D%E5%88%B6\"><span class=\"toc-text\">MySQL支持哪些复制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">为什么需要主从同步</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#MVCC\"><span class=\"toc-text\">MVCC</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BD%93%E5%89%8D%E8%AF%BB\"><span class=\"toc-text\">当前读</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BF%AB%E7%85%A7%E8%AF%BB\"><span class=\"toc-text\">快照读</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">实现原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">隐藏字段</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#undolog\"><span class=\"toc-text\">undolog</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Read-View\"><span class=\"toc-text\">Read View</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ReadView%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">ReadView的可见性算法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#RC%EF%BC%8CRR%E7%BA%A7%E5%88%AB%E4%B8%8B%E7%9A%84%E8%A7%86%E5%9B%BE\"><span class=\"toc-text\">RC，RR级别下的视图</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93%EF%BC%9A\"><span class=\"toc-text\">总结：</span></a></li></ol></li></ol>","author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Spring","uid":"946249c65165e1a3d66f50e0cb6e89e7","slug":"Spring","date":"2022-10-26T13:17:18.000Z","updated":"2022-11-09T08:29:44.585Z","comments":true,"path":"api/articles/Spring.json","keywords":null,"cover":[],"text":"bean的生命周期Bean的创建分为三个基本步骤 实例化：可以理解为new一个对象，AbstractAutowireCapableBeanFactory中的createBeanInstance方法 属性注入：可以理解为setter方法完成属性注入，AbstractAutowire...","link":"","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"JAVA进阶","slug":"JAVA进阶","count":1,"path":"api/tags/JAVA进阶.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"netty——reactor线程模型简述","uid":"0bdbdbbdfc4f649a26dfdf23cf4f1d34","slug":"netty项目记录——react线程模型简述","date":"2022-10-22T09:16:43.000Z","updated":"2022-10-23T09:26:13.439Z","comments":true,"path":"api/articles/netty项目记录——react线程模型简述.json","keywords":null,"cover":[],"text":"BIOBlock IO:同步阻塞IO，一般传统的JDK内置的Socket编程就是BIO。其底层流程是： 创建socket接口，号为x 使用bind函数将接口号与端口号进行绑定 进行listen监听事件或者是read读事件，且会一直阻塞在该命令，直到有客户端连接或者发送数据 缺点：...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"netty高并发项目","slug":"netty高并发项目","count":1,"path":"api/tags/netty高并发项目.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}