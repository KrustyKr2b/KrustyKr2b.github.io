{"title":"线程和协程","uid":"911607c17b916d6cafeabb37f57539b9","slug":"协程","date":"2022-10-20T08:53:01.000Z","updated":"2022-10-21T09:11:49.568Z","comments":true,"path":"api/articles/协程.json","keywords":null,"cover":[],"content":"<h1 id=\"一个程序开多少线程合适\"><a href=\"#一个程序开多少线程合适\" class=\"headerlink\" title=\"一个程序开多少线程合适\"></a>一个程序开多少线程合适</h1><h2 id=\"CPU密集型\"><a href=\"#CPU密集型\" class=\"headerlink\" title=\"CPU密集型\"></a>CPU密集型</h2><p>一个完整的请求，IO操作可以在很短的时间内完成，CPU的运算时间占大部分，线程等待时间接近0</p>\n<ol>\n<li>单核CPU：一个CPU对应一个线程，且IO时间短，所以不适合使用多线程。若使用多线程，会造成线程竞争，造成不必要的浪费</li>\n<li>多核：如果是多核CPU，就可以最大化利用CPU的核心数，使用并发编程来提高效率。理论上的线程数量就等于CPU的核数，但是一般会设置为核数+1，这个额外的线程可以保证线程因为缺页中断或者其他原因暂停而不会导致CPU中断工作</li>\n</ol>\n<h2 id=\"IO密集型\"><a href=\"#IO密集型\" class=\"headerlink\" title=\"IO密集型\"></a>IO密集型</h2><p>一个完整请求，除了CPU的运算操作，还有许多IO操作要做，也就是说，IO操作占很大一部分，等待时间较长。</p>\n<p>理论最佳线程数：CPU核心数 * （1&#x2F;CPU利用率），CPU利用率&#x3D;1+（IO耗时&#x2F;CPU耗时）</p>\n<p>如果几乎全是IO耗时，那么就可以说是2N，但是一般也有一个backup，也就是2N+1</p>\n<h1 id=\"创建线程有哪些方式\"><a href=\"#创建线程有哪些方式\" class=\"headerlink\" title=\"创建线程有哪些方式\"></a>创建线程有哪些方式</h1><p>有四种方式</p>\n<h2 id=\"继承Thread类\"><a href=\"#继承Thread类\" class=\"headerlink\" title=\"继承Thread类\"></a>继承Thread类</h2><ol>\n<li>定义thread类的子类，并重写run方法，该方法的方法体就是线程需要完成的任务，run方法也称为线程执行体。</li>\n<li>创建Thread类的实例，也就是创建了线程对象</li>\n<li>启动线程，即调用线程的start方法</li>\n</ol>\n<h2 id=\"实现Runnable接口\"><a href=\"#实现Runnable接口\" class=\"headerlink\" title=\"实现Runnable接口\"></a>实现Runnable接口</h2><ol>\n<li>定义Runnable接口的实现类，重写run方法，run方法同样是线程执行体</li>\n<li>创建实现类的实例，并用这个实例作为Thread类的target来创建Thread对象，这个Thread对象便是线程对象</li>\n<li>启动线程，调用start方法</li>\n</ol>\n<h2 id=\"使用Callable和future创建\"><a href=\"#使用Callable和future创建\" class=\"headerlink\" title=\"使用Callable和future创建\"></a>使用Callable和future创建</h2><p>future接口是jdk1.5引入的，可以用来接收callable接口里call方法的返回值</p>\n<p>有一个实现类futureTask，实现了future和runnable接口，因此可以作为thread类的target</p>\n<ol>\n<li>创建callable接口的实现类，并实现call方法，然后创建该实现类的实例</li>\n<li>使用futureTask类来包装callable对象</li>\n<li>使用futureTask对象作为thread对象的target创建并启动线程</li>\n<li>使用futureTask对象的get方法来获取子线程执行结束后的返回值</li>\n</ol>\n<p>call方法比run方法更加强大：可以有返回值，可以抛出异常</p>\n<h2 id=\"使用executor框架\"><a href=\"#使用executor框架\" class=\"headerlink\" title=\"使用executor框架\"></a>使用executor框架</h2><p>JDK1.5引入的executor框架最大的优点就是把任务的提交和执行解耦</p>\n<p>开发者只需描述好要只需的任务，然后提交即可</p>\n<ol>\n<li>创建一个executorService</li>\n<li>若有返回值，将写好的runnable实例或者callable实例作为target submit即可，返回值是一个future对象，所以可以使用get方法获取返回值</li>\n<li>若无返回值，直接使用execute方法即可</li>\n</ol>\n<p>executor框架的内部使用了线程池的机制，使用线程池性能更好，节约开销</p>\n<h1 id=\"线程的生命周期\"><a href=\"#线程的生命周期\" class=\"headerlink\" title=\"线程的生命周期\"></a>线程的生命周期</h1><h2 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h2><p>当使用new关键字创建了一个线程之后，该线程就处于一个新建状态，此时它和其他java对象一样，仅仅被分配了内存，并初始化了成员变量值。没有线程的动态特征，也不会执行线程的执行体</p>\n<h2 id=\"就绪\"><a href=\"#就绪\" class=\"headerlink\" title=\"就绪\"></a>就绪</h2><p>当调用start方法后，该线程处于就绪状态。JVM会为其创建虚拟机栈和PC，处于这个状态表示线程可以运行了，等待被调度执行</p>\n<h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><p>在就绪状态下，若被OS调度，就会进入运行状态。当时间片用完或者调用线程让步时，回到就绪状态</p>\n<h2 id=\"阻塞\"><a href=\"#阻塞\" class=\"headerlink\" title=\"阻塞\"></a>阻塞</h2><ol>\n<li>等待阻塞：线程执行wait方法，JVM会将其放入等待池中，此时线程会释放持有的锁</li>\n<li>同步阻塞：即被synchronized修饰的代码块被其他线程拿到，本线程获取同步锁失败，就会被JVM放入锁池中</li>\n<li>其他阻塞：线程执行sleep或者join方法，或者发出了IO请求。当sleep超时，join等待线程终止或者等待超时，IO完毕，线程就会重新转入就绪状态</li>\n</ol>\n<p>sleep：线程睡眠，使线程转入阻塞状态一定时间</p>\n<p>wait：线程等待，使线程放入等待池，指导其他线程调用notify或者notifyall方法来唤醒，此时线程会尝试获取锁，若成功，转为就绪状态，若失败，则进入锁池等待锁的释放。</p>\n<p>yield：线程让步，暂停当前正在执行的线程对象，回到就绪状态，把执行机会让给优先级相同或者更高的线程</p>\n<p>join：线程加入，等待其他线程终止，在当前进程中调用另一个指定进程的join方法，则当前进程转入阻塞状态，直到另一个进程运行结束，当前进程再由阻塞转为就绪状态</p>\n<p>notify：线程唤醒，唤醒被wait阻塞的进程</p>\n<h2 id=\"死亡\"><a href=\"#死亡\" class=\"headerlink\" title=\"死亡\"></a>死亡</h2><ol>\n<li>run方法执行完成，线程正常结束</li>\n<li>抛出异常</li>\n<li>直接调用stop方法来结束（容易造成死锁）</li>\n</ol>\n<p><img src=\"/../img/thread.png\" alt=\"thread\"></p>\n<h1 id=\"协程\"><a href=\"#协程\" class=\"headerlink\" title=\"协程\"></a>协程</h1><p>协程就是轻量级的线程，即在虚拟机的线程栈和PC的基础上再建立更多的栈和PC</p>\n<p>即虚拟机层面的线程，更加轻量级</p>\n<h2 id=\"JVM的普通线程：1-1模型\"><a href=\"#JVM的普通线程：1-1模型\" class=\"headerlink\" title=\"JVM的普通线程：1:1模型\"></a>JVM的普通线程：1:1模型</h2><p>即JVM层面创建一个线程，就会向OS申请一个线程</p>\n<p>优点：简单，省事</p>\n<p>缺点：重量级大，需要在JVM和OS两个层面都创建等待队列，依赖于OS的线程调度器，对线程的操作如上下文切换，阻塞，唤醒等都需要等待OS的反馈，效率偏低。</p>\n<h2 id=\"Fiber：M-N模型（go语言的goroutine）\"><a href=\"#Fiber：M-N模型（go语言的goroutine）\" class=\"headerlink\" title=\"Fiber：M:N模型（go语言的goroutine）\"></a>Fiber：M:N模型（go语言的goroutine）</h2><p>在JVM里创建一个自身的线程调度器来模拟OS，以及实现自身的调度算法，最先由GO语言实现。</p>\n<p>M:N模型：JVM或者GO语言虚拟机里面的协程数会远远大于OS层面的线程</p>\n<p>因为虚拟机层面的协程切换的花销要远远小于OS层面的上下文切换或者调度，所以协程的效率比普通线程更好</p>\n<p>JVM本身不支持协程，使用代理技术：在进入JVM之前，Fiber代码折算为线程代码，再进入JVM</p>\n","feature":true,"text":"一个程序开多少线程合适CPU密集型一个完整的请求，IO操作可以在很短的时间内完成，CPU的运算时间占大部分，线程等待时间接近0 单核CPU：一个CPU对应一个线程，且IO时间短，所以不适合使用多线程。若使用多线程，会造成线程竞争，造成不必要的浪费 多核：如果是多核CPU，就可以最...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"面试突击","slug":"面试突击","count":7,"path":"api/tags/面试突击.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B%E5%90%88%E9%80%82\"><span class=\"toc-text\">一个程序开多少线程合适</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CPU%E5%AF%86%E9%9B%86%E5%9E%8B\"><span class=\"toc-text\">CPU密集型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#IO%E5%AF%86%E9%9B%86%E5%9E%8B\"><span class=\"toc-text\">IO密集型</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">创建线程有哪些方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BFThread%E7%B1%BB\"><span class=\"toc-text\">继承Thread类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">实现Runnable接口</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8Callable%E5%92%8Cfuture%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">使用Callable和future创建</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8executor%E6%A1%86%E6%9E%B6\"><span class=\"toc-text\">使用executor框架</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">线程的生命周期</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">创建</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%B1%E7%BB%AA\"><span class=\"toc-text\">就绪</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%A1%8C\"><span class=\"toc-text\">运行</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%98%BB%E5%A1%9E\"><span class=\"toc-text\">阻塞</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E4%BA%A1\"><span class=\"toc-text\">死亡</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E7%A8%8B\"><span class=\"toc-text\">协程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JVM%E7%9A%84%E6%99%AE%E9%80%9A%E7%BA%BF%E7%A8%8B%EF%BC%9A1-1%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">JVM的普通线程：1:1模型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Fiber%EF%BC%9AM-N%E6%A8%A1%E5%9E%8B%EF%BC%88go%E8%AF%AD%E8%A8%80%E7%9A%84goroutine%EF%BC%89\"><span class=\"toc-text\">Fiber：M:N模型（go语言的goroutine）</span></a></li></ol></li></ol>","author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"netty——reactor线程模型简述","uid":"0bdbdbbdfc4f649a26dfdf23cf4f1d34","slug":"netty项目记录——react线程模型简述","date":"2022-10-22T09:16:43.000Z","updated":"2022-10-23T09:26:13.439Z","comments":true,"path":"api/articles/netty项目记录——react线程模型简述.json","keywords":null,"cover":[],"text":"BIOBlock IO:同步阻塞IO，一般传统的JDK内置的Socket编程就是BIO。其底层流程是： 创建socket接口，号为x 使用bind函数将接口号与端口号进行绑定 进行listen监听事件或者是read读事件，且会一直阻塞在该命令，直到有客户端连接或者发送数据 缺点：...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"netty高并发项目","slug":"netty高并发项目","count":1,"path":"api/tags/netty高并发项目.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"synchronized,volatile与lock","uid":"2b0f61f6bf7b985f1f4587a53651bb18","slug":"synchronized-volatile与lock","date":"2022-10-20T06:09:39.000Z","updated":"2022-10-23T09:25:26.481Z","comments":true,"path":"api/articles/synchronized-volatile与lock.json","keywords":null,"cover":[],"text":"Synchronized同步锁，保证在同一时刻，被修饰的代码块或方法只有一个线程执行，以达到并发安全的效果 同步锁是解决并发问题最简单的一种方法，直接给代码块加上此关键字即可 在JDK1.5之前，Synchronized是一个重量级锁，在以后的版本经过改进后成重量级减小 sync...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"面试突击","slug":"面试突击","count":7,"path":"api/tags/面试突击.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}