{"title":"进程，线程和协程","uid":"a81dd39014b037511fb6ceaf21738564","slug":"协程","date":"2022-10-20T08:53:01.000Z","updated":"2022-11-15T07:12:22.395Z","comments":true,"path":"api/articles/协程.json","keywords":null,"cover":[],"content":"<h1 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h1><p><code>an instance of a computer program that is being executed</code></p>\n<p>进程是程序的一次执行，是一个程序及其数据，运行环境，在处理机上运行时所发生的活动。</p>\n<p>与程序不同的是，进程具有动态性和生命周期，是系统进行资源分配和调度的独立单位。</p>\n<p>进程的结构：</p>\n<ol>\n<li>控制块</li>\n<li>数据段</li>\n<li>程序段</li>\n</ol>\n<h1 id=\"线程的Linux实现\"><a href=\"#线程的Linux实现\" class=\"headerlink\" title=\"线程的Linux实现\"></a>线程的Linux实现</h1><p>而在windows中，线程被抽象为一种比进程更轻量级的可以独立处理事件的单元，支持真线程的系统一定要有线程控制块：TCB，操作系统既要进行进程管理，又要进行线程管理，设计层面是比较复杂的。windows上一定会有相关线程操作的系统调用接口。</p>\n<p>而在Linux中却不一样，从内核的角度来看，并没有线程这个概念，Linux把所有的线程都当作进程来处理，内核也并没有定义独特的调度算法和数据结构来实现线程，线程就是一个与父进程共享资源的进程而已，Linux在创建线程时，会直接创建进程并分配task_struct，同时指定共享资源，所以对于内核来说，它就是进程，线程在Linux中是一个实现进程共享资源的机制。</p>\n<p>在 Linux 中每一个进程都由 task_struct 数据结构来定义。task_struct 就是我们通常所说的 PCB，当我们调用 fork()  时，系统会为我们产生一个 task_struct 结构。然后从父进程，那里继承一些数据，并将PCB插入任务队列中，以待进行进程管理。</p>\n<p>对于线程来说，需要在clone()中指定共享资源</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span>CLONE_VM <span class=\"token operator\">|</span> CLONE_FS <span class=\"token operator\">|</span> CLONE_FILES <span class=\"token operator\">|</span> CLONE_SIGHAND<span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//VM：共享地址空间</span>\n<span class=\"token comment\">//FS：共享文件系统信息</span>\n<span class=\"token comment\">//FILES:共享打开的文件</span>\n<span class=\"token comment\">//SIGHAND：共享阻断信号</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>而一个普通的fork()就是</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span>SIGCHLD<span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"内核线程\"><a href=\"#内核线程\" class=\"headerlink\" title=\"内核线程\"></a>内核线程</h2><p>内核需要经常在后台处理操作，这些任务可以交给内核线程来处理。内核线程就是独立运行在内核空间的标准进程。</p>\n<p>内核线程没有独立的地址空间。其指向地址空间的mm指针设置为null，只存在于内核空间</p>\n<p>task_struct结构中的mm指针：指向进程所拥有的内存描述符</p>\n<p><strong>多线程的优点：并发性提高，占用资源比进程更少。</strong></p>\n<p><strong>多线程缺点：存在大量临界资源，势必会造成各种互斥。编程难度提高，线程的调度和同步需要更多额外的开销。</strong></p>\n<h2 id=\"线程的通信方式\"><a href=\"#线程的通信方式\" class=\"headerlink\" title=\"线程的通信方式\"></a>线程的通信方式</h2><h3 id=\"管道：\"><a href=\"#管道：\" class=\"headerlink\" title=\"管道：\"></a>管道：</h3><p>分为匿名管道和命名管道，实质是一个缓冲区，管道的作用正如其名，需要通信的两个进程在管道的两端，进程利用管道传递信息。管道对于管道两端的进程而言，就是一个文件，但是这个文件比较特殊，它不属于文件系统并且只存在于内存中。</p>\n<h3 id=\"信号signal：\"><a href=\"#信号signal：\" class=\"headerlink\" title=\"信号signal：\"></a>信号signal：</h3><p>信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，进程不必通过任何操作来等待信号的到达。信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件。</p>\n<h3 id=\"信号量Semaphore：\"><a href=\"#信号量Semaphore：\" class=\"headerlink\" title=\"信号量Semaphore：\"></a>信号量Semaphore：</h3><p>信号量实质上就是一个标识可用资源数量的计数器，它的值总是非负整数。而只有0和1两种取值的信号量叫做二进制信号量（或二值信号量），可用用来标识某个资源是否可用。</p>\n<h3 id=\"共享内存\"><a href=\"#共享内存\" class=\"headerlink\" title=\"共享内存:\"></a>共享内存:</h3><p>使得多个进程可以可以直接读写同一块内存空间，是针对其他通信机制运行效率较低而设计的。为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率</p>\n<h3 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列:\"></a>消息队列:</h3><p>消息队列是消息的链表，具有特定的格式,存放在内存中并由消息队列标识符标识，并且允许一个或多个进程向它写入与读取消息</p>\n<h3 id=\"套接字\"><a href=\"#套接字\" class=\"headerlink\" title=\"套接字:\"></a>套接字:</h3><p>不同客户端的进程间的通信方式</p>\n<h1 id=\"用户空间和内核空间\"><a href=\"#用户空间和内核空间\" class=\"headerlink\" title=\"用户空间和内核空间\"></a>用户空间和内核空间</h1><p>操作系统为了支持多个应用同时运行，需要保证不同进程之间相对独立，一个进程的崩溃不会影响其他进程，恶意进程不能读取其他进程的数据。于是内存空间被划分为两部分，<strong>内核空间和用户空间</strong>，内核空间的代码和数据拥有更高的权限，而用户空间的代码不能访问高级别的空间，因此保护了操作系统自身的内存数据。</p>\n<p><strong>用户态</strong>：指进程运行在用户地址空间中的状态，被执行的代码要受到 CPU 的很多检查。进程只能访问地址空间中规定的页面的虚拟地址。</p>\n<p><strong>内核态</strong>：指进程运行在内核地址空间中的状态，此时 CPU 可以执行任何指令。运行的代码也不受任何的限制，可以自由地访问任何有效地址，也可以直接进行端口的访问。所有系统资源的管理都是在内核态去做的，比如创建一个线程需要分配资源，就需要进入内核态，来完成。</p>\n<h2 id=\"什么是进程上下文\"><a href=\"#什么是进程上下文\" class=\"headerlink\" title=\"什么是进程上下文\"></a>什么是进程上下文</h2><p>在Linux中，用户程序装入系统形成一个进程的实质是系统为用户程序提供一个完整的运行环境</p>\n<p>进程的运行环境是由它的程序代码和程序运行所需要的数据结构以及硬件环境组成的，进程的运行环境主要包括：</p>\n<ol>\n<li>进程空间中的代码和数据、各种数据结构、进程堆栈和共享内存区等。</li>\n<li>环境变量：提供进程运行所需的环境信息。</li>\n<li>系统数据：进程空间中的对进程进行管理和控制所需的信息，包括进程任务结构体以及内核堆栈等。</li>\n<li>进程访问设备或者文件时的权限。</li>\n<li>各种硬件寄存器。</li>\n<li>地址转换信息。</li>\n</ol>\n<p>从以上组成情况可以看到，进程的运行环境是动态变化的，尤其是硬件寄存器的值以及进程控制信息是随着进程的运行而不断变化的。在Linux中把系统提供给进程的的处于<strong>动态变化的运行环境总和</strong>称为进程上下文。</p>\n<p>系统中的每一个进程都有自己的上下文。一个正在使用处理器运行的进程称为当前进程(current)。当前进程因时间片用完或者因等待某个事件而阻塞时，进程调度需要把处理器的使用权从当前进程交给另一个进程，这个过程叫做进程切换。</p>\n<p>此时，被调用进程成为当前进程。在进程切换时系统要把当前进程的上下文保存在指定的内存区域（该进程的任务状态段TSS中），然后把下一个使用处理器运行的进程的上下文设置成当前进程的上下文。</p>\n<p>当一个进程经过调度再次使用CPU运行时，系统要恢复该进程保存的上下文。所以，<strong>进程的切换也就是上下文切换</strong>。</p>\n<p>在系统内核为用户进程服务时，通常是进程通过系统调用执行内核代码，此时内核为用户进程服务，可以说内核在代替当前进程执行某种服务。所以可以认为，<strong>内核态就是内核运行在进程上下文中的状态</strong>。</p>\n<p><strong>中断上下文</strong>：硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理。所谓的“中断上下文”，其实也可以看作就是硬<strong>件传递过来的这些参数和内核需要保存的一些其他环境</strong>（主要是当前被打断执行的进程环境）</p>\n<h2 id=\"如何从用户态进入内核态：中断\"><a href=\"#如何从用户态进入内核态：中断\" class=\"headerlink\" title=\"如何从用户态进入内核态：中断\"></a>如何从用户态进入内核态：中断</h2><p>中断是CPU的一个功能：CPU停下工作后，保留现场，自动的转去执行相应的处理程序，CPU的控制权发生改变，处理完该事件后再返回断点继续执行。<strong>避免了CPU的轮询检查</strong>，而是转换为事件驱动，向CPU发送中断事件，强制让CPU来执行中断处理程序。发生中断，CPU会立即进入<strong>内核态</strong>，针对不同的中断信号，采取不同的处理方式。**中断是CPU从用户态进入核心态的唯一途径(如系统调用)**。</p>\n<h3 id=\"硬中断\"><a href=\"#硬中断\" class=\"headerlink\" title=\"硬中断\"></a>硬中断</h3><p>硬中断时由外部事件引起的，具有<strong>随机性和突发性</strong>，比如键盘，鼠标的输入，磁盘的读写，缺页。硬中断的中断号是<strong>由中断控制器提供的</strong>，硬中断是<strong>可以屏蔽</strong>掉的。</p>\n<p>流程如下</p>\n<ol>\n<li><strong>外设</strong> 将中断请求发送给中断控制器；</li>\n<li><strong>中断控制器</strong> 根据中断优先级，有序地将中断号传递给 CPU；</li>\n<li><strong>CPU</strong> 终止执行当前程序流，将 CPU 所有寄存器的数值保存到栈中；</li>\n<li><strong>CPU</strong> 根据中断号，从<strong>中断向量表</strong>中查找中断处理程序的入口地址，执行中断处理程序；</li>\n<li><strong>CPU</strong> 恢复寄存器中的数值，返回原程序流停止位置继续执行。</li>\n</ol>\n<h3 id=\"软中断（被动）\"><a href=\"#软中断（被动）\" class=\"headerlink\" title=\"软中断（被动）\"></a>软中断（被动）</h3><p>CPU的内部事件或者程序引起的中断，如程序故障，电压故障。</p>\n<h3 id=\"软中断（主动）\"><a href=\"#软中断（主动）\" class=\"headerlink\" title=\"软中断（主动）\"></a>软中断（主动）</h3><p>也称作<strong>系统调用</strong>，用户进程<strong>主动要求</strong>进入内核态。用户进程通过系统调用申请操作系统提供服务。</p>\n<p> 系统调用使用的是一个特别的中断实现的。具体是:调用 int $<strong>0x80</strong>的汇编指令，将产生向量为0x80的编程异常（软中断）</p>\n<p>软中断模拟了硬中断的处理过程：</p>\n<ol>\n<li>无</li>\n<li>无</li>\n<li><strong>CPU</strong> 终止执行当前程序流，将 CPU 所有寄存器的数值保存到栈中；</li>\n<li><strong>CPU</strong> 根据中断向量，从中断向量表中查找中断处理程序的入口地址，执行中断处理程序；</li>\n<li><strong>CPU</strong> 恢复寄存器中的数值，返回原程序流停止位置继续执行。</li>\n</ol>\n<h1 id=\"一个程序开多少线程合适\"><a href=\"#一个程序开多少线程合适\" class=\"headerlink\" title=\"一个程序开多少线程合适\"></a>一个程序开多少线程合适</h1><h2 id=\"CPU密集型\"><a href=\"#CPU密集型\" class=\"headerlink\" title=\"CPU密集型\"></a>CPU密集型</h2><p>一个完整的请求，IO操作可以在很短的时间内完成，CPU的运算时间占大部分，线程等待时间接近0</p>\n<ol>\n<li>单核CPU：一个CPU对应一个线程，且IO时间短，所以不适合使用多线程。若使用多线程，会造成线程竞争，造成不必要的浪费</li>\n<li>多核：如果是多核CPU，就可以最大化利用CPU的核心数，使用并发编程来提高效率。理论上的线程数量就等于CPU的核数，但是一般会设置为核数+1，这个额外的线程可以保证线程因为缺页中断或者其他原因暂停而不会导致CPU中断工作</li>\n</ol>\n<h2 id=\"IO密集型\"><a href=\"#IO密集型\" class=\"headerlink\" title=\"IO密集型\"></a>IO密集型</h2><p>一个完整请求，除了CPU的运算操作，还有许多IO操作要做，也就是说，IO操作占很大一部分，等待时间较长。</p>\n<p>理论最佳线程数：CPU核心数 * （1&#x2F;CPU利用率），CPU利用率&#x3D;1+（IO耗时&#x2F;CPU耗时）</p>\n<p>如果几乎全是IO耗时，那么就可以说是2N，但是一般也有一个backup，也就是2N+1</p>\n<h1 id=\"创建线程有哪些方式\"><a href=\"#创建线程有哪些方式\" class=\"headerlink\" title=\"创建线程有哪些方式\"></a>创建线程有哪些方式</h1><p>有四种方式</p>\n<h2 id=\"继承Thread类\"><a href=\"#继承Thread类\" class=\"headerlink\" title=\"继承Thread类\"></a>继承Thread类</h2><ol>\n<li>定义thread类的子类，并重写run方法，该方法的方法体就是线程需要完成的任务，run方法也称为线程执行体。</li>\n<li>创建Thread类的实例，也就是创建了线程对象</li>\n<li>启动线程，即调用线程的start方法</li>\n</ol>\n<h2 id=\"实现Runnable接口\"><a href=\"#实现Runnable接口\" class=\"headerlink\" title=\"实现Runnable接口\"></a>实现Runnable接口</h2><ol>\n<li>定义Runnable接口的实现类，重写run方法，run方法同样是线程执行体</li>\n<li>创建实现类的实例，并用这个实例作为Thread类的target来创建Thread对象，这个Thread对象便是线程对象</li>\n<li>启动线程，调用start方法</li>\n</ol>\n<h2 id=\"使用Callable和future创建\"><a href=\"#使用Callable和future创建\" class=\"headerlink\" title=\"使用Callable和future创建\"></a>使用Callable和future创建</h2><p>future接口是jdk1.5引入的，可以用来接收callable接口里call方法的返回值</p>\n<p>有一个实现类futureTask，实现了future和runnable接口，因此可以作为thread类的target</p>\n<ol>\n<li>创建callable接口的实现类，并实现call方法，然后创建该实现类的实例</li>\n<li>使用futureTask类来包装callable对象</li>\n<li>使用futureTask对象作为thread对象的target创建并启动线程</li>\n<li>使用futureTask对象的get方法来获取子线程执行结束后的返回值</li>\n</ol>\n<p>call方法比run方法更加强大：可以有返回值，可以抛出异常</p>\n<h2 id=\"使用executor框架\"><a href=\"#使用executor框架\" class=\"headerlink\" title=\"使用executor框架\"></a>使用executor框架</h2><p>JDK1.5引入的executor框架最大的优点就是把任务的提交和执行解耦</p>\n<p>开发者只需描述好要只需的任务，然后提交即可</p>\n<ol>\n<li>创建一个executorService</li>\n<li>若有返回值，将写好的runnable实例或者callable实例作为target submit即可，返回值是一个future对象，所以可以使用get方法获取返回值</li>\n<li>若无返回值，直接使用execute方法即可</li>\n</ol>\n<p>executor框架的内部使用了线程池的机制，使用线程池性能更好，节约开销</p>\n<h1 id=\"线程的生命周期\"><a href=\"#线程的生命周期\" class=\"headerlink\" title=\"线程的生命周期\"></a>线程的生命周期</h1><h2 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h2><p>当使用new关键字创建了一个线程之后，该线程就处于一个新建状态，此时它和其他java对象一样，仅仅被分配了内存，并初始化了成员变量值。没有线程的动态特征，也不会执行线程的执行体</p>\n<h2 id=\"就绪\"><a href=\"#就绪\" class=\"headerlink\" title=\"就绪\"></a>就绪</h2><p>当调用start方法后，该线程处于就绪状态。JVM会为其创建虚拟机栈和PC，处于这个状态表示线程可以运行了，等待被调度执行</p>\n<h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><p>在就绪状态下，若被OS调度，就会进入运行状态。当时间片用完或者调用线程让步时，回到就绪状态</p>\n<h2 id=\"阻塞\"><a href=\"#阻塞\" class=\"headerlink\" title=\"阻塞\"></a>阻塞</h2><ol>\n<li>等待阻塞：线程执行wait方法，JVM会将其放入等待池中，此时线程会释放持有的锁</li>\n<li>同步阻塞：即被synchronized修饰的代码块被其他线程拿到，本线程获取同步锁失败，就会被JVM放入锁池中</li>\n<li>其他阻塞：线程执行sleep或者join方法，或者发出了IO请求。当sleep超时，join等待线程终止或者等待超时，IO完毕，线程就会重新转入就绪状态</li>\n</ol>\n<p>sleep：线程睡眠，使线程转入阻塞状态一定时间</p>\n<p>wait：线程等待，使线程放入等待池，指导其他线程调用notify或者notifyall方法来唤醒，此时线程会尝试获取锁，若成功，转为就绪状态，若失败，则进入锁池等待锁的释放。</p>\n<p>yield：线程让步，暂停当前正在执行的线程对象，回到就绪状态，把执行机会让给优先级相同或者更高的线程</p>\n<p>join：线程加入，等待其他线程终止，在当前进程中调用另一个指定进程的join方法，则当前进程转入阻塞状态，直到另一个进程运行结束，当前进程再由阻塞转为就绪状态</p>\n<p>notify：线程唤醒，唤醒被wait阻塞的进程</p>\n<h2 id=\"死亡\"><a href=\"#死亡\" class=\"headerlink\" title=\"死亡\"></a>死亡</h2><ol>\n<li>run方法执行完成，线程正常结束</li>\n<li>抛出异常</li>\n<li>直接调用stop方法来结束（容易造成死锁）</li>\n</ol>\n<p><img src=\"/../img/thread.png\" alt=\"thread\"></p>\n<h1 id=\"协程\"><a href=\"#协程\" class=\"headerlink\" title=\"协程\"></a>协程</h1><p>协程就是轻量级的线程，即在虚拟机的线程栈和PC的基础上再建立更多的栈和PC</p>\n<p>即虚拟机层面的线程，更加轻量级</p>\n<h2 id=\"JVM的普通线程：1-1模型\"><a href=\"#JVM的普通线程：1-1模型\" class=\"headerlink\" title=\"JVM的普通线程：1:1模型\"></a>JVM的普通线程：1:1模型</h2><p>即JVM层面创建一个线程，就会向OS申请一个线程</p>\n<p>优点：简单，省事</p>\n<p>缺点：重量级大，需要在JVM和OS两个层面都创建等待队列，依赖于OS的线程调度器，对线程的操作如上下文切换，阻塞，唤醒等都需要等待OS的反馈，效率偏低。</p>\n<h2 id=\"Fiber纤程：M-N模型（go语言的goroutine）\"><a href=\"#Fiber纤程：M-N模型（go语言的goroutine）\" class=\"headerlink\" title=\"Fiber纤程：M:N模型（go语言的goroutine）\"></a>Fiber纤程：M:N模型（go语言的goroutine）</h2><p>在JVM里创建一个自身的线程调度器来模拟OS，以及实现自身的调度算法，最先由GO语言实现。</p>\n<p>M:N模型：JVM或者GO语言虚拟机里面的协程数会远远大于OS层面的线程</p>\n<p>因为虚拟机层面的协程切换的花销要远远小于OS层面的上下文切换或者调度，所以协程的效率比普通线程更好</p>\n<p>JVM本身不支持协程，使用代理技术：在进入JVM之前，Fiber代码折算为线程代码，再进入JVM</p>\n<h1 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h1><p>即线程本地变量，使公共变量可以在多个线程内进行隔离访问</p>\n<p><code>static ThreadLocal&lt;Object&gt; TL = new ThreadLocal&lt;&gt;();</code></p>\n<p>若线程1对TL设置内容Value1，此时线程2是无法通过get方法拿到Value1的</p>\n<h3 id=\"常用方法及实现原理\"><a href=\"#常用方法及实现原理\" class=\"headerlink\" title=\"常用方法及实现原理\"></a>常用方法及实现原理</h3><p>set (T value)：设置线程本地变量的内容</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">T</span> value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 获取当前线程</span>\n    <span class=\"token class-name\">Thread</span> t <span class=\"token operator\">=</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 获取当前线程的threadLocals字段</span>\n    <span class=\"token class-name\">ThreadLocalMap</span> map <span class=\"token operator\">=</span> <span class=\"token function\">getMap</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 判断线程的threadLocals是否初始化了</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>map <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//this就是公共变量TL</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// 没有则创建一个ThreadLocalMap对象进行初始化</span>\n        <span class=\"token function\">createMap</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>每一个thread对象里都会自带一个threadLocals对象，而这个对象就是ThreadLocalMap的实例</p>\n<p>ThreadLocalMap就是一个存储Entry即键值对的数组，初始化时threadLocals会设置为null</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">ThreadLocal<span class=\"token punctuation\">.</span>ThreadLocalMap</span> threadLocals <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><strong>所以set方法并不是往tl对象里面装内容，而是以tl的引用为K，value为V，生成Entry装入该线程的map中</strong></p>\n<p>get()：获取线程本地变量的内容</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">T</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">Thread</span> t <span class=\"token operator\">=</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">ThreadLocalMap</span> map <span class=\"token operator\">=</span> <span class=\"token function\">getMap</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>map <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// 获取ThreadLocal对应保留在Map中的Entry对象</span>\n        <span class=\"token class-name\">ThreadLocalMap<span class=\"token punctuation\">.</span>Entry</span> e <span class=\"token operator\">=</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">getEntry</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token annotation punctuation\">@SuppressWarnings</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"unchecked\"</span><span class=\"token punctuation\">)</span>\n            <span class=\"token comment\">// 获取ThreadLocal对象对应的值</span>\n            <span class=\"token class-name\">T</span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">)</span>e<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token comment\">// map还没有初始化时创建map对象，并设置null，同时返回null</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">setInitialValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"/../img/ThreadLocal.png\" alt=\"ThreadLocal\"></p>\n<p>Entry继承了弱引用类，说明这里的每一个Entry都是一个弱引用，弱引用的使用可以避免内存泄漏</p>\n<p><img src=\"/../img/threadLocal1.png\" alt=\"threadLocal1\"></p>\n<p><img src=\"/../img/ThreadLocal2.png\" alt=\"ThreadLocal2\"></p>\n<p>ThreadLocal对象的作用：</p>\n<ol>\n<li>引用作为key来进行查找entry的值</li>\n<li>维护map，ThreadLocalMap的设置删除都是由ThreadLocal来进行的</li>\n</ol>\n<p>在ThreadLocalMap的set&#x2F;getEntry中，会对key进行判断，<strong>如果key为null，那么value也会被设置为null</strong>，这样即使在忘记调用了remove方法，当ThreadLocal被销毁时，对应value的内容也会被清空，避免了内存泄漏。</p>\n<h3 id=\"为什么ThreadLocal包装的变量可以实现线程隔离？\"><a href=\"#为什么ThreadLocal包装的变量可以实现线程隔离？\" class=\"headerlink\" title=\"为什么ThreadLocal包装的变量可以实现线程隔离？\"></a>为什么ThreadLocal包装的变量可以实现线程隔离？</h3><p>thread对象内不方便手动添加成员变量，所以就使用ThreadLocal来实现成员变量的效果。ThreadLocal对象本身不存储值，而是作为一个key来查找不同线程中的map的value，不同线程<strong>以ThreadLocal的弱引用作为key的Entry里的Value肯定都是不同的</strong>，每一个线程内的map都保存了一份副本各玩儿各的，所以就实现了线程隔离。</p>\n<h2 id=\"ThreadLocal的应用场景\"><a href=\"#ThreadLocal的应用场景\" class=\"headerlink\" title=\"ThreadLocal的应用场景\"></a>ThreadLocal的应用场景</h2><ol>\n<li>Spring的@Transaction事务声明的注解中就使用ThreadLocal保存了当前的Connection对象，避免在本次调用的不同方法中使用不同的Connection对象。</li>\n<li>依赖于ThreadLocal本身的特性，对于需要进行线程隔离的变量可以使用ThreadLocal进行封装</li>\n</ol>\n","text":"进程an instance of a computer program that is being executed 进程是程序的一次执行，是一个程序及其数据，运行环境，在处理机上运行时所发生的活动。 与程序不同的是，进程具有动态性和生命周期，是系统进行资源分配和调度的独立单位。...","link":"","photos":[],"count_time":{"symbolsCount":"7.6k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":9,"path":"api/tags/Java基础知识.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B\"><span class=\"toc-text\">进程</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84Linux%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">线程的Linux实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">内核线程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">线程的通信方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%A1%E9%81%93%EF%BC%9A\"><span class=\"toc-text\">管道：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BF%A1%E5%8F%B7signal%EF%BC%9A\"><span class=\"toc-text\">信号signal：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BF%A1%E5%8F%B7%E9%87%8FSemaphore%EF%BC%9A\"><span class=\"toc-text\">信号量Semaphore：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98\"><span class=\"toc-text\">共享内存:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97\"><span class=\"toc-text\">消息队列:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A5%97%E6%8E%A5%E5%AD%97\"><span class=\"toc-text\">套接字:</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%92%8C%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4\"><span class=\"toc-text\">用户空间和内核空间</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87\"><span class=\"toc-text\">什么是进程上下文</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E4%BB%8E%E7%94%A8%E6%88%B7%E6%80%81%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E6%80%81%EF%BC%9A%E4%B8%AD%E6%96%AD\"><span class=\"toc-text\">如何从用户态进入内核态：中断</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A1%AC%E4%B8%AD%E6%96%AD\"><span class=\"toc-text\">硬中断</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BD%AF%E4%B8%AD%E6%96%AD%EF%BC%88%E8%A2%AB%E5%8A%A8%EF%BC%89\"><span class=\"toc-text\">软中断（被动）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BD%AF%E4%B8%AD%E6%96%AD%EF%BC%88%E4%B8%BB%E5%8A%A8%EF%BC%89\"><span class=\"toc-text\">软中断（主动）</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B%E5%90%88%E9%80%82\"><span class=\"toc-text\">一个程序开多少线程合适</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CPU%E5%AF%86%E9%9B%86%E5%9E%8B\"><span class=\"toc-text\">CPU密集型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#IO%E5%AF%86%E9%9B%86%E5%9E%8B\"><span class=\"toc-text\">IO密集型</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">创建线程有哪些方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BFThread%E7%B1%BB\"><span class=\"toc-text\">继承Thread类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">实现Runnable接口</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8Callable%E5%92%8Cfuture%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">使用Callable和future创建</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8executor%E6%A1%86%E6%9E%B6\"><span class=\"toc-text\">使用executor框架</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">线程的生命周期</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">创建</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%B1%E7%BB%AA\"><span class=\"toc-text\">就绪</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%A1%8C\"><span class=\"toc-text\">运行</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%98%BB%E5%A1%9E\"><span class=\"toc-text\">阻塞</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E4%BA%A1\"><span class=\"toc-text\">死亡</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E7%A8%8B\"><span class=\"toc-text\">协程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JVM%E7%9A%84%E6%99%AE%E9%80%9A%E7%BA%BF%E7%A8%8B%EF%BC%9A1-1%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">JVM的普通线程：1:1模型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Fiber%E7%BA%A4%E7%A8%8B%EF%BC%9AM-N%E6%A8%A1%E5%9E%8B%EF%BC%88go%E8%AF%AD%E8%A8%80%E7%9A%84goroutine%EF%BC%89\"><span class=\"toc-text\">Fiber纤程：M:N模型（go语言的goroutine）</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ThreadLocal\"><span class=\"toc-text\">ThreadLocal</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">常用方法及实现原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88ThreadLocal%E5%8C%85%E8%A3%85%E7%9A%84%E5%8F%98%E9%87%8F%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB%EF%BC%9F\"><span class=\"toc-text\">为什么ThreadLocal包装的变量可以实现线程隔离？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ThreadLocal%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">ThreadLocal的应用场景</span></a></li></ol></li></ol>","author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"netty基础知识","uid":"4fe89795a63627b54cad79ec28758dc1","slug":"netty基础知识","date":"2022-10-22T08:35:26.000Z","updated":"2022-11-15T08:39:49.211Z","comments":true,"path":"api/articles/netty基础知识.json","keywords":null,"cover":[],"text":"Netty和Tomcat有什么区别？Netty是一个基于NIO的异步网络通信框架，性能高，封装了原生NIO，降低了编码复杂度。 Tomcat是一个Web服务器，是一个Servlet容器，内部只运行Servlet程序并处理HTTP请求。 Netty封装的是IO模型，用于处理网络数据...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"netty","slug":"netty","count":2,"path":"api/tags/netty.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"synchronized,volatile与lock","uid":"2b0f61f6bf7b985f1f4587a53651bb18","slug":"synchronized-volatile与lock","date":"2022-10-20T06:09:39.000Z","updated":"2022-10-31T06:16:33.398Z","comments":true,"path":"api/articles/synchronized-volatile与lock.json","keywords":null,"cover":[],"text":"Synchronized同步锁，保证在同一时刻，被修饰的代码块或方法只有一个线程执行，以达到并发安全的效果 同步锁是解决并发问题最简单的一种方法，直接给代码块加上此关键字即可 在JDK1.5之前，Synchronized是一个重量级锁，在以后的版本经过改进后成重量级减小 sync...","link":"","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":9,"path":"api/tags/Java基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}