{"title":"线程池","uid":"d1863bbf8aa3ec7bc32e4a0f3476163f","slug":"线程池","date":"2022-10-18T12:33:43.000Z","updated":"2022-10-20T09:20:51.227Z","comments":true,"path":"api/articles/线程池.json","keywords":null,"cover":null,"content":"<h1 id=\"何为线程池：\"><a href=\"#何为线程池：\" class=\"headerlink\" title=\"何为线程池：\"></a>何为线程池：</h1><p>一种多线程的处理形式，处理过程中可以将任务添加到队列中，然后在创建线程后自动启动这些任务。</p>\n<h3 id=\"线程池的优势：\"><a href=\"#线程池的优势：\" class=\"headerlink\" title=\"线程池的优势：\"></a>线程池的优势：</h3><ol>\n<li>线程和任务分离，线程可被重用，提升复用性</li>\n<li>控制线程并发数量，统一管理，降低服务器压力</li>\n<li>提升系统响应速度，因为线程池内的线程可以被复用，且线程池内有核心线程待命，所以就减少了创建线程和销毁线程的时间。</li>\n</ol>\n<h3 id=\"应用场景：\"><a href=\"#应用场景：\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><p>网购商品秒杀，云盘文件上传，旅行系统购票等等</p>\n<h3 id=\"为什么要使用线程池\"><a href=\"#为什么要使用线程池\" class=\"headerlink\" title=\"为什么要使用线程池\"></a>为什么要使用线程池</h3><p>JAVA线程的创建十分昂贵，需要JVM和OS配合完成大量的工作</p>\n<ol>\n<li>必须为线程堆栈分配和初始化大量的内存块，其中至少包含1MB的栈内存</li>\n<li>JVM的线程模型为1:1模型，即JVM的线程和OS的线程是1:1对应的，需要进行系统调用，以便在OS中创建和注册本地线程</li>\n</ol>\n<p>Java的高并发应用频繁创建和销毁线程的操作是十分低效的，且不符合编程规范的，所以需要使用线程池来独立负责线程的创建维护和分配，以提升性能，减少资源消耗。</p>\n<h1 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h1><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//构造方法:</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> corePoolSize<span class=\"token punctuation\">,</span> <span class=\"token comment\">//核心线程数量</span>\n                              <span class=\"token keyword\">int</span> maximumPoolSize<span class=\"token punctuation\">,</span><span class=\"token comment\">//     最大线程数</span>\n                              <span class=\"token keyword\">long</span> keepAliveTime<span class=\"token punctuation\">,</span> <span class=\"token comment\">//       最大空闲时间</span>\n                              <span class=\"token class-name\">TimeUnit</span> unit<span class=\"token punctuation\">,</span>         <span class=\"token comment\">//        时间单位</span>\n                              <span class=\"token class-name\">BlockingQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">></span></span> workQueue<span class=\"token punctuation\">,</span>   <span class=\"token comment\">//   任务队列</span>\n                              <span class=\"token class-name\">ThreadFactory</span> threadFactory<span class=\"token punctuation\">,</span>    <span class=\"token comment\">// 线程工厂</span>\n                              <span class=\"token class-name\">RejectedExecutionHandler</span> handler  <span class=\"token comment\">//  饱和处理机制</span>\n\t<span class=\"token punctuation\">)</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>参数解释：</p>\n<ol>\n<li>corePoolSize : 指空闲也不允许被销毁的线程，随时待命存放于线程池中</li>\n<li>maximumPoolSize：指最大线程数，当任务队列满时，需要创建临时进程处理无法进入任务队列的任务。当临时进程空闲时，会被销毁</li>\n<li>keepAliveTime&amp;TimeUnit：最大空闲时间和时间单位，当临时进程空闲时间超过最大空闲时间后，便会被销毁</li>\n<li>BlockingQueue：任务队列，当核心线程均不空闲时，任务进入队列等待。队列就是一种容器，可以用多种数据结构实现，常见的有ConcurrentMap,PriorityQueue,ArrayBlockingQueue等等。永远推荐使用有界队列，即由数组实现的队列，并设立合理的长度。避免造成等待任务过多消耗系统资源。</li>\n<li>ThreadFactory ：线程工厂，手动命名创建线程的工厂，方便抛出错误后定位相应线程池</li>\n<li>RejectedExecutionHandler：拒绝策略，当任务队列满且所有线程均不空闲时，启用饱和处理机制</li>\n</ol>\n<h2 id=\"如何确定核心线程数，最大线程数，任务队列长度\"><a href=\"#如何确定核心线程数，最大线程数，任务队列长度\" class=\"headerlink\" title=\"如何确定核心线程数，最大线程数，任务队列长度\"></a>如何确定核心线程数，最大线程数，任务队列长度</h2><p>核心线程数：IO密集型：CPU数*2；CPU密集型：CPU数+1</p>\n<p>最大线程数：(每秒产生的最大任务数-任务队列长度)*单个任务执行时间</p>\n<p>任务队列长度：核心线程数&#x2F;单个任务执行时间*2</p>\n<h2 id=\"饱和处理机制有哪些\"><a href=\"#饱和处理机制有哪些\" class=\"headerlink\" title=\"饱和处理机制有哪些\"></a>饱和处理机制有哪些</h2><ol>\n<li>AbortPolicy：丢弃任务并抛出异常</li>\n<li>DiscardPolicy：丢弃任务不抛出异常</li>\n<li>DiscardOldestPolicy：丢弃最前面的任务，然后重新提交被拒绝的任务</li>\n<li>CallerRunsPolicy：直接调用线程处理该任务</li>\n</ol>\n","text":"何为线程池：一种多线程的处理形式，处理过程中可以将任务添加到队列中，然后在创建线程后自动启动这些任务。 线程池的优势： 线程和任务分离，线程可被重用，提升复用性 控制线程并发数量，统一管理，降低服务器压力 提升系统响应速度，因为线程池内的线程可以被复用，且线程池内有核心线程待命，...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"面试突击","slug":"面试突击","count":7,"path":"api/tags/面试突击.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BD%95%E4%B8%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9A\"><span class=\"toc-text\">何为线程池：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BC%98%E5%8A%BF%EF%BC%9A\"><span class=\"toc-text\">线程池的优势：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A\"><span class=\"toc-text\">应用场景：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0\"><span class=\"toc-text\">为什么要使用线程池</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0%EF%BC%8C%E6%9C%80%E5%A4%A7%E7%BA%BF%E7%A8%8B%E6%95%B0%EF%BC%8C%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E9%95%BF%E5%BA%A6\"><span class=\"toc-text\">如何确定核心线程数，最大线程数，任务队列长度</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A5%B1%E5%92%8C%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">饱和处理机制有哪些</span></a></li></ol></li></ol>","author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"字典序问题","uid":"db91e78c8da8e89de1c0960e4a35ed33","slug":"字典序问题","date":"2022-10-19T05:30:33.000Z","updated":"2022-10-19T06:21:05.815Z","comments":true,"path":"api/articles/字典序问题.json","keywords":null,"cover":null,"text":"给你一个整数 n ，按字典序返回范围 [1, n] 内所有整数。 你必须设计一个时间复杂度为 O(n) 且使用 O(1) 额外空间的算法。 示例 1： 输入：n &#x3D; 13 输出：[1,10,11,12,13,2,3,4,5,6,7,8,9] 思路：字典序的构建可以看成是...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"LeetCode初见","slug":"LeetCode初见","count":7,"path":"api/tags/LeetCode初见.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"每日一问10/17/2022","uid":"626084d3a58b4f97f22000ce81567720","slug":"每日一问10-17-2022","date":"2022-10-17T13:16:32.000Z","updated":"2022-10-18T14:02:21.366Z","comments":true,"path":"api/articles/每日一问10-17-2022.json","keywords":null,"cover":[],"text":"Q1:String,StringBuilder,StringBuffer的区别答： String的底层是一个由final修饰的char型数组，String是静态只读的，当改变变量的值时，其实只是改变了引用对象的指向，指向了新创建的字符串，而原字符串仍存在于字符串常量池。 Stri...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"面试突击","slug":"面试突击","count":7,"path":"api/tags/面试突击.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}