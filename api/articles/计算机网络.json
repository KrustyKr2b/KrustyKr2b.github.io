{"title":"计算机网络","uid":"293c17b4d2a4292133cc4d1ffd7f8725","slug":"计算机网络","date":"2022-10-31T06:51:13.000Z","updated":"2022-11-03T12:25:09.918Z","comments":true,"path":"api/articles/计算机网络.json","keywords":null,"cover":[],"content":"<h1 id=\"计算机网络的分层模型\"><a href=\"#计算机网络的分层模型\" class=\"headerlink\" title=\"计算机网络的分层模型\"></a>计算机网络的分层模型</h1><h3 id=\"OSI七层模型\"><a href=\"#OSI七层模型\" class=\"headerlink\" title=\"OSI七层模型\"></a>OSI七层模型</h3><ol>\n<li>应用层：计算机上的网络应用，传输应用报文，如HTTP，SMTP</li>\n<li>表示层：用于处理交换信息的表示格式（处理语法和处理语义），格式变换，数据加密解密，数据压缩等功能</li>\n<li>会话层：向表示层建立连接，并传输有序的数据，也就是建立同步SYN</li>\n<li>运输层：负责两个进程的通信，即端到端，如TCP UDP</li>\n<li>网络层：讲分组从源端传到目的端，注重传输过程中的路径选择，如IP</li>\n<li>链路层：讲网络层的数据包封装成帧，如CSMA</li>\n<li>物理层：以比特流的方式传输</li>\n</ol>\n<p>上面4层是端到端的，也就是关注的是数据从源主机交付到目的主机，而不管每步是怎么传输的</p>\n<p>下面3层是点到点的，关注数据在传输过程中下一步是怎么走的，也就是路由是如何转发的</p>\n<h3 id=\"TCP-x2F-IP四层模型\"><a href=\"#TCP-x2F-IP四层模型\" class=\"headerlink\" title=\"TCP&#x2F;IP四层模型\"></a>TCP&#x2F;IP四层模型</h3><ol>\n<li>应用层（应用层+表示层+会话层）</li>\n<li>运输层</li>\n<li>网络层</li>\n<li>网络接口层（物理层+链路层）</li>\n</ol>\n<h3 id=\"五层参考模型\"><a href=\"#五层参考模型\" class=\"headerlink\" title=\"五层参考模型\"></a>五层参考模型</h3><ol>\n<li>应用层</li>\n<li>运输层 </li>\n<li>网络层</li>\n<li>链路层</li>\n<li>物理层</li>\n</ol>\n<h1 id=\"运输层协议\"><a href=\"#运输层协议\" class=\"headerlink\" title=\"运输层协议\"></a>运输层协议</h1><h2 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h2><p>特点</p>\n<ol>\n<li>无连接状态：UDP无需任何准备就可以传输数据，也没有引入建立连接的时延。并且UDP也不维护连接状态</li>\n<li>精确控制发送数据的时机：应用程序将数据传给UDP，UDP可以立即将数据封装为UDP报文并传递给网络层，而TCP引入了拥塞机制来控制发送方的频率。</li>\n</ol>\n<p>报文结构：</p>\n<p>UDP首部仅四个部分</p>\n<ol>\n<li>源端口号：2字节</li>\n<li>目的端口号：2字节</li>\n<li>长度：2字节</li>\n<li>校验和：2字节</li>\n</ol>\n<p>UDP的校验和：应用数据的所有16比特字之和的反码</p>\n<h2 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h2><p>特点</p>\n<ol>\n<li>保证发送有效，有序的字节流，是面向流的协议，基于TCP:HTTP</li>\n<li>首部20字节</li>\n</ol>\n<p><strong>TCP首部的标志字段</strong></p>\n<ol>\n<li>URG&#x3D;1 表明紧急指针字段有效，表示有紧急数据，应该尽快传输</li>\n<li>ACK&#x3D;1 表明确认字段有效</li>\n<li>PSH&#x3D;1 表示接收方此时应该尽快交付缓冲区的数据</li>\n<li>RST&#x3D;1 表示TCP连接出现严重错误，必须释放连接，再重新建立连接</li>\n<li><strong>SYN</strong>&#x3D;1 表示这是一个连接请求或者连接接受报文</li>\n<li>FIN&#x3D;1 表示此段数据的发送端已经发送完毕最后一个数据段，并要求释放连接</li>\n</ol>\n<h4 id=\"TCP的连接管理\"><a href=\"#TCP的连接管理\" class=\"headerlink\" title=\"TCP的连接管理\"></a>TCP的连接管理</h4><p><strong>三次握手：</strong></p>\n<ol>\n<li>开始处于CLOSED，客户机向服务器发送TCP SYN报文段，使用seq指定初始序号，这个请求报文是没有数据的，客户机进入SYN_SENT</li>\n<li>服务器收到客户机的SYN报文段，使用带ACK的SYN报文段来回复，为该连接分配缓冲区和相关变量，使用seq指定相关序号</li>\n<li>客户机接到服务器的SYN报文段，客户机为连接分配缓冲，使用ACK报文段回复（SYN&#x3D;0），可能会有数据，客户机进入ESTABLISHED</li>\n</ol>\n<p>SYN ：<em>Syn</em>chronize Sequence Numbers 即握手信号</p>\n<p>为什么需要三次：第二步服务器向客户机提供了自己的初始序号，因此再需要一次握手来确认此序号</p>\n<p><strong>四次挥手：</strong></p>\n<ol>\n<li>客户机发送TCP FIN报文段到服务器，进入FIN_WAIT_1</li>\n<li>服务器收到FIN，回复ACK，进入FIN_WAIT_2</li>\n<li>服务器发送FIN报文给客户机，此时连接半关闭，</li>\n<li>客户机接收FIN，回复ACK报文，进入TIME_WAIT，时间结束后，释放资源，服务器收到后连接关闭</li>\n</ol>\n<h2 id=\"TCP的有限状态机\"><a href=\"#TCP的有限状态机\" class=\"headerlink\" title=\"TCP的有限状态机\"></a>TCP的有限状态机</h2><p><img src=\"/../img/TCPFSM.png\" alt=\"TCPFSM\"></p>\n<p><img src=\"/../img/TCPFSM1.png\" alt=\"TCPFSM1\"></p>\n<ol>\n<li>CLOSED 没有任何连接状态</li>\n<li>LISTEN 侦听状态，等待来自远方TCP端口的连接请求 </li>\n<li>SYN-SENT 在发送连接请求后，等待对方确认 </li>\n<li>SYN-RECEIVED 在收到和发送一个连接请求后，等待对方确认 </li>\n<li>ESTABLISHED 代表传输连接建立，双方进入数据传送状态 </li>\n<li>FIN-WAIT-1 主动关闭,主机已发送关闭连接请求，等待对方确认 </li>\n<li>FIN-WAIT-2 主动关闭,主机已收到对方关闭传输连接确认，等待对方发送关闭传输连接请求 </li>\n<li>TIME-WAIT 完成双向传输连接关闭，等待所有分组消失 </li>\n<li>CLOSE-WAIT 被动关闭,收到对方发来的关闭连接请求，并已确认 </li>\n<li>LAST-ACK 被动关闭,等待最后一个关闭传输连接确认，并等待所有分组消失</li>\n<li>CLOSING 如果通信双方同时发送FIN数据包，则同时进行关闭操作，则双方将同时进入TCP_CLOSING状态。 \t具体的，本地发送一个FIN数据包以结束本地数据包发送，如果在等待应答期间，接收到远端发送的FIN数据包，则本地将状态设置为TCP_CLOSING状态。 \t在接收到应答后，再继续装入到TCP_CLOSE_WAIT状态。</li>\n</ol>\n<h3 id=\"TCP的拥塞控制\"><a href=\"#TCP的拥塞控制\" class=\"headerlink\" title=\"TCP的拥塞控制\"></a>TCP的拥塞控制</h3><ol>\n<li><strong>当cwnd &lt; ssthresh时，慢启动，指数增长</strong></li>\n<li><strong>当cwnd &gt; ssthresh时，拥塞避免，线性增长</strong></li>\n<li><strong>出现三个冗余确认，快速恢复，ssthresh &#x3D; cwnd&#x2F;2 ; cwnd &#x3D; ssthresh+3*MSS；此后每收到一个冗余ACK就增加一个MSS，直到收到正确的ACK，cwnd&#x3D;ssthresh,进入慢增长</strong></li>\n<li><strong>出现timeout，ssthresh &#x3D; cwnd&#x2F;2 ; cwnd &#x3D; 1MSS</strong></li>\n</ol>\n<h2 id=\"TCP可靠传输机制的保证：\"><a href=\"#TCP可靠传输机制的保证：\" class=\"headerlink\" title=\"TCP可靠传输机制的保证：\"></a>TCP可靠传输机制的保证：</h2><ol>\n<li><p>检验和：用于检验一个分组中的比特错误</p>\n</li>\n<li><p>定时器：用于超时检验，发生超时事件时重传</p>\n</li>\n<li><p>序号：为一系列分组编号，可以检测出丢失分组以及冗余分组</p>\n</li>\n<li><p>ACK：用于告诉发送方分组被正确接收</p>\n</li>\n<li><p>NAK：用于告诉发送方分组未被正确接收</p>\n</li>\n<li><p>窗口：发送方被限制发送的序号范围</p>\n</li>\n</ol>\n<h4 id=\"GBN-回退N步-go-back-N\"><a href=\"#GBN-回退N步-go-back-N\" class=\"headerlink\" title=\"GBN 回退N步 go-back-N\"></a>GBN 回退N步 go-back-N</h4><p>将序号队列分为四部分</p>\n<ol>\n<li>已被确认</li>\n<li>窗口内：已发送，未被确认</li>\n<li>窗口内：可用，未发送</li>\n<li>不可用</li>\n</ol>\n<p>若窗口内某一序号n的ACK timeout，则需要重传n之后的所有分组</p>\n<p>当接收到正确序号的ACK时，窗口便前移一个序号</p>\n<p>0123 +rcv ack0 &#x3D;&gt; 1234</p>\n<p>1234 +rcv ack1 &#x3D;&gt; 2345</p>\n<p>ack2 timeout &#x3D;&gt;re_send (2345)</p>\n<p>接受方无buffer，失序分组会被丢弃，所以需要重发来重新确认顺序</p>\n<h4 id=\"选择性重传SR-selective-repeat\"><a href=\"#选择性重传SR-selective-repeat\" class=\"headerlink\" title=\"选择性重传SR selective repeat\"></a>选择性重传SR selective repeat</h4><p>接收方添加buffer，按序提交给上层</p>\n<p>发送方只重发没有确认的分组</p>\n<p>为每一个分组都添加timer，缓冲区的存在可以暂存失序但正确的分组</p>\n<p>待重传分组到达并恢复顺序后，再统一交付给上层</p>\n<h2 id=\"TCP和UDP的区别\"><a href=\"#TCP和UDP的区别\" class=\"headerlink\" title=\"TCP和UDP的区别\"></a>TCP和UDP的区别</h2><ol>\n<li>通信即时性：UDP协议的双方随时都可以进行通信，而TCP协议的双方必须经过三次握手后才能通信，并且要经过四次挥手才能断开连接</li>\n<li>对象不同：UDP是面向报文的，接收来自应用层的数据直接加上首部就发送。而TCP是将应用层的数据看作字节流，为其设立缓存，将数据进行打包并发送</li>\n<li>通信数量不同：UDP支持单播，多播，广播；TCP只支持单播</li>\n<li>数据的安全性不同：网络层以上提供的都是不可靠的传输协议，UDP也是。而TCP保证了可靠传输，解决了丢失，乱序等问题</li>\n<li>报文大小不同：UDP首部结构简单，8字节；而TCP报文首部有20字节，最大可达60字节。</li>\n</ol>\n<h2 id=\"如何使UDP可靠\"><a href=\"#如何使UDP可靠\" class=\"headerlink\" title=\"如何使UDP可靠\"></a>如何使UDP可靠</h2><p>运输层不能改变，网络层及下层都无法保证可靠，所以需要从应用层来保证可靠</p>\n<p>核心出发点：在应用层模仿TCP的可靠性传输</p>\n<p>如：</p>\n<ol>\n<li>添加添加seq&#x2F;ack机制，确保数据发送到对端</li>\n<li>添加发送和接收缓冲区，主要是用户超时重传</li>\n<li>添加超时重传机制</li>\n</ol>\n<p>送端发送数据时，生成一个随机seq&#x3D;x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack&#x3D;x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。</p>\n<p>只不过都是由应用层的软件来实现的，比如使用UDP数据包+序列号，UDP数据包+时间戳等方法，在服务器端进行应答确认机制。</p>\n<p>比如RUDP或者RTP都是基于UDP实现的可靠传输协议。</p>\n","feature":true,"text":"计算机网络的分层模型OSI七层模型 应用层：计算机上的网络应用，传输应用报文，如HTTP，SMTP 表示层：用于处理交换信息的表示格式（处理语法和处理语义），格式变换，数据加密解密，数据压缩等功能 会话层：向表示层建立连接，并传输有序的数据，也就是建立同步SYN 运输层：负责两个...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","count":1,"path":"api/tags/计算机基础知识.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">计算机网络的分层模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">OSI七层模型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#TCP-x2F-IP%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">TCP&#x2F;IP四层模型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%94%E5%B1%82%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">五层参考模型</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">运输层协议</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#UDP\"><span class=\"toc-text\">UDP</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TCP\"><span class=\"toc-text\">TCP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#TCP%E7%9A%84%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">TCP的连接管理</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TCP%E7%9A%84%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA\"><span class=\"toc-text\">TCP的有限状态机</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">TCP的拥塞控制</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BF%9D%E8%AF%81%EF%BC%9A\"><span class=\"toc-text\">TCP可靠传输机制的保证：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#GBN-%E5%9B%9E%E9%80%80N%E6%AD%A5-go-back-N\"><span class=\"toc-text\">GBN 回退N步 go-back-N</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%80%89%E6%8B%A9%E6%80%A7%E9%87%8D%E4%BC%A0SR-selective-repeat\"><span class=\"toc-text\">选择性重传SR selective repeat</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">TCP和UDP的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E4%BD%BFUDP%E5%8F%AF%E9%9D%A0\"><span class=\"toc-text\">如何使UDP可靠</span></a></li></ol></li></ol>","author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"洪水淹没算法","uid":"52c15247d71045907737fa627f8aa035","slug":"洪水淹没算法","date":"2022-10-31T06:51:29.000Z","updated":"2022-10-31T11:10:18.126Z","comments":true,"path":"api/articles/洪水淹没算法.json","keywords":null,"cover":[],"text":"695. 岛屿的最大面积 输入：grid &#x3D; [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0]...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"LeetCode初见","slug":"LeetCode初见","count":8,"path":"api/tags/LeetCode初见.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"HashMap","uid":"a7e90bf30b292f0f6e0827bd156cab5e","slug":"HashMap","date":"2022-10-30T14:05:57.000Z","updated":"2022-10-31T06:15:48.697Z","comments":true,"path":"api/articles/HashMap.json","keywords":null,"cover":null,"text":"HashCodeHashCode()，在未被重写前，即object类中，是一个Native方法，默认返回对象在堆中的地址，是一个独特值，可以看作是对象的身份ID 而在String类中，HashCode被重写 public int hashCode() &#123; int h =...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":12,"path":"api/tags/Java基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}