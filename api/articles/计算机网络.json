{"title":"计算机网络","uid":"293c17b4d2a4292133cc4d1ffd7f8725","slug":"计算机网络","date":"2022-10-31T06:51:13.000Z","updated":"2022-11-05T14:26:09.410Z","comments":true,"path":"api/articles/计算机网络.json","keywords":null,"cover":[],"content":"<h1 id=\"计算机网络的分层模型\"><a href=\"#计算机网络的分层模型\" class=\"headerlink\" title=\"计算机网络的分层模型\"></a>计算机网络的分层模型</h1><h3 id=\"OSI七层模型\"><a href=\"#OSI七层模型\" class=\"headerlink\" title=\"OSI七层模型\"></a>OSI七层模型</h3><ol>\n<li>应用层：计算机上的网络应用，传输应用报文，如HTTP，SMTP</li>\n<li>表示层：用于处理交换信息的表示格式（处理语法和处理语义），格式变换，数据加密解密，数据压缩等功能</li>\n<li>会话层：向表示层建立连接，并传输有序的数据，也就是建立同步SYN</li>\n<li>运输层：负责两个进程的通信，即端到端，如TCP UDP</li>\n<li>网络层：讲分组从源端传到目的端，注重传输过程中的路径选择，如IP</li>\n<li>链路层：讲网络层的数据包封装成帧，如CSMA</li>\n<li>物理层：以比特流的方式传输</li>\n</ol>\n<p>上面4层是端到端的，也就是关注的是数据从源主机交付到目的主机，而不管每步是怎么传输的</p>\n<p>下面3层是点到点的，关注数据在传输过程中下一步是怎么走的，也就是路由是如何转发的</p>\n<h3 id=\"TCP-x2F-IP四层模型\"><a href=\"#TCP-x2F-IP四层模型\" class=\"headerlink\" title=\"TCP&#x2F;IP四层模型\"></a>TCP&#x2F;IP四层模型</h3><ol>\n<li>应用层（应用层+表示层+会话层）</li>\n<li>运输层</li>\n<li>网络层</li>\n<li>网络接口层（物理层+链路层）</li>\n</ol>\n<h3 id=\"五层参考模型\"><a href=\"#五层参考模型\" class=\"headerlink\" title=\"五层参考模型\"></a>五层参考模型</h3><ol>\n<li>应用层</li>\n<li>运输层 </li>\n<li>网络层</li>\n<li>链路层</li>\n<li>物理层</li>\n</ol>\n<h1 id=\"运输层协议\"><a href=\"#运输层协议\" class=\"headerlink\" title=\"运输层协议\"></a>运输层协议</h1><h2 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h2><p>特点</p>\n<ol>\n<li>无连接状态：UDP无需任何准备就可以传输数据，也没有引入建立连接的时延。并且UDP也不维护连接状态</li>\n<li>精确控制发送数据的时机：应用程序将数据传给UDP，UDP可以立即将数据封装为UDP报文并传递给网络层，而TCP引入了拥塞机制来控制发送方的频率。</li>\n</ol>\n<p>报文结构：</p>\n<p>UDP首部仅四个部分</p>\n<ol>\n<li>源端口号：2字节</li>\n<li>目的端口号：2字节</li>\n<li>长度：2字节</li>\n<li>校验和：2字节</li>\n</ol>\n<p>UDP的校验和：应用数据的所有16比特字之和的反码</p>\n<h2 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h2><p>特点</p>\n<ol>\n<li>保证发送有效，有序的字节流，是面向流的协议，基于TCP:HTTP</li>\n<li>首部20字节</li>\n</ol>\n<p><strong>TCP首部的标志字段</strong></p>\n<ol>\n<li>URG&#x3D;1 表明紧急指针字段有效，表示有紧急数据，应该尽快传输</li>\n<li>ACK&#x3D;1 表明确认字段有效</li>\n<li>PSH&#x3D;1 表示接收方此时应该尽快交付缓冲区的数据</li>\n<li>RST&#x3D;1 表示TCP连接出现严重错误，必须释放连接，再重新建立连接</li>\n<li><strong>SYN</strong>&#x3D;1 表示这是一个连接请求或者连接接受报文</li>\n<li>FIN&#x3D;1 表示此段数据的发送端已经发送完毕最后一个数据段，并要求释放连接</li>\n</ol>\n<h4 id=\"TCP的连接管理\"><a href=\"#TCP的连接管理\" class=\"headerlink\" title=\"TCP的连接管理\"></a>TCP的连接管理</h4><p><strong>三次握手：</strong></p>\n<ol>\n<li>开始处于CLOSED，客户机向服务器发送TCP SYN报文段，使用seq指定初始序号，这个请求报文是没有数据的，客户机进入SYN_SENT</li>\n<li>服务器收到客户机的SYN报文段，使用带ACK的SYN报文段来回复，为该连接分配缓冲区和相关变量，使用seq指定相关序号</li>\n<li>客户机接到服务器的SYN报文段，客户机为连接分配缓冲，使用ACK报文段回复（SYN&#x3D;0），可能会有数据，客户机进入ESTABLISHED</li>\n</ol>\n<p>SYN ：<em>Syn</em>chronize Sequence Numbers 即握手信号</p>\n<p>为什么需要三次：第二步服务器向客户机提供了自己的初始序号，因此再需要一次握手来确认此序号</p>\n<p><strong>四次挥手：</strong></p>\n<ol>\n<li>客户机发送TCP FIN报文段到服务器，进入FIN_WAIT_1</li>\n<li>服务器收到FIN，回复ACK，进入FIN_WAIT_2</li>\n<li>服务器发送FIN报文给客户机，此时连接半关闭，</li>\n<li>客户机接收FIN，回复ACK报文，进入TIME_WAIT，时间结束后，释放资源，服务器收到后连接关闭</li>\n</ol>\n<h2 id=\"TCP的有限状态机\"><a href=\"#TCP的有限状态机\" class=\"headerlink\" title=\"TCP的有限状态机\"></a>TCP的有限状态机</h2><p><img src=\"/../img/TCPFSM.png\" alt=\"TCPFSM\"></p>\n<p><img src=\"/../img/TCPFSM1.png\" alt=\"TCPFSM1\"></p>\n<ol>\n<li>CLOSED 没有任何连接状态</li>\n<li>LISTEN 侦听状态，等待来自远方TCP端口的连接请求 </li>\n<li>SYN-SENT 在发送连接请求后，等待对方确认 </li>\n<li>SYN-RECEIVED 在收到和发送一个连接请求后，等待对方确认 </li>\n<li>ESTABLISHED 代表传输连接建立，双方进入数据传送状态 </li>\n<li>FIN-WAIT-1 主动关闭,主机已发送关闭连接请求，等待对方确认 </li>\n<li>FIN-WAIT-2 主动关闭,主机已收到对方关闭传输连接确认，等待对方发送关闭传输连接请求 </li>\n<li>TIME-WAIT 完成双向传输连接关闭，等待所有分组消失 </li>\n<li>CLOSE-WAIT 被动关闭,收到对方发来的关闭连接请求，并已确认 </li>\n<li>LAST-ACK 被动关闭,等待最后一个关闭传输连接确认，并等待所有分组消失</li>\n<li>CLOSING 如果通信双方同时发送FIN数据包，则同时进行关闭操作，则双方将同时进入TCP_CLOSING状态。 \t具体的，本地发送一个FIN数据包以结束本地数据包发送，如果在等待应答期间，接收到远端发送的FIN数据包，则本地将状态设置为TCP_CLOSING状态。 \t在接收到应答后，再继续装入到TCP_CLOSE_WAIT状态。</li>\n</ol>\n<h3 id=\"TCP的拥塞控制\"><a href=\"#TCP的拥塞控制\" class=\"headerlink\" title=\"TCP的拥塞控制\"></a>TCP的拥塞控制</h3><ol>\n<li><strong>当cwnd &lt; ssthresh时，慢启动，指数增长</strong></li>\n<li><strong>当cwnd &gt; ssthresh时，拥塞避免，线性增长</strong></li>\n<li><strong>出现三个冗余确认，快速恢复，ssthresh &#x3D; cwnd&#x2F;2 ; cwnd &#x3D; ssthresh+3*MSS；此后每收到一个冗余ACK就增加一个MSS，直到收到正确的ACK，cwnd&#x3D;ssthresh,进入慢增长</strong></li>\n<li><strong>出现timeout，ssthresh &#x3D; cwnd&#x2F;2 ; cwnd &#x3D; 1MSS</strong></li>\n</ol>\n<h2 id=\"TCP可靠传输机制的保证：\"><a href=\"#TCP可靠传输机制的保证：\" class=\"headerlink\" title=\"TCP可靠传输机制的保证：\"></a>TCP可靠传输机制的保证：</h2><ol>\n<li><p>检验和：用于检验一个分组中的比特错误</p>\n</li>\n<li><p>定时器：用于超时检验，发生超时事件时重传</p>\n</li>\n<li><p>序号：为一系列分组编号，可以检测出丢失分组以及冗余分组</p>\n</li>\n<li><p>ACK：用于告诉发送方分组被正确接收</p>\n</li>\n<li><p>NAK：用于告诉发送方分组未被正确接收</p>\n</li>\n<li><p>窗口：发送方被限制发送的序号范围</p>\n</li>\n</ol>\n<h4 id=\"GBN-回退N步-go-back-N\"><a href=\"#GBN-回退N步-go-back-N\" class=\"headerlink\" title=\"GBN 回退N步 go-back-N\"></a>GBN 回退N步 go-back-N</h4><p>将序号队列分为四部分</p>\n<ol>\n<li>已被确认</li>\n<li>窗口内：已发送，未被确认</li>\n<li>窗口内：可用，未发送</li>\n<li>不可用</li>\n</ol>\n<p>若窗口内某一序号n的ACK timeout，则需要重传n之后的所有分组</p>\n<p>当接收到正确序号的ACK时，窗口便前移一个序号</p>\n<p>0123 +rcv ack0 &#x3D;&gt; 1234</p>\n<p>1234 +rcv ack1 &#x3D;&gt; 2345</p>\n<p>ack2 timeout &#x3D;&gt;re_send (2345)</p>\n<p>接受方无buffer，失序分组会被丢弃，所以需要重发来重新确认顺序</p>\n<h4 id=\"选择性重传SR-selective-repeat\"><a href=\"#选择性重传SR-selective-repeat\" class=\"headerlink\" title=\"选择性重传SR selective repeat\"></a>选择性重传SR selective repeat</h4><p>接收方添加buffer，按序提交给上层</p>\n<p>发送方只重发没有确认的分组</p>\n<p>为每一个分组都添加timer，缓冲区的存在可以暂存失序但正确的分组</p>\n<p>待重传分组到达并恢复顺序后，再统一交付给上层</p>\n<h2 id=\"TCP和UDP的区别\"><a href=\"#TCP和UDP的区别\" class=\"headerlink\" title=\"TCP和UDP的区别\"></a>TCP和UDP的区别</h2><ol>\n<li>通信即时性：UDP协议的双方随时都可以进行通信，而TCP协议的双方必须经过三次握手后才能通信，并且要经过四次挥手才能断开连接</li>\n<li>对象不同：UDP是面向报文的，接收来自应用层的数据直接加上首部就发送。而TCP是将应用层的数据看作字节流，为其设立缓存，将数据进行打包并发送</li>\n<li>通信数量不同：UDP支持单播，多播，广播；TCP只支持单播</li>\n<li>数据的安全性不同：网络层以上提供的都是不可靠的传输协议，UDP也是。而TCP保证了可靠传输，解决了丢失，乱序等问题</li>\n<li>报文大小不同：UDP首部结构简单，8字节；而TCP报文首部有20字节，最大可达60字节。</li>\n</ol>\n<h2 id=\"如何使UDP可靠\"><a href=\"#如何使UDP可靠\" class=\"headerlink\" title=\"如何使UDP可靠\"></a>如何使UDP可靠</h2><p>运输层不能改变，网络层及下层都无法保证可靠，所以需要从应用层来保证可靠</p>\n<p>核心出发点：在应用层模仿TCP的可靠性传输</p>\n<p>如：</p>\n<ol>\n<li>添加添加seq&#x2F;ack机制，确保数据发送到对端</li>\n<li>添加发送和接收缓冲区，主要是用户超时重传</li>\n<li>添加超时重传机制</li>\n</ol>\n<p>送端发送数据时，生成一个随机seq&#x3D;x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack&#x3D;x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。</p>\n<p>只不过都是由应用层的软件来实现的，比如使用UDP数据包+序列号，UDP数据包+时间戳等方法，在服务器端进行应答确认机制。</p>\n<p>比如RUDP或者RTP都是基于UDP实现的可靠传输协议。</p>\n<h3 id=\"QUIC协议\"><a href=\"#QUIC协议\" class=\"headerlink\" title=\"QUIC协议\"></a>QUIC协议</h3><p>HTTP3弃用TCP后，使用了<strong>基于UDP</strong>的QUIC协议，使用UDP实现了TCP+TLS的特性，且仅需一次握手即可建立可靠连接（<strong>0-RTT 握手</strong>）</p>\n<p>如何实现可靠传输</p>\n<ol>\n<li>包号PKN+确认应答SACK来保证确认接收和数据有序性</li>\n<li>滑动窗口：应用层实现</li>\n<li>拥塞控制：应用层实现</li>\n</ol>\n<p>如何避免对头阻塞</p>\n<ol>\n<li>弃用TCP</li>\n<li>使用二进制帧格式的数据结构，面向流的传输，给每个请求流都分配一个独立的滑动窗口</li>\n</ol>\n<p><img src=\"/../img/QUIC.png\" alt=\"QUIC\"></p>\n<h2 id=\"为什么QQ使用的是UDP协议\"><a href=\"#为什么QQ使用的是UDP协议\" class=\"headerlink\" title=\"为什么QQ使用的是UDP协议\"></a>为什么QQ使用的是UDP协议</h2><p>登陆和保持连接状态采用TCP，和好友之间发送消息采用UDP，内网传文件采用了P2P</p>\n<ol>\n<li>当时没有epoll这种可以支持成千上万tcp并发连接的技术，所以使用了应用层封装后的UDP来解决大并发的问题。后面也懒得修改</li>\n<li>国内网络环境水平参差复杂，特别是在千禧年，带宽窄且抖动厉害，此时TCP的等待握手反而会成为劣势，占用宝贵的时间资源和性能资源</li>\n<li>UDP的特性，即时封装即时发送，所以在在应用层的控制下，可以更快地探测和重传。</li>\n</ol>\n<p>QQ如何实现可靠：使用上层协议来实现可靠，如果客户端使用UDP协议发出消息后，服务器收到该包，需要使用UDP协议发回一个应答包。如此来保证消息可以无遗漏传输</p>\n<h1 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h1><p>超文本传输协议，基于TCP实现</p>\n<h4 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ol>\n<li>可靠</li>\n<li>简单快速：客户向服务器请求服务时，只需传输方法和路径</li>\n<li>灵活：支持任意类型的数据</li>\n<li>无状态，无持久化</li>\n</ol>\n<h4 id=\"请求指令\"><a href=\"#请求指令\" class=\"headerlink\" title=\"请求指令\"></a>请求指令</h4><ol>\n<li>GET：从服务器获取一个资源</li>\n<li>PUT：将来自客户端的资源存储到服务器中</li>\n<li>POST：将客户端数据发送到服务器应用程序中去</li>\n<li>DELETE：从服务器中删除资源</li>\n<li>HEAD：仅发送HTTP首部</li>\n</ol>\n<p>GET和POST的区别：</p>\n<ol>\n<li>get通过URL传输数据，比如以字段&#x3D;value的形式，以？和&amp;连接。传输少量数据，URL是可见的，可能会泄漏信息。</li>\n<li>POST可以传输大量数据，且支持标准字符集，可以正确传输中文字符</li>\n<li>前者着重于获取资源，后者着重于发送数据</li>\n</ol>\n<h4 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h4><p>响应报文都会携带一个状态码来告知请求报文的状态</p>\n<ol>\n<li>200：正确返回</li>\n<li>302：重定向</li>\n<li>404：没找到</li>\n</ol>\n<h2 id=\"报文\"><a href=\"#报文\" class=\"headerlink\" title=\"报文\"></a>报文</h2><h3 id=\"请求报文\"><a href=\"#请求报文\" class=\"headerlink\" title=\"请求报文\"></a>请求报文</h3><ol>\n<li>起始行：请求指令，URL，HTTP版本号</li>\n<li>首部：描述浏览器可以接受的字符集，编码方式，期望的语言</li>\n<li>主体：可能会有，也可能没有</li>\n</ol>\n<h3 id=\"响应报文\"><a href=\"#响应报文\" class=\"headerlink\" title=\"响应报文\"></a>响应报文</h3><ol>\n<li>起始行：版本号，状态码</li>\n<li>首部：返回的数据类型，长度等信息</li>\n<li>主体：二进制流</li>\n</ol>\n<h2 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h2><p>身份标识：向服务器表明自己的身份</p>\n<p>Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</p>\n<p>Cookie存储的数据量有限，且都是保存在<strong>客户端浏览器</strong>中，大小一般不超过4kb</p>\n<p><img src=\"/../img/cookie.png\" alt=\"cookie\"></p>\n<p>在服务器发送响应后，会顺带将Set-Cookie也发送给客户端。</p>\n<p>当客户端保存后，之后给服务器发送请求时，都会在请求中包含Cookie的头部</p>\n<p>应用：判断用户是否已经登录网站，购物车</p>\n<h2 id=\"Session\"><a href=\"#Session\" class=\"headerlink\" title=\"Session\"></a>Session</h2><p>当用户登录时，发送用户名和密码后，服务端查询数据库是否存在该用户，如果有的话，会自动生成一个sessionid，用于记录登录的时间、状态、属于哪个用户，过期时间等信息，并将这些信息<strong>保存在服务端</strong></p>\n<p>同时，将这些信息通过<strong>cookie的形式</strong>将这些数据返回给客户端</p>\n<p>当用户再次登录该服务器，访问其他接口的时候，会自动带上sessionid，服务器接收到请求后会自动查询有没有存储这个sessionid的信息</p>\n<p><img src=\"/../img/session.png\" alt=\"session\"></p>\n<p>Cookie和Session的区别：</p>\n<ol>\n<li>Session因为存储在服务器上，所以安全性比Cookie更高。</li>\n<li>Cookie中只能存储ASCII字符串，如果是略微复杂的信息如java 对象，unicode字符串，比较艰难，需要进行编码，而session可以存取任意类型的数据，包括java对象</li>\n<li>隐私策略不同：cookie对客户端可见，客户端的程序是可以窥探到cookie的。而session对客户端是不可见的。</li>\n<li>cookie的过期时间可以设置得很长，而session因为存储在服务器上，出于性能的考虑，不能将存活时间设置得太长</li>\n<li>当并发量高的时候，session的资源消耗会很高，而cookie就不会给服务器造成太大压力</li>\n</ol>\n<p>存在的问题</p>\n<ol>\n<li>存储在服务器，消耗大量的存储资源</li>\n<li>查询速度会成为瓶颈，导致响应速度慢</li>\n<li>在跨端、跨服务器时，需要session同步</li>\n<li>通过架设数据库集群redis，会导致维护成本高，配置复杂</li>\n</ol>\n<h2 id=\"Token\"><a href=\"#Token\" class=\"headerlink\" title=\"Token\"></a>Token</h2><p>服务器不存储用户数据，而是直接通过加密的方式把用户数据通过令牌的方式返回给客户端，该令牌将会由服务器自己设置。</p>\n<p>每次用户访问时，都会携带这个令牌，用来证明自己的身份，从而得到自己的状态和数据。</p>\n<p>服务器不需要存储用户资源导致资源占用过多的问题，也不需要每次查询从而加快了响应速度，而且传递的方式也由双方协定，不管是否跨域，都可以正常传递。</p>\n<p><img src=\"/../img/token.png\" alt=\"token\"></p>\n<p>但是，这种token容易被伪造，因为只要任何人拿到了这种令牌都可以称自己是合法的用户</p>\n<p>从而获取一些私密的信息，此时如果服务器能拥有某种方式使得能证明该用户是合法的就显得极为重要</p>\n<p><strong>sign</strong>:由服务端进行设置，且只有服务器知道签名和密钥。</p>\n<p>当用户登录时，服务器提取将用户信息（payload）和header组成新的数据，然后再加上sign进行加密得到一个token。</p>\n<p>当用户发起请求后，由服务器对sign进行解密，然后再结合自己设置的sign进行对比，如果一致，就证明该token合法，如果不一致，该token就是非法的</p>\n<h2 id=\"JWT\"><a href=\"#JWT\" class=\"headerlink\" title=\"JWT\"></a>JWT</h2><p>是token的一个实现形式，全称为JSON Web Token，本质是一个字符串，他将用户的信息保存到一个json字符串中，然后进行编码后得到一个<code>JWT token</code>，<strong>并且这个<code>JWT token</code>带有签名信息，接收后可以校验是否被篡改</strong></p>\n<p>JWT的优势：</p>\n<ol>\n<li>数据量小，传输速度快</li>\n<li>以JSON加密保存，跨语言</li>\n<li>不依赖于cookie和session，适合于分布式微服务</li>\n</ol>\n<h3 id=\"JWT的结构\"><a href=\"#JWT的结构\" class=\"headerlink\" title=\"JWT的结构\"></a>JWT的结构</h3><h4 id=\"header\"><a href=\"#header\" class=\"headerlink\" title=\"header\"></a>header</h4><p>头部是一个描述JWT元数据的JSON对象</p>\n<pre class=\"line-numbers language-JSON\" data-language=\"JSON\"><code class=\"language-JSON\">&#123;\n  &quot;alg&quot;: &quot;HS256&quot;,&#x2F;&#x2F;签名使用的算法\n  &quot;typ&quot;: &quot;JWT&quot;&#x2F;&#x2F;令牌名称\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"Payload\"><a href=\"#Payload\" class=\"headerlink\" title=\"Payload\"></a>Payload</h4><p>有效载荷，提供七个可选字段：</p>\n<p><code>iss</code>：发行人 <code>exp</code>：到期时间 <code>sub</code>：主题 <code>aud</code>：用户 <code>nbf</code>：在此之前不可用 <code>iat</code>：发布时间 <code>jti</code>：JWT ID用于标识该JWT</p>\n<pre class=\"line-numbers language-JSON\" data-language=\"JSON\"><code class=\"language-JSON\">&#123;\n  &quot;sub&quot;: &quot;1234567890&quot;,\n  &quot;name&quot;: &quot;Helen&quot;,\n  &quot;admin&quot;: true\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"Signature\"><a href=\"#Signature\" class=\"headerlink\" title=\"Signature\"></a>Signature</h4><p>签名哈希部分是对上面两部分数据签名，需要使用base64编码后的header和payload数据，通过指定的算法生成哈希，以确保数据不会被篡改。</p>\n<p>首先，需要指定一个密钥（secret）。该密钥仅仅为保存在服务器中，并且不能向用户公开。</p>\n<p>然后，使用header中指定的签名算法（默认情况下为HMAC SHA256）根据以下公式生成签名</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token function\">HMACSHA256</span><span class=\"token punctuation\">(</span><span class=\"token function\">base64UrlEncode</span><span class=\"token punctuation\">(</span>header<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\".\"</span><span class=\"token operator\">+</span><span class=\"token function\">base64UrlEncode</span><span class=\"token punctuation\">(</span>payload<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>secret<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>在计算出签名哈希后，JWT头，有效载荷和签名哈希的三个部分组合成一个字符串，每个部分用<code>.</code>分隔，就构成整个JWT对象</p>\n<p><img src=\"/../img/JWT.png\" alt=\"JWT\"></p>\n<p>注意JWT每部分的作用，在服务端接收到客户端发送过来的JWT token之后：</p>\n<p>header和payload可以直接利用base64解码出原文，从header中获取哈希签名的算法，从payload中获取有效数据<br>signature由于使用了<strong>不可逆的加密算法</strong>，无法解码出原文，它的作用是<strong>校验token有没有被篡改</strong>。</p>\n<p>服务端获取header中的加密算法之后，利用该算法加上secretKey对header、payload进行加密，比对加密后的数据和客户端发送过来的签名是否一致，注意secretKey只能保存在服务端。</p>\n<p>对于不同的加密算法secretKey含义有所不同，一般对于MD5类型的摘要加密算法，secretKey实际上代表的是盐值</p>\n<h1 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h1><p>HTTP+SSL，是可加密的，身份认证的网络协议，更加安全</p>\n<h2 id=\"SSL-x2F-TLS\"><a href=\"#SSL-x2F-TLS\" class=\"headerlink\" title=\"SSL&#x2F;TLS\"></a>SSL&#x2F;TLS</h2><p>HTTP的缺点：报文都是明文的，始终可见，安全性低</p>\n<p>对称加密：双方使用同一种方式来加密和解密，如果加密的规则被破解，那么就不存在密文了</p>\n<p>非对称加密：公钥加密后，必须由私钥解密；反之必须由公钥解密。</p>\n<p>SSL证书：由CA颁发，拥有SSL证书的服务器就可以向客户端提供公钥，支持HTTPS连接</p>\n<h1 id=\"计算机输入URL后会发生什么\"><a href=\"#计算机输入URL后会发生什么\" class=\"headerlink\" title=\"计算机输入URL后会发生什么\"></a>计算机输入URL后会发生什么</h1><h2 id=\"浏览器查找域名的IP地址\"><a href=\"#浏览器查找域名的IP地址\" class=\"headerlink\" title=\"浏览器查找域名的IP地址\"></a>浏览器查找域名的IP地址</h2><ol>\n<li>客户端发起请求后，浏览器解析域名。首先浏览器会查看本地磁盘的host文件（已被舍弃），是否有对应的IP地址，如果有就直接使用</li>\n<li>如果没有，就会发送一个DNS请求给本地的DNS服务器，比如中国移动</li>\n<li>本地DNS服务器会查询缓存记录，如果缓存存在，就直接返回结果。如果没有，本地DNS服务器还要向DNS根服务器进行查询</li>\n<li>根 DNS 服务器不记录具体的域名和 IP 地址的对应关系，而是告诉本地 DNS 服务器到顶级域名服务器进行查询，并给出顶级域名服务器的地址（迭代查询）</li>\n<li>本地 DNS 服务器继续向域服务器发出请求，域服务器收到请求之后，不会直接返回域名和 IP 地址的对应关系，而是告诉本地 DNS 服务器权威域名服务器的地址</li>\n<li>本地 DNS 服务器向权威域名服务器发出请求，收到一个域名和 IP 地址对应关系，本地 DNS 服务器不仅要把 IP 地址返回给客户端，还要把这个对应关系保存在缓存中，以备下次别的用户访问。</li>\n</ol>\n<h2 id=\"浏览器向web服务器发送一个HTTP请求\"><a href=\"#浏览器向web服务器发送一个HTTP请求\" class=\"headerlink\" title=\"浏览器向web服务器发送一个HTTP请求\"></a>浏览器向web服务器发送一个HTTP请求</h2><p>拿到IP地址后，浏览器会以一个随机端口号向服务器的80端口发起TCP的连接请求</p>\n<p><strong>三次握手</strong>建立TCP连接</p>\n<p>建立了 TCP 连接之后，发起了一个 HTTP 请求，如 GET、POST等</p>\n<h2 id=\"服务器的重定向访问\"><a href=\"#服务器的重定向访问\" class=\"headerlink\" title=\"服务器的重定向访问\"></a>服务器的重定向访问</h2><p>301和302重定向对比<br>两个状态码都表示重定向，但301表示旧地址的资源已经被永久的移除了，搜索引擎在抓取新的内容时将旧的网络地址交换为重定向后的网址；302表示旧的地址资源还在，这个重定向只是临时的从旧地址跳转到新地址，搜索引擎会抓取新的内容而保存旧的地址。防止一个页面出现多个缓存。</p>\n<p>浏览器会重新发送HTTP请求</p>\n<h2 id=\"服务器处理并返回HTTP响应，浏览器显示HTML\"><a href=\"#服务器处理并返回HTTP响应，浏览器显示HTML\" class=\"headerlink\" title=\"服务器处理并返回HTTP响应，浏览器显示HTML\"></a>服务器处理并返回HTTP响应，浏览器显示HTML</h2>","feature":true,"text":"计算机网络的分层模型OSI七层模型 应用层：计算机上的网络应用，传输应用报文，如HTTP，SMTP 表示层：用于处理交换信息的表示格式（处理语法和处理语义），格式变换，数据加密解密，数据压缩等功能 会话层：向表示层建立连接，并传输有序的数据，也就是建立同步SYN 运输层：负责两个...","link":"","photos":[],"count_time":{"symbolsCount":"7.6k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","count":1,"path":"api/tags/计算机基础知识.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">计算机网络的分层模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">OSI七层模型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#TCP-x2F-IP%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">TCP&#x2F;IP四层模型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%94%E5%B1%82%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">五层参考模型</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">运输层协议</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#UDP\"><span class=\"toc-text\">UDP</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TCP\"><span class=\"toc-text\">TCP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#TCP%E7%9A%84%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">TCP的连接管理</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TCP%E7%9A%84%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA\"><span class=\"toc-text\">TCP的有限状态机</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">TCP的拥塞控制</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BF%9D%E8%AF%81%EF%BC%9A\"><span class=\"toc-text\">TCP可靠传输机制的保证：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#GBN-%E5%9B%9E%E9%80%80N%E6%AD%A5-go-back-N\"><span class=\"toc-text\">GBN 回退N步 go-back-N</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%80%89%E6%8B%A9%E6%80%A7%E9%87%8D%E4%BC%A0SR-selective-repeat\"><span class=\"toc-text\">选择性重传SR selective repeat</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">TCP和UDP的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E4%BD%BFUDP%E5%8F%AF%E9%9D%A0\"><span class=\"toc-text\">如何使UDP可靠</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#QUIC%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">QUIC协议</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88QQ%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AFUDP%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">为什么QQ使用的是UDP协议</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#HTTP%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">HTTP协议</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">特点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AF%B7%E6%B1%82%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">请求指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%8A%B6%E6%80%81%E7%A0%81\"><span class=\"toc-text\">状态码</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8A%A5%E6%96%87\"><span class=\"toc-text\">报文</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87\"><span class=\"toc-text\">请求报文</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87\"><span class=\"toc-text\">响应报文</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Cookie\"><span class=\"toc-text\">Cookie</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Session\"><span class=\"toc-text\">Session</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Token\"><span class=\"toc-text\">Token</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JWT\"><span class=\"toc-text\">JWT</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JWT%E7%9A%84%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">JWT的结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#header\"><span class=\"toc-text\">header</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Payload\"><span class=\"toc-text\">Payload</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Signature\"><span class=\"toc-text\">Signature</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#HTTPS\"><span class=\"toc-text\">HTTPS</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SSL-x2F-TLS\"><span class=\"toc-text\">SSL&#x2F;TLS</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BE%93%E5%85%A5URL%E5%90%8E%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">计算机输入URL后会发生什么</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9F%A5%E6%89%BE%E5%9F%9F%E5%90%8D%E7%9A%84IP%E5%9C%B0%E5%9D%80\"><span class=\"toc-text\">浏览器查找域名的IP地址</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%91web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E4%B8%80%E4%B8%AAHTTP%E8%AF%B7%E6%B1%82\"><span class=\"toc-text\">浏览器向web服务器发送一个HTTP请求</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%87%8D%E5%AE%9A%E5%90%91%E8%AE%BF%E9%97%AE\"><span class=\"toc-text\">服务器的重定向访问</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%84%E7%90%86%E5%B9%B6%E8%BF%94%E5%9B%9EHTTP%E5%93%8D%E5%BA%94%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BAHTML\"><span class=\"toc-text\">服务器处理并返回HTTP响应，浏览器显示HTML</span></a></li></ol></li></ol>","author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"洪水淹没算法","uid":"52c15247d71045907737fa627f8aa035","slug":"洪水淹没算法","date":"2022-10-31T06:51:29.000Z","updated":"2022-10-31T11:10:18.126Z","comments":true,"path":"api/articles/洪水淹没算法.json","keywords":null,"cover":[],"text":"695. 岛屿的最大面积 输入：grid &#x3D; [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0]...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"LeetCode初见","slug":"LeetCode初见","count":8,"path":"api/tags/LeetCode初见.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"HashMap","uid":"a7e90bf30b292f0f6e0827bd156cab5e","slug":"HashMap","date":"2022-10-30T14:05:57.000Z","updated":"2022-10-31T06:15:48.697Z","comments":true,"path":"api/articles/HashMap.json","keywords":null,"cover":null,"text":"HashCodeHashCode()，在未被重写前，即object类中，是一个Native方法，默认返回对象在堆中的地址，是一个独特值，可以看作是对象的身份ID 而在String类中，HashCode被重写 public int hashCode() &#123; int h =...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":12,"path":"api/tags/Java基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}