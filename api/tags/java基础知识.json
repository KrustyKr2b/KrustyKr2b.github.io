{"name":"Java基础知识","slug":"Java基础知识","count":9,"postlist":[{"title":"JVM相关知识","uid":"d819bd760b595babeef6cadb7a50d452","slug":"JVM基础","date":"2022-09-12T04:37:43.000Z","updated":"2022-11-13T07:58:08.432Z","comments":true,"path":"api/articles/JVM基础.json","keywords":null,"cover":[],"text":"JAVA内存区域讲解运行时数据区域分为两部分：线程共享和线程私有 线程共享区域： 堆：是虚拟机内存的最大的一块，此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存，注意是“几乎”，JDK1.7之后，当方法中的对象引用没有被返回或者未被外部使用，就会直...","link":"","photos":[],"count_time":{"symbolsCount":"9k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":9,"path":"api/tags/Java基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"HashMap","uid":"a7e90bf30b292f0f6e0827bd156cab5e","slug":"HashMap","date":"2022-10-30T14:05:57.000Z","updated":"2022-11-13T08:18:49.266Z","comments":true,"path":"api/articles/HashMap.json","keywords":null,"cover":null,"text":"HashCodeHashCode()，在未被重写前，即object类中，是一个Native方法，默认返回对象在堆中的地址，是一个独特值，可以看作是对象的身份ID 而在String类中，HashCode被重写 public int hashCode() &#123; int h =...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":9,"path":"api/tags/Java基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Java基础知识汇总","uid":"2e8864ab557e295b3f55e14c06a19e33","slug":"JAVA基础知识汇总","date":"2022-11-13T07:48:43.000Z","updated":"2022-11-13T07:56:15.222Z","comments":true,"path":"api/articles/JAVA基础知识汇总.json","keywords":null,"cover":null,"text":"Object类中有哪些方法 equals()：未被重写前，由&#x3D;&#x3D;来实现，比较引用数据类型的引用地址是否相同 HashCode()：本地方法，未被重写前返回对象在堆上的唯一地址值，可以看作是对象的身份ID clone()：实现了cloneable接口才可以调用该...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":9,"path":"api/tags/Java基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"Java数据结构","uid":"9a0ea7adf62049ce83652b0a7c894a59","slug":"Java数据结构","date":"2022-08-12T05:41:02.000Z","updated":"2022-10-31T06:16:14.603Z","comments":true,"path":"api/articles/Java数据结构.json","keywords":null,"cover":null,"text":"ArrayListArrayList即数组列表，是基于数组实现的，这个数组可以插入任何元素，只不过这个数组是可以按需扩容，可以进行数据拷贝的 ArrayList的构造private static final int DEFAULT_CAPACITY = 10; //默认初始化容量...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":9,"path":"api/tags/Java基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"JAVA的字符串","uid":"b8307bc7cc4dad51e597289f7dfa286e","slug":"Java的字符串","date":"2022-08-14T04:57:02.000Z","updated":"2022-10-13T08:13:50.657Z","comments":true,"path":"api/articles/Java的字符串.json","keywords":null,"cover":null,"text":"String&amp;StringBuilderString的底层数据结构是数组char value[] public final class String implements java.io.Serializable, Comparable&lt;String>, CharS...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":9,"path":"api/tags/Java基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"synchronized,volatile与lock","uid":"2b0f61f6bf7b985f1f4587a53651bb18","slug":"synchronized-volatile与lock","date":"2022-10-20T06:09:39.000Z","updated":"2022-10-31T06:16:33.398Z","comments":true,"path":"api/articles/synchronized-volatile与lock.json","keywords":null,"cover":[],"text":"Synchronized同步锁，保证在同一时刻，被修饰的代码块或方法只有一个线程执行，以达到并发安全的效果 同步锁是解决并发问题最简单的一种方法，直接给代码块加上此关键字即可 在JDK1.5之前，Synchronized是一个重量级锁，在以后的版本经过改进后成重量级减小 sync...","link":"","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":9,"path":"api/tags/Java基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"一篇关于锁的文章","uid":"a213144f9a961ec1d4584b73bef34320","slug":"一篇关于锁的文章","date":"2022-10-19T08:28:53.000Z","updated":"2022-10-31T06:17:36.262Z","comments":true,"path":"api/articles/一篇关于锁的文章.json","keywords":null,"cover":[],"text":"面试官：解释一下什么是乐观锁，悲观锁，自旋锁，读写锁，排它锁，共享锁，统一锁，分段锁 这种问题虽然庞大复杂，但是千万不要被干沉默，能说清楚就是P5往上 按抽象概念分悲观锁悲观地认为数据大概率会被其他线程操作，所以具有强烈的独占性和排它性 比如synchronized，先加锁再执行...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":9,"path":"api/tags/Java基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"进程，线程和协程","uid":"a81dd39014b037511fb6ceaf21738564","slug":"协程","date":"2022-10-20T08:53:01.000Z","updated":"2022-11-15T07:12:22.395Z","comments":true,"path":"api/articles/协程.json","keywords":null,"cover":[],"text":"进程an instance of a computer program that is being executed 进程是程序的一次执行，是一个程序及其数据，运行环境，在处理机上运行时所发生的活动。 与程序不同的是，进程具有动态性和生命周期，是系统进行资源分配和调度的独立单位。...","link":"","photos":[],"count_time":{"symbolsCount":"7.6k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":9,"path":"api/tags/Java基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"线程池","uid":"d1863bbf8aa3ec7bc32e4a0f3476163f","slug":"线程池","date":"2022-10-18T12:33:43.000Z","updated":"2022-10-31T06:17:20.965Z","comments":true,"path":"api/articles/线程池.json","keywords":null,"cover":null,"text":"何为线程池：一种多线程的处理形式，处理过程中可以将任务添加到队列中，然后在创建线程后自动启动这些任务。 线程池的优势： 线程和任务分离，线程可被重用，提升复用性 控制线程并发数量，统一管理，降低服务器压力 提升系统响应速度，因为线程池内的线程可以被复用，且线程池内有核心线程待命，...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","count":9,"path":"api/tags/Java基础知识.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}]}