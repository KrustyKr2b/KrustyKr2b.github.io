{"name":"面试突击","slug":"面试突击","count":6,"postlist":[{"title":"synchronized,volatile与lock","uid":"2b0f61f6bf7b985f1f4587a53651bb18","slug":"synchronized-volatile与lock","date":"2022-10-20T06:09:39.000Z","updated":"2022-10-20T08:28:27.526Z","comments":true,"path":"api/articles/synchronized-volatile与lock.json","keywords":null,"cover":[],"text":"Synchronized同步锁，保证在同一时刻，被修饰的代码块或方法只有一个线程执行，以达到并发安全的效果 同步锁是解决并发问题最简单的一种方法，直接给代码块加上此关键字即可 在JDK1.5之前，Synchronized是一个重量级锁，在以后的版本经过改进后成重量级减小 sync...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"面试突击","slug":"面试突击","count":6,"path":"api/tags/面试突击.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"一篇关于锁的文章","uid":"a213144f9a961ec1d4584b73bef34320","slug":"一篇关于锁的文章","date":"2022-10-19T08:28:53.000Z","updated":"2022-10-19T14:15:28.671Z","comments":true,"path":"api/articles/一篇关于锁的文章.json","keywords":null,"cover":[],"text":"面试官：解释一下什么是乐观锁，悲观锁，自旋锁，读写锁，排它锁，共享锁，统一锁，分段锁 这种问题虽然庞大复杂，但是千万不要被干沉默，能说清楚就是P5往上 按抽象概念分悲观锁悲观地认为数据大概率会被其他线程操作，所以具有强烈的独占性和排它性 比如synchronized，先加锁再执行...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"面试突击","slug":"面试突击","count":6,"path":"api/tags/面试突击.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"每日一问10/13/2022","uid":"cfe019c4b3b720ab570d0b0eea78733d","slug":"每日一问10-13-2022","date":"2022-10-13T12:41:31.000Z","updated":"2022-10-13T13:50:40.940Z","comments":true,"path":"api/articles/每日一问10-13-2022.json","keywords":null,"cover":null,"text":"Q1：Object o = new Object()在内存中占用多少个字节？答： 一个对象在内存中的存储布局：markword：8字节，锁信息+HashCode+GC信息；classPointer:4字节；对齐：保证大小能被8整除；数据段：即对象内声明的变量 所以一个空对象最小为...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"面试突击","slug":"面试突击","count":6,"path":"api/tags/面试突击.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"每日一问10/14/2022","uid":"91683efeeb5b4f823eb3ffc7a800c9f1","slug":"每日一问10-14-2022","date":"2022-10-14T06:56:54.000Z","updated":"2022-10-14T14:06:11.102Z","comments":true,"path":"api/articles/每日一问10-14-2022.json","keywords":null,"cover":null,"text":"Q1：接口和抽象类有哪些区别答： 相同点： 不能被实例化 可以将抽象类和接口类型作为引用类型 一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部实现 不同点： 抽象类中可以定义构造器，可以有抽象方法和具体方法，抽象类中可以定义成员变量，一个类只能继承一个抽象类...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"面试突击","slug":"面试突击","count":6,"path":"api/tags/面试突击.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"每日一问10/17/2022","uid":"626084d3a58b4f97f22000ce81567720","slug":"每日一问10-17-2022","date":"2022-10-17T13:16:32.000Z","updated":"2022-10-18T14:02:21.366Z","comments":true,"path":"api/articles/每日一问10-17-2022.json","keywords":null,"cover":[],"text":"Q1:String,StringBuilder,StringBuffer的区别答： String的底层是一个由final修饰的char型数组，String是静态只读的，当改变变量的值时，其实只是改变了引用对象的指向，指向了新创建的字符串，而原字符串仍存在于字符串常量池。 Stri...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"面试突击","slug":"面试突击","count":6,"path":"api/tags/面试突击.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"线程池","uid":"d1863bbf8aa3ec7bc32e4a0f3476163f","slug":"线程池","date":"2022-10-18T12:33:43.000Z","updated":"2022-10-18T14:00:04.676Z","comments":true,"path":"api/articles/线程池.json","keywords":null,"cover":null,"text":"何为线程池：一种多线程的处理形式，处理过程中可以将任务添加到队列中，然后在创建线程后自动启动这些任务。 线程池的优势： 线程和任务分离，线程可被重用，提升复用性 控制线程并发数量，统一管理，降低服务器压力 提升系统响应速度，因为线程池内的线程可以被复用，且线程池内有核心线程待命，...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"面试突击","slug":"面试突击","count":6,"path":"api/tags/面试突击.json"}],"author":{"name":"Samuel","slug":"blog-author","avatar":"/img/avatar.PNG","link":"/","description":"<b>燃烧烈爱,静默如谜</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}]}