[{"id":"e0c4de6a72c616ec823d805c53472b1a","title":"子集排列问题sucks","content":"回溯算法解决所有子集排列问题形式一：元素无重复，且不可复选，即nums中所有元素均唯一，且最多使用一次\n/* 组合/子集问题回溯算法框架 */\n//使用start参数来避免复选\nvoid backtrack(int[] nums, int start) &#123;\n    // 回溯算法标准框架\n    for (int i = start; i &lt; nums.length; i++) &#123;\n        // 做选择\n        track.addLast(nums[i]);\n        // 注意参数\n        backtrack(nums, i + 1);\n        // 撤销选择\n        track.removeLast();\n    &#125;\n&#125;\n/* 排列问题回溯算法框架 */\n//使用used数组来记录已选过的元素，避免复选\nvoid backtrack(int[] nums) &#123;\n    for (int i = 0; i &lt; nums.length; i++) &#123;\n        // 剪枝逻辑\n        if (used[i]) &#123;\n            continue;\n        &#125;\n        // 做选择\n        used[i] = true;\n        track.addLast(nums[i]);\n\n        backtrack(nums);\n        // 撤销选择\n        track.removeLast();\n        used[i] = false;\n    &#125;\n&#125;\n\n形式二：元素有重复，但是不可以复选，即nums中存在重复的元素，但是每个元素只能使用一次\nArrays.sort(nums);\n//为数组排序，使得相同的元素排在一起\n/* 组合/子集问题回溯算法框架 */\nvoid backtrack(int[] nums, int start) &#123;\n    // 回溯算法标准框架\n    for (int i = start; i &lt; nums.length; i++) &#123;\n        // 剪枝逻辑，跳过值相同的相邻树枝\n        if (i > start &amp;&amp; nums[i] == nums[i - 1]) &#123;\n            continue;\n        &#125;\n        // 做选择\n        track.addLast(nums[i]);\n        // 注意参数\n        backtrack(nums, i + 1);\n        // 撤销选择\n        track.removeLast();\n    &#125;\n&#125;\n\n\nArrays.sort(nums);\n/* 排列问题回溯算法框架 */\nvoid backtrack(int[] nums) &#123;\n    for (int i = 0; i &lt; nums.length; i++) &#123;\n        // 剪枝逻辑\n        if (used[i]) &#123;\n            continue;\n        &#125;\n        // 剪枝逻辑，固定相同的元素在排列中的相对位置，若i-1未被选择，那么i也不能选，相当于固定了顺序\n        if (i > 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) &#123;\n            continue;\n        &#125;\n        // 做选择\n        used[i] = true;\n        track.addLast(nums[i]);\n\n        backtrack(nums);\n        // 撤销选择\n        track.removeLast();\n        used[i] = false;\n    &#125;\n&#125;\n\n形式三：元素无重复，但是可以复选\n/* 组合/子集问题回溯算法框架 */\nvoid backtrack(int[] nums, int start) &#123;\n    // 回溯算法标准框架\n    for (int i = start; i &lt; nums.length; i++) &#123;\n        // 做选择\n        track.addLast(nums[i]);\n        // 注意参数\n        backtrack(nums, i);\n        // 撤销选择\n        track.removeLast();\n    &#125;\n&#125;\n\n\n/* 排列问题回溯算法框架 */\nvoid backtrack(int[] nums) &#123;\n    for (int i = 0; i &lt; nums.length; i++) &#123;\n        // 做选择\n        track.addLast(nums[i]);\n        backtrack(nums);\n        // 撤销选择\n        track.removeLast();\n    &#125;\n&#125;\n","slug":"子集排列问题sucks","date":"2022-10-13T05:14:49.000Z","categories_index":"","tags_index":"算法归纳","author_index":"Samuel"},{"id":"bdd0b34d75b797c3e041acb9ccf9384c","title":"位运算技巧","content":"//位运算算法技巧\n//不用临时变量交换两个数\na ^= b;\nb ^= a;\na ^= b;\n//判断是否异号（同号）\nboolean f = ((x ^ y) &lt; 0);\n//利用或操作 | 和空格将英文字符转换为小写\n('A' | ' ') = 'a';\n//利用与操作 &amp; 和下划线将英文字符转换为大写\n('b' &amp; '_') = 'B';\n//利用异或操作 ^ 和空格进行英文字符大小写互换\n('D' ^ ' ') = 'd';\n//去掉最后一位1\nn &amp; (n-1);\n//异或运算的特殊性质,异或运算满足交换律和结合律\na ^ a = 0;\na ^ 0 = a;\n//取反码+与运算\nx &amp; ~x = 0;\nx &amp; ~0 =x;\n\n","slug":"位运算技巧","date":"2022-10-13T04:59:51.000Z","categories_index":"","tags_index":"算法归纳","author_index":"Samuel"},{"id":"2181d0c3b44c85661e4d1e16727307c2","title":"Redis随想","content":"RedisSDS结构模型基于C语言，由Redis封装的一种简单高效安全的数据结构\n源码分析SDS的底层实现思路其实十分简单\n\n无符号变量len：记录字符串的长度\n无符号变量free：记录空闲内存的大小\nchar型数组buf：存储字符\n\n其中：buf尾部会自动追加一个空字符，遵循了c语言原生字符串的规范，并且SDS的指针也不是指向起始位置，而是指向buf，使得SDS可以直接使用一部分库函数。\nSDS取消了字节对齐，使得指针移动一位便可以读取到header里的信息。如果没有取消，这个移动的位数是未知的，就无法兼容C语言的库函数了，指针操作也要麻烦很多。\n数据结构优化：如果一个字符串非常短，但是记录信息的头部却占用了更多的空间，这未免有一些浪费，所以SDS会分为五种类型\n\n短字符串：小于32，用一个char类型的flag变量来记录长度，低三位存储类型，高三位存储长度\n短字符串：用一字节的char来记录长度，一字节的flag来记录类型\n长字符串：用2字节的short来记录长度，1字节的flag来记录类型\n长字符串：用4字节的int来记录长度\n超长字符串：用8字节的long来记录字符串\n\nSDS的最大长度：在3.X版本中，因为数据结构中的len属性是由int来修饰的，所以buf的最大长度就是214783647，即512MB\n但是在6.x版本后，长度就更多样了\nSDS相比原生string的优势：\nO(1)时间复杂度获取字符串的长度：因为C语言原生基本数据类型不记录自身长度，当要计算一个字符串的长度必须遍历整个字符串，直到遇到空字符为止，时间复杂度O(n)，而使用SDS则直接获取len属性即可，时间复杂度为O(1)\n二进制安全：在C语言中，用空字符表示字符串的结束，若字符串本身就包含空字符，那么遇到便会截断，即非二进制安全。与其相对的便是二进制安全，SDS使用len属性来判断字符串是否结束，不会受到空字符影响。\n杜绝缓冲区溢出：在C语言中，在对字符串进行拼接操作时，若没有给字符串分配足够的内存，那么就可能产生缓冲区溢出，把其他数据覆盖掉。而SDS的自动扩容机制杜绝了溢出，sdsMakeRoomFor方法：参数：原字符串，待加入的字符串。若空闲空间大于待拼接字符串的长度，则无需扩容；若拼接后的长度小于1M，则直接扩容至新长度的两倍；若拼接后的长度大于1M，则扩容至新长度+1M；扩容后检查类型，若发生变化，则需要为SDS重新分配内存（header的大小也改变了）\n优化的内存分配策略：预分配：扩容后的SDS不会恰好容下新字符串，而是多分配了一些空间，从而减少修改字符串时带来的内存重分配次数；惰性空间释放机制：当缩短字符串时，不会立刻回收空余的空间，而是仅仅更新len属性，空余空间供将来使用，减少内存分配频率，当然Redis也提供了释放未使用空间的方法sdsRemoveFreeSpace\n\nListRedis 的列表相当于 Java 语言里面的 LinkedList，这意味着List的插入和删除操作非常块，但是索引定位就比较慢了\nList支持先进先出（lpop）先进后出（rpop）\nList有两种实现方式：压缩列表和双向循环链表\nziplist节点的数据小于64字节，数据个数小于512个\n一般的数组都要求每一格的元素大小相同，但是若要存储不同大小的字符串，就需要以最大长度来作为元素大小，会造成一定程度的浪费。而压缩列表就是将元素紧凑，但是会在每个元素的头部追加一个len属性，这样就能很容易计算出下一个元素的内存地址。\n双向链表和linkedlist很相似，可以处理数据量较大的情况，每个节点包含value和前驱，后继节点的指针\nHash和JAVA里的hashmap类似，都是无序的键值对集合。\nhash也有两种实现方式，当数据量小的时候，使用压缩列表，当数据量大的时候，使用散列表。\nhash的底层和hashmap也差不多，都是数组+链表的二维结构，但是hash只能存储字符串，并且rehash的方式也不一样，redis为了保证高性能，采用渐进式的rehash方法，即在不断输入的任务以及hash操作中一步步将旧结构里的内容迁移到新结构中\nSET集合，存储一组不重复的数据，同样两种实现方法：有序数组（只用于处理整数）和散列表。前者是处理较少的数据，后者是处理大量数据。\nRedis的持久化因为redis的数据是在内存里，一旦断电或者宕机，数据便会丢失，所以必须保证数据不会因为故障而丢失\nRDB(redis database)即快照，在指定的时间间隔内将内存中的所有数据集快照写入磁盘\nRedis会单独创建fork一个子进程来进行持久化，依靠操作系统的COW机制（写入时复制，在client没有对数据进行写入时，子进程和主进程通过指针共享一个物理页面，当client对数据进行写入修改时，OS才会为页面创建副本，子进程将副本数据写入RDB，而这个过程仍然不影响主进程对数据的修改），fork进程内部的数据便是整个数据库的一个快照。当子进程完成对新RDB文件的写入时，便会拿其替换原来的RDB文件。\nfork 的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。 子进程读取数据，然后序列化写到磁盘中。\nRDB是对整个内存的数据进行快照，所以只有一个文件，这种方法适合大规模的数据恢复，而且很方便，因为OS只需要fork一个子进程，服务进程无需进行其他的IO操作，最大化保障redis的性能。\n但是RDB也有一些缺点：最后一次快照无法及时写入内存，可能会发生丢失，因为是由fork子进程来完成持久化，相当于克隆了一份内存数据，当数据集较大时，可能会影响整个服务器的性能。\nAOF(Append Only File)以日志的形式来记录写操作，只记录写指令，恢复时只需从前往后执行一遍即可完成数据恢复的工作。\n记录方式：写后日志：即在数据写入内存后再记录日志，让操作系统先执行命令，只有命令执行成功才能被记录，这种方式排除了错误的指令，并且不会阻塞当前的写操作。\n风险：若写入数据后未来得及记录日志便宕机，就会造成数据丢失。虽然避免了当前命令的阻塞，但是会给下一个操作带来阻塞 的风险，因为AOF日志是在主线程中进行的，写入磁盘时，磁盘的写压力大，可能会造成后序操作的阻塞。\n同步写回：每个操作完成后写回，会影响性能，但是可靠性高\n每秒写回：即每秒进行一次写回，性能适中，但是可能会丢失这一秒内的数据\n操作系统控制的写回：每个写完命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时写回磁盘。性能好，但是宕机时丢失的数据多\nRedis的事务redis是不支持回滚的：由程序员自行纠正编程错误，无回滚的方式保证了内部的简单快速\n以MULTI开始一个事务，将多个命令入队，入队后不会立即执行，而是放置在等待执行的队列里，由EXEC触发事务\n所有命令都会被序列化，顺序执行，执行过程中不会被其他客户端的命令打断\n在提交之前所有命令都不会被执行\n不保证原子性：有一条命令失败，其他的命令仍然会进行，没有回滚\nMYSQL关系型数据库，插件式的存储引擎，这种架构可以根据业务的需求和实际需要选择合适的存储引擎。\n\n客户端通过协议与服务器连接，发送查询语句，先检查缓存是否命中，若命中直接返回，否则进行语句解析\n预处理，检查语句是否有语法错误，查询优化（是否会使用索引扫描），生成查询计划，启动查询引擎，开始查询，底层存储引擎调用API获取数据，返回给客户端\nMYSQL默认使用B树索引\n\n索引索引的本质就是一个满足某种查找算法的数据结构，常见的有BST，AVL，红黑树，Btree，B+树等等\n这些结构以某种方式指向数据（索引结点指向数据记录物理地址的指针）\n\n索引大大减少了服务器需要扫描的数据量，提高了检索效率\n避免排序，减少CPU消耗\n将随机IO转换为顺序IO\n\n索引也是一张表，保存了主键和索引，指向了实体表，也需要占用内存。索引存储于外存，所以索引的查询也需要磁盘IO开销\n虽然提高了查询速度，但是在对实体表进行更新时，索引也需要进行相应的维护更新，而索引的维护也需要开销，降低了更新表的速度\nHASH索引：等值查询很快，计算的hash值与对应的行指针一并存入表中，哈希碰撞的元素以链表的形式相连。但是不支持范围查询，也不支持排序。所以应用场景少。\nB树考虑到IO时十分高昂的操作，且数据库动辄百万级数据量，所以当一次IO时，常常以页作为单位来读取数据，当读取一页的数据至内存缓冲区时，实际上才发生了一次IO，所以控制IO的次数对于索引效率的提升，至关重要。\nB+树的特点：\n\n除叶子结点外的子节点：只起到索引的作用，仅存储指针，不存储信息\n所有信息存储于叶子结点，所有叶子结点在底部链接形成一个线性链表\n\nMYSQL默认使用B+树：为啥要用B+树，不用B树\n因为两者都是存储于磁盘，而IO是花销很大的操作，innoDB每次申请磁盘空间时都会申请若干条连续的磁盘块来组成一页，并放入内存，读取索引，放回磁盘，不断重复，直到找到数据。所以如果每次申请到的数据都能有助于定位到所需数据，这将会减少IO次数，提高查询效率。\n对于B树，因为B树的每一个结点都会存储键和数据，每个结点的信息存储能力有限，树的高度也会更高，增加了IO次数。而B+树的非叶子结点只存储键，所以B+树的非叶子结点可以存储更多的信息，降低了树高度，平均一次IO可以获取更多索引，所以B+树更适合外存索引。其中在 MySQL 底层对 B+ 树进行进一步优化：叶子节之间是双向链表，节点内部是单向链表，且在链表的头结点和尾节点也是循环指向的。\n跳表skipList跳表是可以实现二分查找的有序链表，常用于redis的有序集合数据结构\n拥有与红黑树相近的查找，删除，插入效率，并且范围查找效率更优越\n原理在于为有序链表建立多级索引，从而实现跳跃查找，\n最底层包含所有元素，第一级索引包含1&#x2F;2的元素，以此类推。\n每个索引包含了一个指针数组，指向了该索引可以到达的所有节点，数组下标即当前指针所在的层数。\n通过生成随机数的方式，来为每一个插入的元素设定索引级数，从而无需重建整个索引，降低了时间复杂度\n","slug":"Redis随想","date":"2022-10-12T05:45:16.000Z","categories_index":"","tags_index":"数据库基础知识","author_index":"Samuel"},{"id":"1a1bb15f69c32b83456560735cf8e617","title":"JVM随笔","content":"JAVA内存区域讲解运行时数据区域分为两部分：线程共享和线程私有\n线程共享区域：\n\n堆：是虚拟机内存的最大的一块，此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存，注意是“几乎”，JDK1.7之后，当方法中的对象引用没有被返回或者未被外部使用，就会直接在栈上分配内存。同时，堆也是垃圾收集器管理的主要区域，所以也被称为GC堆。\nJDK1.8之前：方法区（运行时常量池）；JDK1.8之后：无，将方法区移至本地内存。方法区是运行时数据区域的一个逻辑区域，在不同虚拟上方法区的实现是不同的，当虚拟机要使用一个类时，它需要读取并解析class文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的类信息，字段信息，方法信息，常量，静态变量，即时编译器编译后的代码缓存。方法区有两种具体实现：永久代permanent gen和元空间metaspace。前者拥有一个由本身JVM设置的大小上限，无法调整，而在8版本之后，转而使用元空间，后者使用的是计算机的直接内存，溢出的概率更小。方法区包含运行时常量池和字符串常量池，后者是为了减少string类的内存消耗而专门开辟的，可以避免字符串的重复创建。方法区是一个公共且抽象的概念，在不同虚拟机上可以有不同的实现。\n\n线程私有区域：\n\n虚拟机栈：由一个个栈帧组成，栈帧内包含：局部变量表（存放可以编译器可以被识别的各种数据类型），操作数栈（作为方法调用的中转站，存放中间计算结果），动态链接（当一个方法需要调用其他方法时，动态链接就是未来将符号引用转换为调用方法的直接引用），方法返回地址。除了本地方法，其他所有方法的调用都是通过栈来实现。方法调用的数据通过栈进行传递，每一个方法没调用时都会有一个对应的栈帧被压入，每一个方法调用结束后，都会有一个栈帧被弹出。当函数调用陷入无限循环，或者压栈太多，导致线程请求的栈的深度超过JAVA虚拟机栈的最大深度时，就会抛出,stackoverflow。栈帧的弹出：return语句，异常抛出，随方法的调用而创建，随方法的结束而销毁，所以无论方法是否正常完成还是异常完成，都可以视为方法结束。\n本地方法栈：和虚拟机栈十分相似，但是本地方法是由c++编写的，所以这个栈是为native方法服务的，同样也会创建栈帧，同样也会抛出栈溢出的错误。\n程序计数器PC：一块较小的内存空间，就是一个计数器，可以看作是当前线程执行的字节码的行号指示器，字节码解释器通过改变PC的值来选取下一条要执行的字节码指令，从而实现循环，跳转，异常处理等功能。每个线程都需要一个独立的PC，PC也是唯一一个不会出现outofmemory的内存区域。\n\n类文件结构解析字节码：.class扩展名\n\n魔数：magic number：每个class文件的头4个字节被称为魔数（CAFEBABE）唯一作用便是确定这个文件是否为一个能被虚拟机接收的class文件\nclass文件版本号：小版本号+大版本号。高版本的JVM可以执行低版本的class文件\n常量池数量，常量池，常量池计数器从1开始，若有某些指向常量池的索引值需要表达“不引用常量池中的项目”这一含义，则可以将索引值设为0。常量池中主要存储两大常量：字面量：即文本字符串，或者被final修饰的常量等。符号引用：package，接口的全名，方法名称或描述符，字段名称或描述符等等。与c不同的是，java在编译时，不会有连接这一步骤，而是会在虚拟机加载class文件时进行动态连接，虚拟机在进行类加载时，将会从常量池中获得对应的符号引用，在类创建时或运行时解析，并翻译到具体的内存地址中。常量池中的每一项都是一个表。常量池可以看作是class文件里的资源仓库，占用空间最大。\n访问标志：用于识别类或者接口的访问信息，比如class是类还是接口，public还是abstract，是否被final修饰等\n索引集合：当前类，父类，接口索引集合\n字段表集合：描述接口或类中声明的变量，不包括方法内声明的局部变量\n方法表集合\n\n类加载过程加载加载主要完成下面三件事情\n\n通过全类名获取定义此类的二进制字节流\n将字节流代表的静态数据结构转换为方法区的运行时数据结构\n在内存中生成一个代表该类的class对象，作为方法区数据的访问入口\n\n连接——验证\n文件格式验证：是否符合class文件格式的规范（CAFEBABE），主次版本号是否在虚拟机的处理范围内，常量池中的的常量是否都可以支持\n元数据验证：对字节码的信息进行语义分析，保证描述的信息符合java的语言规范，比如这个类是否有父类，这个类是否继承了不被允许继承的类\n字节码验证：这是最为复杂的一个阶段，通过数据流和控制流的分析，确定程序语义是合法，符合逻辑的，比如确保任意时刻操作数栈都能配合工作\n符号引用验证：确保解析动作能正确执行\n\n连接——准备这个阶段会正式为变量分配内存并设置初始变量，仅包括类变量,static\n连接——解析将常量池里的符号引用替换为直接引用，主要针对，接口，字段，类方法。符号引用就是用一组符号来描述目标，可以是任何字面量；直接引用就是直接指向目标的指针，偏移量\n初始化这是类加载的最后一步，执行初始化方法，在这一步，JVM才真正开始执行类中定义的java程序代码\nHOTSPOT虚拟机对象创建的过程类加载检测虚拟机遇到new指令时，首先检查这条指令的参数是否能在常量池中定位到这个类的引用，检查这个符号引用代表的类是否已经被加载过，解析，或初始化。若没有，则先执行相应的类加载过程。\n分配内存为新对象分配内存，所需内存大小在类加载完成后就可以确定，分配内存的任务等同于将一块确定大小的内存从堆中划分出来。\n\n指针碰撞：堆内存规整，将用过的内存和没用过的内存整合到两边，中间有一个分界指针，只需要将指针移动相应大小即可完成分配。\n空闲列表：堆内存不规整，虚拟机会维护一个列表，列表中会记录哪些内存块是可用的，寻找到一块满足大小的内存分配后，更新列表。\n\n初始化零值当内存分配后，需要将分配到的内存空间都初始化为0值，这一步保证了对象的字段在java代码中可以不赋值就能直接被使用，程序能访问这些字段的数据类型对应的0值\n设置对象头这个对象是哪个类的实例，对象的hashcode，如何才能找到类的元数据信息，等信息处理后放入对象头中、\n执行init方法在虚拟机的视角来看，对象的创建已经完成，但是对于java程序来说，对象创建才刚刚开始，在init之前所有的字段都是零值，init之后便会将对象按照程序员的意愿进行初始化，一个真正可用的对象才算真正创建。\n","slug":"Java随想","date":"2022-10-12T04:37:43.000Z","categories_index":"","tags_index":"Java基础知识","author_index":"Samuel"}]