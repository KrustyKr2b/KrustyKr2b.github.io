[{"id":"a213144f9a961ec1d4584b73bef34320","title":"一篇关于锁的文章","content":"面试官：解释一下什么是乐观锁，悲观锁，自旋锁，读写锁，排它锁，共享锁，统一锁，分段锁这种问题虽然庞大复杂，但是千万不要被干沉默，能说清楚就是P5往上\n按抽象概念分悲观锁悲观地认为数据大概率会被其他线程操作，所以具有强烈的独占性和排它性\n比如synchronized，先加锁再执行代码块\n乐观锁相反，乐观地认为数据不大会被其他线程操作，所以先执行代码块，遇见线程冲突的情况，再补偿\n自旋锁自旋锁是乐观锁的一种实现形式，首先需要了解一些概念\nCAS操作：CAS全称为compare and swap，即比较和交换\n这是JDK提供的原子性操作。语义上是两步操作，但是CPU一条指令即可以完成，\nboolean compareAndSwapLong(Object obj,Long valueOffset,long expect,long update);\n//obj:对象的内存地址\n//valueOffset:偏移值\n//expect:期望的旧值\n//update:期望的新值\n\n如果对象中的变量值为expect，则使用新的值update替换expect\n替换成功，返回true；替换失败，即变量值不为expect，返回false；\n特点：非阻塞，即允许多个线程对共享资源进行修改，但是同一时刻只有一个线程可以进行写操作，其他线程并不是被阻塞，而是在不停重试拿到锁。\n这么做的原因：在JAVA中若一个线程没有拿到锁被阻塞，就会造成线程的上下文切换，大量线程的重新调度会造成性能的浪费。而volatile只能保证有序性和可见性，不能保证原子性。CAS就保证了原子性。\nABA问题：假如线程1使用CAS修改初始值为A的变量X&#x3D;A，那么线程1首先会获取当前变量X的值（A），然后使用CAS操作尝试修改X的值为B，如果使用CAS修改成功了，那么程序运行一定是正常的吗？\n其实未必，这是因为有可能在线程1获取到变量X的值A后，在执行CAS之前，线程2使用了CAS修改了变量X值为B，然后又使用了CAS操作使得变量X值为A，虽然线程A执行了CAS操作时X&#x3D;A，但是这个A已经不是线程1获取到的A了。这就是ABA问题。\nABA问题的产生是因为变量的状态值产生了环形转换，就是变量值可以从A到B，也可以B到A，如果变量的值只能朝着一个方向转换，例如A到B，B到C，不构成环路，就不会存在这个问题。\nJDK中的AtomicStampedReference类给每个变量的状态值都配备了一个时间戳，从而避免了ABA问题。或者是使用版本号，一个数据一个版本号，版本号不同数据值相同，也不会进行修改。\n所以自旋锁便是通过CAS来实现的，在获取锁的时候使用while循环不断进行CAS操作，类似于不断旋转，直到操作成功返回true，在释放锁的时候使用CAS将锁的状态从1变成0。\n按读写属性分排他锁又称写锁，X锁，只有一个线程能访问代码块，synchronized关键字即是排他锁。写的时候，不允许其他线程读，也不允许其他线程写\n共享锁又称读锁，S锁，可以有多个线程访问代码块，允许同时读，不允许写，必须等所有锁释放后才可以写\n读写锁概念同上\n按粒度分统一锁大粒度的锁，防止出现死锁。\n锁定A线程，等待B线程；锁定B，等待A；\n若没有很好地同步，就会出现死锁\n统一锁便是将A和B统一为一个大锁\n分段锁JDK1.7 ConcurrentHashMap\nHashMap是一个很长的链表，所以如果并发插入数据时，如果每次都锁定整个链表，性能会很差\n所以需要加入一种粒度较小的锁，即在一个桶内放入数据时，只锁定一段，而不是整个链表。\n当锁定一段时，不影响其他段的数据插入，提高了效率，缺点，代码实现复杂\n","slug":"一篇关于锁的文章","date":"2022-10-19T08:28:53.000Z","categories_index":"","tags_index":"面试突击","author_index":"Samuel"},{"id":"db91e78c8da8e89de1c0960e4a35ed33","title":"字典序问题","content":"给你一个整数 n ，按字典序返回范围 [1, n] 内所有整数。\n你必须设计一个时间复杂度为 O(n) 且使用 O(1) 额外空间的算法。\n示例 1：\n输入：n &#x3D; 13\n输出：[1,10,11,12,13,2,3,4,5,6,7,8,9]\n\n思路：字典序的构建可以看成是一支十叉树\n第一层是1位数字，第二层是2位数字，以此类推。\n而十叉树的前序遍历即是字典序的输出\nclass Solution &#123;\n    List&lt;Integer> ans = new ArrayList&lt;>();\n    public List&lt;Integer> lexicalOrder(int n) &#123;\n        //从第一层开始\n        for (int cur = 1; cur &lt;= 9; cur++) recursion(cur, n);\n        return ans;\n    &#125;\n    void recursion(int cur, int limit) &#123;\n        //前序遍历的终止条件\n        if (cur > limit) return ;\n        ans.add(cur);\n        //进入下一层\n        for (int i = 0; i &lt;= 9; i++) recursion(cur * 10 + i, limit);\n    &#125;\n&#125;\n\n给定整数 n 和 k，返回 [1, n] 中字典序第 k 小的数字\n输入: n &#x3D; 13, k &#x3D; 2\n输出: 10\n解释: 字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。\n\n思路：其实按照第一题的思路可以解决，但是如果n十分巨大，全部遍历一遍会造成超时。\n所以无需全部遍历，只需比较该节点下的子节点总数与k的大小即可\n比较节点数与k的大小来判断是否需要进入子树，还是进入兄弟节点的子树\n但是需要解决的问题是，有一些子树的节点不是满的，所以计算nodeCount时需要分情况\nclass Solution &#123;\n    public int findKthNumber(int n, int k) &#123;\n        //从第一层的第一个节点开始扫描\n        int cur =1;\n        k--;\n        //当k==0时，证明找到节点\n        while(k>0)&#123;\n            long left = cur;\n            long right = cur+1;\n            int nodeCount = 0;\n            //统计cur节点下所有子树的节点数\n            while(left&lt;=n)&#123;\n                nodeCount+=Math.min(right,(int)(n+1))-left;\n                left*=10;\n                right*=10;\n            &#125;\n            //不在cur节点下，进入另一个节点\n            if(nodeCount&lt;=k)&#123;\n                k-=nodeCount;\n                cur++;\n            &#125;\n            else&#123;\n                //在cur节点下，进入cur的子树\n                k--;\n                cur*=10;\n            &#125;\n        &#125;\n        return cur;\n    &#125;\n&#125;\n\n","slug":"字典序问题","date":"2022-10-19T05:30:33.000Z","categories_index":"","tags_index":"LeetCode初见","author_index":"Samuel"},{"id":"d1863bbf8aa3ec7bc32e4a0f3476163f","title":"线程池","content":"何为线程池：一种多线程的处理形式，处理过程中可以将任务添加到队列中，然后在创建线程后自动启动这些任务。\n线程池的优势：\n线程和任务分离，线程可被重用，提升复用性\n控制线程并发数量，统一管理，降低服务器压力\n提升系统响应速度，因为线程池内的线程可以被复用，且线程池内有核心线程待命，所以就减少了创建线程和销毁线程的时间。\n\n应用场景：网购商品秒杀，云盘文件上传，旅行系统购票等等\n解析//构造方法:\npublic ThreadPoolExecutor(int corePoolSize, //核心线程数量\n                              int maximumPoolSize,//     最大线程数\n                              long keepAliveTime, //       最大空闲时间\n                              TimeUnit unit,         //        时间单位\n                              BlockingQueue&lt;Runnable> workQueue,   //   任务队列\n                              ThreadFactory threadFactory,    // 线程工厂\n                              RejectedExecutionHandler handler  //  饱和处理机制\n\t) \n\n参数解释：\n\ncorePoolSize : 指空闲也不允许被销毁的线程，随时待命存放于线程池中\nmaximumPoolSize：指最大线程数，当任务队列满时，需要创建临时进程处理无法进入任务队列的任务。当临时进程空闲时，会被销毁\nkeepAliveTime&amp;TimeUnit：最大空闲时间和时间单位，当临时进程空闲时间超过最大空闲时间后，便会被销毁\nBlockingQueue：任务队列，当核心线程均不空闲时，任务进入队列等待。队列就是一种容器，可以用多种数据结构实现，常见的有ConcurrentMap,PriorityQueue,ArrayBlockingQueue等等。永远推荐使用有界队列，即由数组实现的队列，并设立合理的长度。避免造成等待任务过多消耗系统资源。\nThreadFactory ：线程工厂，手动命名创建线程的工厂，方便抛出错误后定位相应线程池\nRejectedExecutionHandler：拒绝策略，当任务队列满且所有线程均不空闲时，启用饱和处理机制\n\n如何确定核心线程数，最大线程数，任务队列长度核心线程数：IO密集型：CPU数*2；CPU密集型：CPU数+1\n最大线程数：(每秒产生的最大任务数-任务队列长度)*单个任务执行时间\n任务队列长度：核心线程数&#x2F;单个任务执行时间*2\n饱和处理机制有哪些\nAbortPolicy：丢弃任务并抛出异常\nDiscardPolicy：丢弃任务不抛出异常\nDiscardOldestPolicy：丢弃最前面的任务，然后重新提交被拒绝的任务\nCallerRunsPolicy：直接调用线程处理该任务\n\n","slug":"线程池","date":"2022-10-18T12:33:43.000Z","categories_index":"","tags_index":"面试突击","author_index":"Samuel"},{"id":"626084d3a58b4f97f22000ce81567720","title":"每日一问10/17/2022","content":"Q1:String,StringBuilder,StringBuffer的区别答：\n\nString的底层是一个由final修饰的char型数组，String是静态只读的，当改变变量的值时，其实只是改变了引用对象的指向，指向了新创建的字符串，而原字符串仍存在于字符串常量池。\nStringBuffer（JDK1.0引入）：引用对象指向一个空间，包含一个可自行扩容的char型数组和字符串长度计数变量Count，StringBuffer的所有方法均被synchronized修饰。扩容时会开辟一块新的空间用于创建更大的数组，并将原数据复制过去，并改变引用对象的指向。\nStringBuilder(JDK1.5引入)：取消了synchronized方法修饰，所以效率更高，但是线程不安全。\n\nQ2:HashMap如何保证线程安全答：\n\nCollections.synchronizedMap()方法传入HashMap的引用变量，返回一个新的Map，这个新的Map就是线程安全的，返回的并不是HashMap，而是map的一种实现。该方法封装了所有不安全的HashMap方法，使用了synchronized方法来进行互斥。该方法使用代理模式new了一个新的类，这个类实现了Map接口。该方法的优点：实现简单；缺点：加锁的粒度较大，性能比较差；\n使用ConcurrentHashMap，使用了新的锁机制，把hashmap拆分成了多个独立的块，这样在高并发的情况下减少了锁冲突的可能。使用的是NonfairSync，这个特性调用CAS指令来保证原子性和互斥性。如果多个线程恰好操作到同一个segment，只有一个线程得到运行。优点：互斥的代码段小，性能更好，发生锁碰撞的几率低。缺点：代码繁琐。\n\nQ3：JAVA类加载器是啥答：\n\nBootstrap类加载器：即引导类加载器，由C++语言实现，无父类。主要加载的是JVM自身需要的类，是虚拟机自身的一部分，它负责&#x2F;lib路径下的核心类库或-Xbootclasspath参数指定的路径下的jar包加载到内存中，虚拟机按照文件名识别jar包，处于安全考虑，启动类加载器只加载包名为java,javax,sun等开头的jar包，即使将不符合要求的jar包丢入lib目录下也没法被识别。\nExtention类加载器：即扩展类加载器，是指sun公司实现的ExtClassLoader类，由Java语言实现，父类加载器为null，是Launcher中的静态内部类，它负责加载&#x2F;lib&#x2F;ext目录或者由系统变量-Djava.ext.dir指定位路径中的类库，开发者可以直接使用标准扩展类加载器。\nApplication类加载器：即应用程序加载器，是指sun公司实现的appClassLoader，父类加载器为扩展类加载器。它负责加载class-path指定路径下的库类，也就是我们经常用到的classpath，一般情况下该类加载是程序中默认的类加载器。\nCustom自定义类加载器：负责加载用户自定义路径下的类包，父类加载器为应用程序加载器\n\n类加载器的三大特征：\n\n委托性：即双亲委派机制，当类A被加载时，首先会委托给父类加载器。引导类加载器会在lib目录下查找是否存在，找到便加载，未找到便回到扩展类加载器。扩展类加载器会在&#x2F;lib&#x2F;ext目录下查找，找到便加载，未找到便回到应用程序加载器。应用程序加载器会在classPath路径下查找，找到则加载，未找到则抛出ClassNotFoundException异常\n可见性：父类加载器加载的类可以被子类观察到，但是子类加载的类对父类不可见\n一个类只可以被加载一次\n\n双亲委派机制：\n\n","slug":"每日一问10-17-2022","date":"2022-10-17T13:16:32.000Z","categories_index":"","tags_index":"面试突击","author_index":"Samuel"},{"id":"8420d36b5907c1ed250973ab1271d588","title":"微软面试题——24点游戏","content":"给定一个长度为4的整数数组 cards 。你有 4 张卡片，每张卡片上都包含一个范围在 [1,9] 的数字。您应该使用运算符 [&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;] 和括号 &#39;(&#39; 和 &#39;)&#39; 将这些卡片上的数字排列成数学表达式，以获得值24。\n输入: cards &#x3D; [4, 1, 8, 7]\n输出: true\n解释: (8-4) * (7-1) &#x3D; 24\n\n显而易见是回溯，但是由于题中给出除法是实数除法，所以必须使用double来进行计算\nclass Solution &#123;\n    static double Target = 24;\n    //浮点数误差最小精度\n    static double standard = 1e-6;\n    public boolean judgePoint24(int[] cards) &#123;\n        return backTrack(new double[]&#123;cards[0],cards[1],cards[2],cards[3]&#125;);\n    &#125;\n    boolean backTrack(double[] nums)&#123;\n        //若最终结果与target的差值小于某一数值，则证明相等\n        if(nums.length ==1 )return Math.abs(nums[0]-Target)&lt;standard;\n        for(int i =0;i&lt;nums.length;i++)&#123;\n            for(int j = i+1;j&lt;nums.length;j++)&#123;\n                //建立一个数组，存储除选中的两个数以外的所有数和这两个数的运算结果\n                double[] next = new double[nums.length-1];\n                for(int k=0,index=0;index&lt;nums.length;index++)&#123;\n                    if(index!=i&amp;&amp;index!=j) next[k++] = nums[index];\n                &#125;\n                //决策树选择\n                for(double num:caculator(nums[i],nums[j]))&#123;\n                    next[next.length-1] = num;\n                    if(backTrack(next)) return true;\n                &#125;\n            &#125;\n        &#125;\n        return false;\n    &#125;\n    //存储两个数可以获得的所有运算结果\n    ArrayList&lt;Double> caculator(double a, double b)&#123;\n        ArrayList&lt;Double> list = new ArrayList();\n        list.add(a*b);\n        list.add(a+b);\n        list.add(a-b);\n        list.add(b-a);\n        //若a绝对值小于精度，则可以认为a为零\n        if(!(Math.abs(a)&lt;standard)) list.add(b/a);\n        if(!(Math.abs(b)&lt;standard)) list.add(a/b);\n        return list;\n    &#125;\n&#125;\n\n","slug":"微软面试题——24点游戏","date":"2022-10-16T11:58:26.000Z","categories_index":"","tags_index":"LeetCode初见","author_index":"Samuel"},{"id":"12f7852204c389ace8749b92fea05496","title":"周赛笔记10/16/2022","content":"6204. 与对应负数同时存在的最大正整数给你一个 不包含 任何零的整数数组 nums ，找出自身与对应的负数都在数组中存在的最大正整数 k \n输入：nums &#x3D; [-1,2,-3,3]\n输出：3\n解释：3 是数组中唯一一个满足题目要求的 k 。\n\n一个HashSet+一遍遍历，秒解\nclass Solution &#123;\n    public int findMaxK(int[] nums) &#123;\n        HashSet&lt;Integer> set = new HashSet&lt;>();\n        int res = Integer.MIN_VALUE;\n        for(int n:nums)&#123;\n            if(set.contains(-n)) res = Math.max(res,Math.abs(n));\n            set.add(n);\n        &#125;\n        return res==Integer.MIN_VALUE?-1:res;\n    &#125;\n&#125;\n\n6205. 反转之后不同整数的数目给你一个由正整数组成的数组nums 。\n你必须取出数组中的每个整数，反转其中每个数位，并将反转后得到的数字添加到数组的末尾。这一操作只针对 nums 中原有的整数执行。\n返回结果数组中不同整数的数目。\n输入：nums &#x3D; [1,13,10,12,31]\n输出：6\n解释：反转每个数字后，结果数组是 [1,13,10,12,31,1,31,1,21,13] 。\n反转后得到的数字添加到数组的末尾并按斜体加粗表示。注意对于整数 10 ，反转之后会变成 01 ，即 1 。\n数组中不同整数的数目为 6（数字 1、10、12、13、21 和 31）\n\n同样一个HashSet+一遍遍历，秒解\nclass Solution &#123;\n    public int countDistinctIntegers(int[] nums) &#123;\n        HashSet&lt;Integer> set = new HashSet();\n        for(int num : nums)&#123;\n            if(num==1) &#123;\n                set.add(num);\n                continue;\n            &#125;\n            set.add(num);\n            int n =0;\n            while(num!=0)&#123;\n                n=n*10+num%10;\n                num/=10;\n            &#125;\n            set.add(n);\n        &#125;\n        return set.size();\n    &#125;\n&#125;\n\n6219. 反转之后的数字和输入：num &#x3D; 443\n输出：true\n解释：172 + 271 &#x3D; 443 ，所以返回 true 。\n\n我以为我的方法很笨，但是发现大家都是同样的解法…\nclass Solution &#123;\n    public boolean sumOfNumberAndReverse(int num) &#123;\n        if(num==0) return true;\n        for(int i=1;i&lt;=num;i++)&#123;\n            if((i+reverseNum(i))==num) return true;\n        &#125;\n        return false;\n    &#125;\n    int reverseNum(int num)&#123;\n        int n =0;\n        while(num!=0)&#123;\n            n=n*10+num%10;\n            num/=10;\n        &#125;\n        return n;\n    &#125;\n&#125;\n\n6207. 统计定界子数组的数目给你一个整数数组 nums 和两个整数 minK 以及 maxK 。\nnums 的定界子数组是满足下述条件的一个子数组：\n子数组中的最小值等于 minK\n子数组中的最大值等于 maxK\n返回定界子数组的数目。\n子数组是数组中的一个连续部分\n输入：nums &#x3D; [1,3,5,2,7,5], minK &#x3D; 1, maxK &#x3D; 5\n输出：2\n解释：定界子数组是 [1,3,5] 和 [1,3,5,2] 。\n\n发呆一小时，没写出来…\n看了好几个解析，写了一个自己的解法，然后有一些自己的理解\nclass Solution &#123;\n public long countSubarrays(int[] nums, int minK, int maxK) &#123;\n        int n = nums.length;\n        long res = 0;\n        int left = 0, minIndex = -1, maxIndex = -1;\n        for (int i = 0; i &lt; n; i++) &#123;\n            //定位出现最大最小值的索引\n            if (nums[i] == minK) minIndex = i;\n            if (nums[i] == maxK) maxIndex = i;\n            //刚进来的数影响了最大值或最小值\n            if (nums[i] &lt; minK || nums[i] > maxK) &#123;\n                //将left定位到刚好不出现越界值的位置\n                left = i + 1;\n                minIndex = maxIndex = -1;\n                //当窗口内同时包含最大值和最小值时，更新结果\n            &#125; else if (minIndex != -1 &amp;&amp; maxIndex != -1) &#123;\n                int min = Math.min(minIndex, maxIndex);\n                res += min - left + 1;\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;\n\n","slug":"周赛笔记10-16-2022","date":"2022-10-16T08:06:31.000Z","categories_index":"","tags_index":"LeetCode初见","author_index":"Samuel"},{"id":"22f311f06a9cae50742dc4cb95ef15a1","title":"子序列数目","content":"输入：s &#x3D; &quot;abc&quot;\n输出：7\n解释：7 个不同的子序列分别是 &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;ab&quot;, &quot;ac&quot;, &quot;bc&quot;, 以及 &quot;abc&quot;。\n\n难度：hard\nclass Solution &#123;\n    //状态转移方程真的不好写，所以我不想用动态规划\n    //思路：以c结尾的子串数目等于：以c之前的所有字母结尾的子序列数目的总和+1\n    public int distinctSubseqII(String s) &#123;\n        char[] arr = s.toCharArray();\n        int n = arr.length;\n        int[] alphaBet  = new int[26];\n        for(int i=0;i&lt;n;i++)&#123;\n            long sum = 0;\n            //求总和\n            for(int j:alphaBet)sum=(sum+j)%1000000007;\n            //+1即加上自身\n            alphaBet[arr[i]-'a'] = (int)sum+1;\n        &#125;\n        long res = 0;\n        for(int i : alphaBet) res = (res+i)%1000000007;\n        return (int)res;\n    &#125;\n&#125;\n","slug":"子序列数目","date":"2022-10-14T14:28:37.000Z","categories_index":"","tags_index":"LeetCode初见","author_index":"Samuel"},{"id":"91683efeeb5b4f823eb3ffc7a800c9f1","title":"每日一问10/14/2022","content":"Q1：接口和抽象类有哪些区别答：\n相同点：\n\n不能被实例化\n可以将抽象类和接口类型作为引用类型\n一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部实现\n\n不同点：\n\n抽象类中可以定义构造器，可以有抽象方法和具体方法，抽象类中可以定义成员变量，一个类只能继承一个抽象类，抽象类中可以包含静态方法，抽象类中的成员可以由private,protected,public修饰\n接口中的成员全部都是由public修饰，不能定义构造器，只能有抽象方法，不能有静态方法，一个类可以实现多个接口\n\n除了语法上的异同之外，两者还有语义上的不同。抽象类适合描述某一更具体的概念，比如狗是一种动物，而不能说狗实现了动物的接口。接口则用于描述多个事物的共同特征，比如鸟实现了flyable接口，这个flyable就是一种行为特征，当然也可以描述其他的特征。\nQ2：HashCode()和equals()的关系，如何使用？答：\n\nequals()来自Object()类，默认使用&#x3D;&#x3D;来比较地址值，判断引用指向是否是一个对象。通过重写该方法来定义新的规则，比如String类中的equals方法就是逐个比较字符串的字符\nHashCode()来自Object()类，这是一个本地方法，在没有被重写时默认返回对象在堆内存上的独特值，可以认为是对象在堆内存中的身份证号，具有唯一性。重写HashCode后，可以返回计算而出的哈希值，即散列算法，用于确定元素的桶位置，例如HashMap\n如何使用：查找一个元素，当调用散列算法后，快速定位到相应位置，若该桶内有元素，则调用equals()，由于哈希碰撞的存在，HashCode()相等时，不一定就是相应的元素，所以必须调用equals()来判断是否为要查找的元素\n\nQ3：&#x3D;&#x3D;和equals的区别答：\n&#x3D;&#x3D;：若比较的是基本数据类型，则比较的是数值是否相等；如果比较的是引用数据类型，则比较的是地址值\nequals()：用来比较引用指向的对象地址是否相等。不可用于基本数据类型的比较。\n在Object类中，equals就是由&#x3D;&#x3D;来实现的，可以认为equals在被重写前，两者作用是相等的\nQ4：HashMap为什么是线程不安全的答：\nJAVA7可能造成死循环：由于resize时的数据迁移采用头插法（当时的人觉得比较高效），而头插法会导致链表顺序颠倒（因为先插入的元素在后面），当线程A未完成transfer操作时被挂起，而线程B成功完成了transfer操作，线程A再次获取时间片后继续执行transfer，由于头插法导致链表顺序颠倒，便有可能导致生成环形链表。\nJAVA8可能造成数据丢失：假设两个线程A、B都在进行put操作，并且hash函数计算出的插入下标是相同的，当线程A执行过程中由于时间片耗尽导致被挂起，而线程B得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程A获得时间片，由于之前已经进行了hash碰撞的判断，所有此时不会再进行判断，而是直接进行插入，这就导致了线程B插入的数据被线程A覆盖了，从而线程不安全。\n","slug":"每日一问10-14-2022","date":"2022-10-14T06:56:54.000Z","categories_index":"","tags_index":"面试突击","author_index":"Samuel"},{"id":"cfe019c4b3b720ab570d0b0eea78733d","title":"每日一问10/13/2022","content":"Q1：Object o = new Object()在内存中占用多少个字节？答：\n一个对象在内存中的存储布局：markword：8字节，锁信息+HashCode+GC信息；classPointer:4字节；对齐：保证大小能被8整除；数据段：即对象内声明的变量\n所以一个空对象最小为16字节\nQ2：对象如何定位？答：\nHotSpot虚拟机默认使用直接定位：指针直接指向堆内存内的对象，对象内的classPointer指向方法区内的class。优点：直接访问快；缺点：GC时，若需要移动对象，则指针也需要改变\n句柄方式（间接方式）：指针指向另一个结构体，该结构体内有两个指针，分别指向堆内存和方法区。优点：对象小，GC时无需改动指针。缺点：比直接访问更慢\nQ3：对象的创建过程答：\nnew指令：申请内存空间，为成员变量设立默认值\ninvokespecial汇编码：调用构造方法，为成员变量设定初始值\nastore汇编码：建立引用，让指针指向堆\nQ4：面向对象有哪些特征答：\n面向对象是一种编程思想，即万物皆可归类抽象，万物皆可对象；有三大特征\n\n封装：类与外界的封装关系，即隐藏类内部的实现机制，对外部而言，它的内部细节是隐藏的，只暴露了自身的访问方法。使用者按照既定的方式来调用方法，不必关心方法的内部实现，便于使用，增强了代码的可维护性。\n继承：类与类的关系，即从已有的类中派生出新的类，即子类与父类，也可以称作超类和基类。从多个类中抽象出一个基类，使其具备多个类的共同特性，使用extends关键字继承某个类后，就具备了父类的属性，并扩展新的属性。在父类中使用private关键字来限制不会被继承。\n多态：多个类的关系，必备的三个要素：继承，重写，父类引用指向子类对象\n\nQ5：ArrayList与LinkedList的区别答：\n\nArrayList是基于索引的数据接口，底层是数组，可以在常数级的复杂度对元素进行随机访问。而LinkedList是基于Node对象列表的形式存储数据，底层是一个双向链表，查找元素是O（n）。因此LinkedList的插入，添加，删除操作，总体上会更快，因为不是数组，不需要移动元素，重新计算索引和大小，但是LinkedList更占内存，因为每一个node都会封装前驱指针和后继指针。\n如果你需要经常随机访问数据，更加推荐使用ArrayList；如果需要经常插入删除元素，推荐使用LinkedList。\n多提一嘴：其实总体上ArrayList性能其实更加优越一些。第一，LinkedList的每一个node都有指针，更占内存，第二：虽然LinkedList的头插效率很高，但是尾插效率却不见得十分高效，因为数组的尾插无需进行拷贝和移位，而链表则需要创建node对象。并且有人测试过，在数据量较大时，链表的中间插入仍会比ArrayList耗时更多。所以俺还是无脑选择ArrayList~\n\n","slug":"每日一问10-13-2022","date":"2022-10-13T12:41:31.000Z","categories_index":"","tags_index":"面试突击","author_index":"Samuel"},{"id":"412f186990736c43d33166b6535da85e","title":"周赛笔记10/9/2022","content":"2432. 处理用时最长的那个任务的员工输入：n &#x3D; 10, logs &#x3D; [[0,3],[2,5],[0,9],[1,15]]\n输出：1\n解释：\n任务 0 于时刻 0 开始，且在时刻 3 结束，共计 3 个单位时间。\n任务 1 于时刻 3 开始，且在时刻 5 结束，共计 2 个单位时间。\n任务 2 于时刻 5 开始，且在时刻 9 结束，共计 4 个单位时间。\n任务 3 于时刻 9 开始，且在时刻 15 结束，共计 6 个单位时间。\n时间最长的任务是任务 3 ，而 id 为 1 的员工是处理此任务的员工，所以返回 1 。\n\n突发奇想，想练习一下sort方法的运用熟练程度\nclass Solution &#123;\n    public int hardestWorker(int n, int[][] logs) &#123;\n        for(int i=logs.length-1;i>=0;i--)&#123;\n            if(i==0) break;\n            else logs[i][1]-=logs[i-1][1];\n        &#125;\n        Arrays.sort(logs,(a,b)->&#123;\n            if(b[1]!=a[1])return b[1]-a[1];\n            else return a[0]-b[0];\n        &#125;);\n        return logs[0][0];\n    &#125;\n&#125;\n\n2433. 找出前缀异或的原始数组输入：pref &#x3D; [5,2,0,3,1]\n输出：[5,7,2,3,2]\n解释：从数组 [5,7,2,3,2] 可以得到如下结果：\n- pref[0] &#x3D; 5\n- pref[1] &#x3D; 5 ^ 7 &#x3D; 2\n- pref[2] &#x3D; 5 ^ 7 ^ 2 &#x3D; 0\n- pref[3] &#x3D; 5 ^ 7 ^ 2 ^ 3 &#x3D; 3\n- pref[4] &#x3D; 5 ^ 7 ^ 2 ^ 3 ^ 2 &#x3D; 1\n\n寻找数学规律即可，只不过确实需要自己写例子推导一下\nclass Solution &#123;\n    public int[] findArray(int[] pref) &#123;\n        int n = pref.length;\n        int[] res = new int[n];\n        if(n&lt;=1) return pref;\n        res[0] = pref[0];\n        for(int i=0,p=1;i&lt;n-1&amp;&amp;p&lt;n;i++)&#123;\n                int j = i+1;\n                res[p++] = pref[i]^pref[j];\n            &#125;\n        return res;\n        &#125;\n&#125;\n\n2435. 矩阵中和能被 K 整除的路径给你一个下标从 0 开始的 m x n 整数矩阵 grid 和一个整数 k \n你从起点 (0, 0) 出发，每一步只能往下或者往右 ，你想要到达终点 (m - 1, n - 1) 。\n\n请你返回路径和能被 k 整除的路径数目，由于答案可能很大，返回答案对 109 + 7 取余 的结果。\n\n我刚开始觉得应该是回溯，因为是图的路径问题，但是有几个用例总是无法通过\n最后看解析才发现需要使用DP，确实有点难，特别是状态转换方程的推导\nclass Solution &#123;\n    public int numberOfPaths(int[][] grid, int k) &#123;\n        int m = grid.length;\n        int n = grid[0].length;\n        //记忆化搜索\n        int[][][] c = new int[m][n][k];//记录dp值\n        c[0][0][grid[0][0]%k]++;//记录第一个元素dp值\n        for(int i=1; i&lt;m; i++)&#123;//记录第一列元素dp值\n            for(int l = 0; l&lt;k; l++)&#123;\n                c[i][0][(l+grid[i][0])%k] += c[i-1][0][l];\n            &#125;\n        &#125;\n        for(int j=1; j&lt;n; j++)&#123;//记录第一行元素dp值\n            for(int l = 0; l&lt;k; l++)&#123;\n                c[0][j][(l+grid[0][j])%k] += c[0][j-1][l];\n            &#125;\n        &#125;\n        for(int i=1; i&lt;m; i++)&#123;//记录其他元素dp值\n            for(int j=1; j&lt;n; j++)&#123;\n                for(int l = 0; l&lt;k; l++)&#123;\n                    c[i][j][(l+grid[i][j])%k] += c[i-1][j][l];\n                    c[i][j][(l+grid[i][j])%k] += c[i][j-1][l];\n                &#125;\n                for(int l = 0; l&lt;k; l++)&#123;//避免整数溢出\n                    if(c[i][j][l] >= 1000000007) c[i][j][l] -=1000000007 ;\n                &#125;\n            &#125;\n        &#125;\n        return c[m-1][n-1][0];\n    &#125;\n&#125;\n\n","slug":"周赛笔记10-9-2022","date":"2022-10-09T05:25:50.000Z","categories_index":"","tags_index":"LeetCode初见","author_index":"Samuel"},{"id":"bdd0b34d75b797c3e041acb9ccf9384c","title":"位运算技巧","content":"//位运算算法技巧\n//不用临时变量交换两个数\na ^= b;\nb ^= a;\na ^= b;\n//判断是否异号（同号）\nboolean f = ((x ^ y) &lt; 0);\n//利用或操作 | 和空格将英文字符转换为小写\n('A' | ' ') = 'a';\n//利用与操作 &amp; 和下划线将英文字符转换为大写\n('b' &amp; '_') = 'B';\n//利用异或操作 ^ 和空格进行英文字符大小写互换\n('D' ^ ' ') = 'd';\n//去掉最后一位1\nn &amp; (n-1);\n//异或运算的特殊性质,异或运算满足交换律和结合律\na ^ a = 0;\na ^ 0 = a;\n//取反码+与运算\nx &amp; ~x = 0;\nx &amp; ~0 =x;\n\n","slug":"位运算技巧","date":"2022-10-02T04:59:51.000Z","categories_index":"","tags_index":"算法归纳","author_index":"Samuel"},{"id":"8a33ad4dd9e973b50a7c9fd8c1c572f8","title":"划分k个相等子集","content":"输入： nums &#x3D; [4, 3, 2, 3, 5, 2, 1], k &#x3D; 4\n输出： True\n说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和\n\n桶问题：若可以划分为k个子集，则想象有k个桶，容量均为sum&#x2F;k，如果我们刚好将桶装满，则返回true，否则返回false\nclass Solution &#123;\n    int sum =0;\n    public boolean canPartitionKSubsets(int[] nums, int k) &#123;\n        if(!isValid(nums,k)) return false;\n        //对数组排序，从后向前搜索\n        Arrays.sort(nums);\n        if(nums[nums.length-1]>sum/k) return false;\n        sum/=k;\n        int[] arr = new int[k];\n        //建立桶的数据结构\n        Arrays.fill(arr,sum);\n        return(backTrack(nums,k,arr,nums.length-1));\n    &#125;\n    boolean isValid(int[] nums, int k)&#123;\n        for(int val : nums) sum+=val;\n        if(sum%k!=0) return false;\n        return true;\n    &#125;\n    boolean backTrack(int[] nums, int k,int[] arr,int cur)&#123;\n        if(cur&lt;0) return true;// cur走到-1时，说明所有的数全部都放进桶里了。这时一定是true\n        for(int i=0;i&lt;k;i++)&#123;\n            //i遍历每一个桶，判断cur指向的数可以放入哪一个桶\n            if(arr[i]==nums[cur]||arr[i]-nums[cur]>=nums[0])&#123;\n                arr[i]-=nums[cur];\n                if(backTrack(nums,k,arr,cur-1)) return true;\n                arr[i]+=nums[cur];\n            &#125;\n        &#125;\n        return false;\n    &#125;\n&#125;\n\n","slug":"划分k个相等子集","date":"2022-09-27T13:57:25.000Z","categories_index":"","tags_index":"LeetCode初见","author_index":"Samuel"},{"id":"2181d0c3b44c85661e4d1e16727307c2","title":"Redis随想","content":"RedisSDS结构模型基于C语言，由Redis封装的一种简单高效安全的数据结构\n源码分析SDS的底层实现思路其实十分简单\n\n无符号变量len：记录字符串的长度\n无符号变量free：记录空闲内存的大小\nchar型数组buf：存储字符\n\n其中：buf尾部会自动追加一个空字符，遵循了c语言原生字符串的规范，并且SDS的指针也不是指向起始位置，而是指向buf，使得SDS可以直接使用一部分库函数。\nSDS取消了字节对齐，使得指针移动一位便可以读取到header里的信息。如果没有取消，这个移动的位数是未知的，就无法兼容C语言的库函数了，指针操作也要麻烦很多。\n数据结构优化：如果一个字符串非常短，但是记录信息的头部却占用了更多的空间，这未免有一些浪费，所以SDS会分为五种类型\n\n短字符串：小于32，用一个char类型的flag变量来记录长度，低三位存储类型，高三位存储长度\n短字符串：用一字节的char来记录长度，一字节的flag来记录类型\n长字符串：用2字节的short来记录长度，1字节的flag来记录类型\n长字符串：用4字节的int来记录长度\n超长字符串：用8字节的long来记录字符串\n\nSDS的最大长度：在3.X版本中，因为数据结构中的len属性是由int来修饰的，所以buf的最大长度就是214783647，即512MB\n但是在6.x版本后，长度就更多样了\nSDS相比原生string的优势：\nO(1)时间复杂度获取字符串的长度：因为C语言原生基本数据类型不记录自身长度，当要计算一个字符串的长度必须遍历整个字符串，直到遇到空字符为止，时间复杂度O(n)，而使用SDS则直接获取len属性即可，时间复杂度为O(1)\n二进制安全：在C语言中，用空字符表示字符串的结束，若字符串本身就包含空字符，那么遇到便会截断，即非二进制安全。与其相对的便是二进制安全，SDS使用len属性来判断字符串是否结束，不会受到空字符影响。\n杜绝缓冲区溢出：在C语言中，在对字符串进行拼接操作时，若没有给字符串分配足够的内存，那么就可能产生缓冲区溢出，把其他数据覆盖掉。而SDS的自动扩容机制杜绝了溢出，sdsMakeRoomFor方法：参数：原字符串，待加入的字符串。若空闲空间大于待拼接字符串的长度，则无需扩容；若拼接后的长度小于1M，则直接扩容至新长度的两倍；若拼接后的长度大于1M，则扩容至新长度+1M；扩容后检查类型，若发生变化，则需要为SDS重新分配内存（header的大小也改变了）\n优化的内存分配策略：预分配：扩容后的SDS不会恰好容下新字符串，而是多分配了一些空间，从而减少修改字符串时带来的内存重分配次数；惰性空间释放机制：当缩短字符串时，不会立刻回收空余的空间，而是仅仅更新len属性，空余空间供将来使用，减少内存分配频率，当然Redis也提供了释放未使用空间的方法sdsRemoveFreeSpace\n\nListRedis 的列表相当于 Java 语言里面的 LinkedList，这意味着List的插入和删除操作非常块，但是索引定位就比较慢了\nList支持先进先出（lpop）先进后出（rpop）\nList有两种实现方式：压缩列表和双向循环链表\nziplist节点的数据小于64字节，数据个数小于512个\n一般的数组都要求每一格的元素大小相同，但是若要存储不同大小的字符串，就需要以最大长度来作为元素大小，会造成一定程度的浪费。而压缩列表就是将元素紧凑，但是会在每个元素的头部追加一个len属性，这样就能很容易计算出下一个元素的内存地址。\n双向链表和linkedlist很相似，可以处理数据量较大的情况，每个节点包含value和前驱，后继节点的指针\nHash和JAVA里的hashmap类似，都是无序的键值对集合。\nhash也有两种实现方式，当数据量小的时候，使用压缩列表，当数据量大的时候，使用散列表。\nhash的底层和hashmap也差不多，都是数组+链表的二维结构，但是hash只能存储字符串，并且rehash的方式也不一样，redis为了保证高性能，采用渐进式的rehash方法，即在不断输入的任务以及hash操作中一步步将旧结构里的内容迁移到新结构中\nSET集合，存储一组不重复的数据，同样两种实现方法：有序数组（只用于处理整数）和散列表。前者是处理较少的数据，后者是处理大量数据。\nRedis的持久化因为redis的数据是在内存里，一旦断电或者宕机，数据便会丢失，所以必须保证数据不会因为故障而丢失\nRDB(redis database)即快照，在指定的时间间隔内将内存中的所有数据集快照写入磁盘\nRedis会单独创建fork一个子进程来进行持久化，依靠操作系统的COW机制（写入时复制，在client没有对数据进行写入时，子进程和主进程通过指针共享一个物理页面，当client对数据进行写入修改时，OS才会为页面创建副本，子进程将副本数据写入RDB，而这个过程仍然不影响主进程对数据的修改），fork进程内部的数据便是整个数据库的一个快照。当子进程完成对新RDB文件的写入时，便会拿其替换原来的RDB文件。\nfork 的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。 子进程读取数据，然后序列化写到磁盘中。\nRDB是对整个内存的数据进行快照，所以只有一个文件，这种方法适合大规模的数据恢复，而且很方便，因为OS只需要fork一个子进程，服务进程无需进行其他的IO操作，最大化保障redis的性能。\n但是RDB也有一些缺点：最后一次快照无法及时写入内存，可能会发生丢失，因为是由fork子进程来完成持久化，相当于克隆了一份内存数据，当数据集较大时，可能会影响整个服务器的性能。\nAOF(Append Only File)以日志的形式来记录写操作，只记录写指令，恢复时只需从前往后执行一遍即可完成数据恢复的工作。\n记录方式：写后日志：即在数据写入内存后再记录日志，让操作系统先执行命令，只有命令执行成功才能被记录，这种方式排除了错误的指令，并且不会阻塞当前的写操作。\n风险：若写入数据后未来得及记录日志便宕机，就会造成数据丢失。虽然避免了当前命令的阻塞，但是会给下一个操作带来阻塞 的风险，因为AOF日志是在主线程中进行的，写入磁盘时，磁盘的写压力大，可能会造成后序操作的阻塞。\n同步写回：每个操作完成后写回，会影响性能，但是可靠性高\n每秒写回：即每秒进行一次写回，性能适中，但是可能会丢失这一秒内的数据\n操作系统控制的写回：每个写完命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时写回磁盘。性能好，但是宕机时丢失的数据多\nRedis的事务redis是不支持回滚的：由程序员自行纠正编程错误，无回滚的方式保证了内部的简单快速\n以MULTI开始一个事务，将多个命令入队，入队后不会立即执行，而是放置在等待执行的队列里，由EXEC触发事务\n所有命令都会被序列化，顺序执行，执行过程中不会被其他客户端的命令打断\n在提交之前所有命令都不会被执行\n不保证原子性：有一条命令失败，其他的命令仍然会进行，没有回滚\nMYSQL关系型数据库，插件式的存储引擎，这种架构可以根据业务的需求和实际需要选择合适的存储引擎。\n\n客户端通过协议与服务器连接，发送查询语句，先检查缓存是否命中，若命中直接返回，否则进行语句解析\n预处理，检查语句是否有语法错误，查询优化（是否会使用索引扫描），生成查询计划，启动查询引擎，开始查询，底层存储引擎调用API获取数据，返回给客户端\nMYSQL默认使用B树索引\n\n索引索引的本质就是一个满足某种查找算法的数据结构，常见的有BST，AVL，红黑树，Btree，B+树等等\n这些结构以某种方式指向数据（索引结点指向数据记录物理地址的指针）\n\n索引大大减少了服务器需要扫描的数据量，提高了检索效率\n避免排序，减少CPU消耗\n将随机IO转换为顺序IO\n\n索引也是一张表，保存了主键和索引，指向了实体表，也需要占用内存。索引存储于外存，所以索引的查询也需要磁盘IO开销\n虽然提高了查询速度，但是在对实体表进行更新时，索引也需要进行相应的维护更新，而索引的维护也需要开销，降低了更新表的速度\nHASH索引：等值查询很快，计算的hash值与对应的行指针一并存入表中，哈希碰撞的元素以链表的形式相连。但是不支持范围查询，也不支持排序。所以应用场景少。\nB树考虑到IO时十分高昂的操作，且数据库动辄百万级数据量，所以当一次IO时，常常以页作为单位来读取数据，当读取一页的数据至内存缓冲区时，实际上才发生了一次IO，所以控制IO的次数对于索引效率的提升，至关重要。\nB+树的特点：\n\n除叶子结点外的子节点：只起到索引的作用，仅存储指针，不存储信息\n所有信息存储于叶子结点，所有叶子结点在底部链接形成一个线性链表\n\nMYSQL默认使用B+树：为啥要用B+树，不用B树\n因为两者都是存储于磁盘，而IO是花销很大的操作，innoDB每次申请磁盘空间时都会申请若干条连续的磁盘块来组成一页，并放入内存，读取索引，放回磁盘，不断重复，直到找到数据。所以如果每次申请到的数据都能有助于定位到所需数据，这将会减少IO次数，提高查询效率。\n对于B树，因为B树的每一个结点都会存储键和数据，每个结点的信息存储能力有限，树的高度也会更高，增加了IO次数。而B+树的非叶子结点只存储键，所以B+树的非叶子结点可以存储更多的信息，降低了树高度，平均一次IO可以获取更多索引，所以B+树更适合外存索引。其中在 MySQL 底层对 B+ 树进行进一步优化：叶子节之间是双向链表，节点内部是单向链表，且在链表的头结点和尾节点也是循环指向的。\n跳表skipList跳表是可以实现二分查找的有序链表，常用于redis的有序集合数据结构\n拥有与红黑树相近的查找，删除，插入效率，并且范围查找效率更优越\n原理在于为有序链表建立多级索引，从而实现跳跃查找，\n最底层包含所有元素，第一级索引包含1&#x2F;2的元素，以此类推。\n每个索引包含了一个指针数组，指向了该索引可以到达的所有节点，数组下标即当前指针所在的层数。\n通过生成随机数的方式，来为每一个插入的元素设定索引级数，从而无需重建整个索引，降低了时间复杂度\n","slug":"Redis随想","date":"2022-09-24T05:45:16.000Z","categories_index":"","tags_index":"数据库基础知识","author_index":"Samuel"},{"id":"e0c4de6a72c616ec823d805c53472b1a","title":"子集排列问题sucks","content":"回溯算法解决所有子集排列问题形式一：元素无重复，且不可复选，即nums中所有元素均唯一，且最多使用一次\n/* 组合/子集问题回溯算法框架 */\n//使用start参数来避免复选\nvoid backtrack(int[] nums, int start) &#123;\n    // 回溯算法标准框架\n    for (int i = start; i &lt; nums.length; i++) &#123;\n        // 做选择\n        track.addLast(nums[i]);\n        // 注意参数\n        backtrack(nums, i + 1);\n        // 撤销选择\n        track.removeLast();\n    &#125;\n&#125;\n/* 排列问题回溯算法框架 */\n//使用used数组来记录已选过的元素，避免复选\nvoid backtrack(int[] nums) &#123;\n    for (int i = 0; i &lt; nums.length; i++) &#123;\n        // 剪枝逻辑\n        if (used[i]) &#123;\n            continue;\n        &#125;\n        // 做选择\n        used[i] = true;\n        track.addLast(nums[i]);\n\n        backtrack(nums);\n        // 撤销选择\n        track.removeLast();\n        used[i] = false;\n    &#125;\n&#125;\n\n形式二：元素有重复，但是不可以复选，即nums中存在重复的元素，但是每个元素只能使用一次\nArrays.sort(nums);\n//为数组排序，使得相同的元素排在一起\n/* 组合/子集问题回溯算法框架 */\nvoid backtrack(int[] nums, int start) &#123;\n    // 回溯算法标准框架\n    for (int i = start; i &lt; nums.length; i++) &#123;\n        // 剪枝逻辑，跳过值相同的相邻树枝\n        if (i > start &amp;&amp; nums[i] == nums[i - 1]) &#123;\n            continue;\n        &#125;\n        // 做选择\n        track.addLast(nums[i]);\n        // 注意参数\n        backtrack(nums, i + 1);\n        // 撤销选择\n        track.removeLast();\n    &#125;\n&#125;\n\n\nArrays.sort(nums);\n/* 排列问题回溯算法框架 */\nvoid backtrack(int[] nums) &#123;\n    for (int i = 0; i &lt; nums.length; i++) &#123;\n        // 剪枝逻辑\n        if (used[i]) &#123;\n            continue;\n        &#125;\n        // 剪枝逻辑，固定相同的元素在排列中的相对位置，若i-1未被选择，那么i也不能选，相当于固定了顺序\n        if (i > 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) &#123;\n            continue;\n        &#125;\n        // 做选择\n        used[i] = true;\n        track.addLast(nums[i]);\n\n        backtrack(nums);\n        // 撤销选择\n        track.removeLast();\n        used[i] = false;\n    &#125;\n&#125;\n\n形式三：元素无重复，但是可以复选\n/* 组合/子集问题回溯算法框架 */\nvoid backtrack(int[] nums, int start) &#123;\n    // 回溯算法标准框架\n    for (int i = start; i &lt; nums.length; i++) &#123;\n        // 做选择\n        track.addLast(nums[i]);\n        // 注意参数\n        backtrack(nums, i);\n        // 撤销选择\n        track.removeLast();\n    &#125;\n&#125;\n\n\n/* 排列问题回溯算法框架 */\nvoid backtrack(int[] nums) &#123;\n    for (int i = 0; i &lt; nums.length; i++) &#123;\n        // 做选择\n        track.addLast(nums[i]);\n        backtrack(nums);\n        // 撤销选择\n        track.removeLast();\n    &#125;\n&#125;\n","slug":"子集排列问题sucks","date":"2022-09-13T05:14:49.000Z","categories_index":"","tags_index":"算法归纳","author_index":"Samuel"},{"id":"1a1bb15f69c32b83456560735cf8e617","title":"JVM随笔","content":"JAVA内存区域讲解运行时数据区域分为两部分：线程共享和线程私有\n线程共享区域：\n\n堆：是虚拟机内存的最大的一块，此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存，注意是“几乎”，JDK1.7之后，当方法中的对象引用没有被返回或者未被外部使用，就会直接在栈上分配内存。同时，堆也是垃圾收集器管理的主要区域，所以也被称为GC堆。\nJDK1.8之前：方法区（运行时常量池）；JDK1.8之后：无，将方法区移至本地内存。方法区是运行时数据区域的一个逻辑区域，在不同虚拟上方法区的实现是不同的，当虚拟机要使用一个类时，它需要读取并解析class文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的类信息，字段信息，方法信息，常量，静态变量，即时编译器编译后的代码缓存。方法区有两种具体实现：永久代permanent gen和元空间metaspace。前者拥有一个由本身JVM设置的大小上限，无法调整，而在8版本之后，转而使用元空间，后者使用的是计算机的直接内存，溢出的概率更小。方法区包含运行时常量池和字符串常量池，后者是为了减少string类的内存消耗而专门开辟的，可以避免字符串的重复创建。方法区是一个公共且抽象的概念，在不同虚拟机上可以有不同的实现。\n\n线程私有区域：\n\n虚拟机栈：由一个个栈帧组成，栈帧内包含：局部变量表（存放可以编译器可以被识别的各种数据类型），操作数栈（作为方法调用的中转站，存放中间计算结果），动态链接（当一个方法需要调用其他方法时，动态链接就是未来将符号引用转换为调用方法的直接引用），方法返回地址。除了本地方法，其他所有方法的调用都是通过栈来实现。方法调用的数据通过栈进行传递，每一个方法没调用时都会有一个对应的栈帧被压入，每一个方法调用结束后，都会有一个栈帧被弹出。当函数调用陷入无限循环，或者压栈太多，导致线程请求的栈的深度超过JAVA虚拟机栈的最大深度时，就会抛出,stackoverflow。栈帧的弹出：return语句，异常抛出，随方法的调用而创建，随方法的结束而销毁，所以无论方法是否正常完成还是异常完成，都可以视为方法结束。\n本地方法栈：和虚拟机栈十分相似，但是本地方法是由c++编写的，所以这个栈是为native方法服务的，同样也会创建栈帧，同样也会抛出栈溢出的错误。\n程序计数器PC：一块较小的内存空间，就是一个计数器，可以看作是当前线程执行的字节码的行号指示器，字节码解释器通过改变PC的值来选取下一条要执行的字节码指令，从而实现循环，跳转，异常处理等功能。每个线程都需要一个独立的PC，PC也是唯一一个不会出现outofmemory的内存区域。\n\n类文件结构解析字节码：.class扩展名\n\n魔数：magic number：每个class文件的头4个字节被称为魔数（CAFEBABE）唯一作用便是确定这个文件是否为一个能被虚拟机接收的class文件\nclass文件版本号：小版本号+大版本号。高版本的JVM可以执行低版本的class文件\n常量池数量，常量池，常量池计数器从1开始，若有某些指向常量池的索引值需要表达“不引用常量池中的项目”这一含义，则可以将索引值设为0。常量池中主要存储两大常量：字面量：即文本字符串，或者被final修饰的常量等。符号引用：package，接口的全名，方法名称或描述符，字段名称或描述符等等。与c不同的是，java在编译时，不会有连接这一步骤，而是会在虚拟机加载class文件时进行动态连接，虚拟机在进行类加载时，将会从常量池中获得对应的符号引用，在类创建时或运行时解析，并翻译到具体的内存地址中。常量池中的每一项都是一个表。常量池可以看作是class文件里的资源仓库，占用空间最大。\n访问标志：用于识别类或者接口的访问信息，比如class是类还是接口，public还是abstract，是否被final修饰等\n索引集合：当前类，父类，接口索引集合\n字段表集合：描述接口或类中声明的变量，不包括方法内声明的局部变量\n方法表集合\n\n类加载过程加载加载主要完成下面三件事情\n\n通过全类名获取定义此类的二进制字节流\n将字节流代表的静态数据结构转换为方法区的运行时数据结构\n在内存中生成一个代表该类的class对象，作为方法区数据的访问入口\n\n连接——验证\n文件格式验证：是否符合class文件格式的规范（CAFEBABE），主次版本号是否在虚拟机的处理范围内，常量池中的的常量是否都可以支持\n元数据验证：对字节码的信息进行语义分析，保证描述的信息符合java的语言规范，比如这个类是否有父类，这个类是否继承了不被允许继承的类\n字节码验证：这是最为复杂的一个阶段，通过数据流和控制流的分析，确定程序语义是合法，符合逻辑的，比如确保任意时刻操作数栈都能配合工作\n符号引用验证：确保解析动作能正确执行\n\n连接——准备这个阶段会正式为变量分配内存并设置初始变量，仅包括类变量,static\n连接——解析将常量池里的符号引用替换为直接引用，主要针对，接口，字段，类方法。符号引用就是用一组符号来描述目标，可以是任何字面量；直接引用就是直接指向目标的指针，偏移量\n初始化这是类加载的最后一步，执行初始化方法，在这一步，JVM才真正开始执行类中定义的java程序代码\nHOTSPOT虚拟机对象创建的过程类加载检测虚拟机遇到new指令时，首先检查这条指令的参数是否能在常量池中定位到这个类的引用，检查这个符号引用代表的类是否已经被加载过，解析，或初始化。若没有，则先执行相应的类加载过程。\n分配内存为新对象分配内存，所需内存大小在类加载完成后就可以确定，分配内存的任务等同于将一块确定大小的内存从堆中划分出来。\n\n指针碰撞：堆内存规整，将用过的内存和没用过的内存整合到两边，中间有一个分界指针，只需要将指针移动相应大小即可完成分配。\n空闲列表：堆内存不规整，虚拟机会维护一个列表，列表中会记录哪些内存块是可用的，寻找到一块满足大小的内存分配后，更新列表。\n\n初始化零值当内存分配后，需要将分配到的内存空间都初始化为0值，这一步保证了对象的字段在java代码中可以不赋值就能直接被使用，程序能访问这些字段的数据类型对应的0值\n设置对象头这个对象是哪个类的实例，对象的hashcode，如何才能找到类的元数据信息，等信息处理后放入对象头中、\n执行init方法在虚拟机的视角来看，对象的创建已经完成，但是对于java程序来说，对象创建才刚刚开始，在init之前所有的字段都是零值，init之后便会将对象按照程序员的意愿进行初始化，一个真正可用的对象才算真正创建。\n","slug":"Java随想","date":"2022-09-12T04:37:43.000Z","categories_index":"","tags_index":"Java基础知识","author_index":"Samuel"},{"id":"b8307bc7cc4dad51e597289f7dfa286e","title":"JAVA的字符串","content":"String&amp;StringBuilderString的底层数据结构是数组char value[]\npublic final class String\nimplements java.io.Serializable, Comparable&lt;String>, CharSequence &#123;\n\t/** The value is used for character storage. */\n\tprivate final char value[];\n\t/** Cache the hash code for the string */\n\tprivate int hash; // Default to 0\n\t/** use serialVersionUID from JDK 1.0.2 for interoperability */\n\tprivate static final long serialVersionUID = -6849794470754667710L;\n&#125;\n\nString的类用于存放字符串的方法都用了final来修饰，也就是创建后均不可以被改变，当我们进行一个字符串相连的操作时，便会创建出新的对象\nString str_1 = new String(\"ab\");\nString str_2 = new String(\"ab\");\nString str_3 = \"ab\";\n\n\nSystem.out.println(str_1 == str_2); //false\nSystem.out.println(str_1 == str_2.intern());//false\nSystem.out.println(str_1.intern() == str_2.intern());//true\nSystem.out.println(str_1 == str_3);//false\nSystem.out.println(str_1.intern() == str_3);//true\n\n结论：\n\n&#x3D;&#x3D; ， 在引用类型中是对比的地址，比如str1和str2，两个new出来的对象置于堆内存中，地址肯定不同；但是如果是基础类型如str3，就是对比值；当然也有equal方法，这是对比的是哈希值\nintern()，这是一个本地方法，底层由c++实现，它的作用是将值推进常量池\nString str_3 = &quot;ab&quot;这种赋值方法JVM做了优化，不会创建对象，直接将值放进常量池\n\nStringBuilder//初始化，同样是数组\nnew StringBuilder(16);\n\npublic StringBuilder() &#123;\n\tsuper(16);\n&#125;\nAbstractStringBuilder(int capacity) &#123;\n\tvalue = new char[capacity];\n&#125;\n\n//添加元素\nstringBuilder.append(\"a\");\n\npublic AbstractStringBuilder append(String str) &#123;\n\tif (str == null)\n\treturn appendNull();\n\tint len = str.length();\n\tensureCapacityInternal(count + len);\n\tstr.getChars(0, len, value, count);\n\tcount += len;\n\treturn this;\n&#125;\n\nprivate void ensureCapacityInternal(int minimumCapacity) &#123;\n\t// overflow-conscious code\n\tif (minimumCapacity - value.length > 0)\n\texpandCapacity(minimumCapacity);\n&#125;\nvoid expandCapacity(int minimumCapacity) &#123;\n\tint newCapacity = value.length * 2 + 2;\n\tif (newCapacity - minimumCapacity &lt; 0) newCapacity = minimumCapacity;\n\tif (newCapacity &lt; 0) &#123;\n\t\tif (minimumCapacity &lt; 0) // overflow\n\t\tthrow new OutOfMemoryError();\n\tnewCapacity = Integer.MAX_VALUE;\n\t&#125;\n\tvalue = Arrays.copyOf(value, newCapacity);\n&#125;\n\n对字符串的各种操作方法字符串类\nString：不可修改\n当使用字符串的相加操作时，不会删掉原字符串，而是在常量池里面新建一个新的String，储存修改后的结果\nequals();\n//boolean比较两个字符串是否相等\ncompareTo();\n//基于每个字符进行Unicode值比较，若完全相等，返回0；小于参数，返回负数；大于参数，返回正数\ncontains();\n//boolean若包含某个字符，返回true\nindexOf();\n//返回字符第一次出现的索引，未找到则返回-1、\nstartsWith(); endsWith();\n//boolean测试字符串是否以参数为前缀开头;是否以参数为后缀结尾\nreplaceAll(String regex,String replacement);\n//将字符串中的所有的regex替换为replacement\nsplit(String regex);\n//每个字符以regex分割并返回一个string型数组\nsubstring();\n//可以接收两个参数，返回这个索引截取的子串\ntrim();\n//删除前置和后置的所有空格\ntoUpperCase();toLowerCase();\n//大小写转换\njoin(\"mark\",\"\");\n//为一系列字符串添加分割符并拼成一个新的字符串\n\nStringBuilder：可以修改，可以在常量池里原地修改字符串\nStringBuffer：可以修改，且线程安全，基本与StringBuilder相同\nappend();\n//字符串连接\ntoString();\n//返回一个与构建器相同的String\nsetCharAt(int i, char c);\n//把某个位置的字符置为C\ninsert(int offset, String str/char c);\n//在指定位置之前插入字符串或字符\ndelete(int startIndex,int endIndex);\n//删除指定范围内的字符串\n\n\ndeleteCharAt (int index);\n//删除某个字符\nreplace(int start,int end,String str);\n//在指定范围内用str替换\n reverse();\n//字符串反转\nsubstring(int start,int end);\n//返回子串\n","slug":"Java的字符串","date":"2022-08-14T04:57:02.000Z","categories_index":"","tags_index":"Java基础知识","author_index":"Samuel"},{"id":"9a0ea7adf62049ce83652b0a7c894a59","title":"Java数据结构","content":"HashCodehashcode是一种编码方式，在java中，每一个对象都会有一个hashcode，而java可以以此来识别每一个对象\n哈希，也可以翻译为“散列”，就是将任意长度的输入，通过散列算法，变换为固定长度的输出，该输出值就是散列值。这是一种压缩映射，不同的输入可能会得到相同的散列值。\n而hashcode就是通过hash函数计算而来的，将对象的物理地址转换为一个整数，再将该整数通过散列算法转换为对应的hash值。hashcode可以理解为一种地址，即在hash表中的地址。\n\n如果两个对象相同，则hashcode一定相同\n如果两个对象的hashcode相同，则这两个对象不一定相同，只能说明这两个对象在散列存储结构中位于同一位置\n\nhashcode的作用hashcode实现了更高效快捷的查找\nhashcode的计算逻辑中，为什么使用31作为乘数？？？\n\n31是一个不大不小的奇质数，如果选择偶数计算，会导致乘积运算时的数据溢出。如果选择一个很小的数，那么hashcode会分布在一个很小的范围内，容易造成哈希值的冲突；如果选择一个很大的数，那么可能会超出整型变量的范围。\n在二进制中31等于2&lt;&lt;5-1，那么31*i即为（i&lt;&lt;5）-i，这种乘积运算可以直接通过位移来提升性能，JVM也支持这种优化方式\n不止31，33，37，39，41也可以作为乘数，当我们使用超过50,000个 单词来计算hashcode，这5个乘数都得到的哈希值冲突都小于7，31最小。同时hash的目的就是让数据尽可能分散排布，而以31作为乘数得到的结果分布最为均匀。\n\nHashMap引入问题：现在有一组字符串，如何以最小且相同的时间复杂度来获取每一个元素，也就说，不能使用循环遍历的方式去查找\n解决方案A为每一个元素赋予一个ID，通过ID直接定位到该元素，这个ID即可以通过hashcode来进行运算获得。\n当我们要查找元素A时，将计算得到的哈希值放到哈希表中进行查找，即可以找到对应的元素\nint idx = key.hashCode() &amp; (tab.length - 1);\n//&amp;：与运算符，这行代码可以得到每个元素在哈希表中的位置\n\n这种方式有什么问题：\n\n散列表的大小不好确定，可能会出现同一个位置放置多个元素的情况\n表太小，碰撞严重，表太大，查找性能差。\n随着元素越来越多，如何扩容散列表，如何将原有的元素进行拆分并放到新的位置上去\n\n解决方案B：引入扰动函数何不把hash值作为数组下标，这样多方便，但是hash值十分巨大，不可能将数组初始化如此之大\n在引入扰动函数后，将A中第一次运算得到的初始hash值再进行一次运算：\n\n将a右移16位（&gt;&gt;&gt;16即在数的左边加上16个零）得到b\n对a,b进行异或运算，得到c\n最后将c与对应的数进行与运算，获得最值散列表索引\n\nc= (h =key.hashCode()) ^ (h >>> 16);\n\n扰动函数运算将原哈希值的高位和地位做异或，增大了随机性\n说白了，扰动函数就是为了增大随机性，减少碰撞，增强了数据的存储和查找性能\n在引入扰动函数后散列表的数据分布更加均匀\n解决方案C：优化初始化容量和负载因子问题散列表的大小我们通常初始化为二进制偶数大小（如8，16等），因为偶数-1，我们才能获得一个01111这样的值（在和c进行与运算的时候才可以获得合法的结果），但是如果我们偏要传进去一个奇数，程序会如何处理\n引入tableSizeFor方法：若传入17可以调用该方法，向正方向寻找一个最接近17的2进制偶数，这里我们找到了32\n这个函数的原理：通过位移运算+或运算将17的每一位都改为1，然后再加1，最后就可以得到32\n负载因子static final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n一辆车的装载量超过某个值后，就将多余的货物装到新的车上\n再hashmap中，负载因子就是一个阈值，当数据量超过这个阈值后，便要进行扩容\n因为hashcode的特性，一个散列表地址可能对应多个元素，所以即使元素数量大于散列表地址数量，也可能出现无法把散列表占满的情况，在这种情况下，某些位置会出现碰撞，这降低了HashMap的性能\n所以当散列表的位置使用到一定程度时，就需要进行扩容\n默认0.75，也就是当使用3&#x2F;4后，就进行扩容，当然也可以设置小一些，减少碰撞，用空间换时间\n扩容与数据迁移在jdk1.7中，当我们将元素拆分后，需要重新计算哈希值，这种方式的弊端：\n\nrehash是十分耗费时间和空间的\n当并发执行扩容操作时，可能会发生数据丢失，死循环等问题\n\n但是在jdk1.8中已经不用再进行rehash，提升了拆分的性能\n将扩容后的哈希表位数命名为oldCap\n如何判断是否需要进行迁移操作：\n将hashcode与oldCap进行与运算，判断最高位，若为1，则直接加上扩容位数，直接通过位移运算来进行加减显然要高效方便许多\n为什么我们可以直接加上扩容位数呢？？\n\n因为每次扩容都是将原数组的长度*2，那么在二进制表达上体现出来的就是n-1多了一个1\n那么在进行与运算时，新索引的值就取决于这个1，所以我们直接看高位的与运算，结果是否为1，若为1，则直接加上扩容长度\n所以在这种规律下，也就无需重复rehash\n\nArrayListArrayList即数组列表，是基于数组实现的，这个数组可以插入任何元素，只不过这个数组是可以按需扩容，可以进行数据拷贝的\nArrayList的构造private static final int DEFAULT_CAPACITY = 10;\n//默认初始化容量\nprivate int size; \n//size指elementData中实际有多少元素\ntransient Object[] elementData;\n//element.length指集合容量\n//transient关键字只能修饰变量，不可修饰方法和类，该变量被序列化后将无法被访问\nprotected transient int modCount = 0;\n//记录对list操作的次数\n\n//无参构造\nprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;\npublic ArrayList() &#123;\n    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n&#125;\n//当使用无参构造时，给elementData数组赋值了一个空数组，这个空数组知道当无参构造时，第一次添加元素后如何扩容。构造时赋予空数组，而当第一次添加元素时，容量便会扩充到10\n\n//有参构造\nprivate static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;\npublic ArrayList(int initialCapacity) &#123;\n    if (initialCapacity > 0) &#123;\n        this.elementData = new Object[initialCapacity];\n        //参数大于零且合法，便初始化一个数组便赋值给elementData\n    &#125; else if (initialCapacity == 0) &#123;\n        //参数为零，便将空数组赋值给elementData\n        this.elementData = EMPTY_ELEMENTDATA;\n    &#125; else &#123;\n        //参数不合法，提示错误\n        throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                  \t\t\tinitialCapacity);\n    &#125;\n&#125;\n\n//使用指定collection来构造\npublic ArrayList(Collection&lt;? extends E> c) &#123;\n    elementData = c.toArray();\n    //将collection c转化为数组并赋值给elementData\n    if ((size = elementData.length) != 0) &#123;、\n        // c.toArray might (incorrectly) not return Object[] (see 6260652)\n        if (elementData.getClass() != Object[].class)\n            //若elementData的数组类型不是object，就做一次转换\n        elementData = Arrays.copyOf(elementData, size, Object[].class);\n    &#125; else &#123;\n        // replace with empty array.\n        this.elementData = EMPTY_ELEMENTDATA;\n    &#125;\n&#125;\n\nArrayList的相关操作//add 操作\npublic boolean add(E e) &#123;\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    //对size进行自增操作，即成功添加新元素\n    elementData[size++] = e;\n    return true;\n&#125;\n\nprivate void ensureCapacityInternal(int minCapacity) &#123;\n    //当使用无参构造时，添加一个元素时会将容量设置为默认10，并进行扩容\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;\n        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n    &#125;\n    ensureExplicitCapacity(minCapacity);\n&#125;\n\nprivate void ensureExplicitCapacity(int minCapacity) &#123;\n    //确认是否需要扩容：即size+1是否会超出容量\n    modCount++;\n    // overflow-conscious code\n    if (minCapacity - elementData.length > 0)\n        //扩容，使用grow方法\n        grow(minCapacity);\n&#125;\n\n//grow操作，当添加元素发现容量不足或无参构造第一次添加元素时，需要扩容\nprivate void grow(int minCapacity) &#123;\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    //将容量扩充至原大小的1.5倍，但是这个大小可能有大有小，所以需要if语句来进行判断\n    if (newCapacity - minCapacity &lt; 0)\n        newCapacity = minCapacity;\n    //扩容后的容量还是很小，不满足需要的容量，则直接将需要的容量赋值给newCapacity\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        //扩容后的容量太大了，就改变扩容方式\n        newCapacity = hugeCapacity(minCapacity);\n    // minCapacity is usually close to size, so this is a win:\n    //将原数组的大小扩充至newCapacity\n    elementData = Arrays.copyOf(elementData, newCapacity);\n&#125;\n\n//当扩大1.5倍后超出了最大范围，那么就干脆将大小设为最大范围\nprivate static int hugeCapacity(int minCapacity) &#123;\n    if (minCapacity &lt; 0) // overflow\n        throw new OutOfMemoryError();\n    return (minCapacity > MAX_ARRAY_SIZE) ?\n        Integer.MAX_VALUE :\n        MAX_ARRAY_SIZE;\n&#125;\n\nprivate static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n//remove操作\n//输入索引\npublic E remove(int index) &#123;\n    //检测这个元素是否处于数组的最后一个位置\n    rangeCheck(index);\n    modCount++;\n    E oldValue = elementData(index);\n    int numMoved = size - index - 1;\n    if (numMoved > 0)\n        //若index不在最后一位，则将index+1开始向后的所有元素向前移动一位，相当于删除了index位置的元素\n        System.arraycopy(elementData, index+1, elementData, index, numMoved);\n    //将最后一位赋值为null\n    elementData[--size] = null; // clear to let GC do its work\n    return oldValue;\n&#125;\n//参数直接为指定元素\npublic boolean remove(Object o) &#123;\n    if (o == null) &#123;\n        for (int index = 0; index &lt; size; index++)\n            if (elementData[index] == null) &#123;\n                fastRemove(index);\n                return true;\n            &#125;\n    &#125; else &#123;\n        for (int index = 0; index &lt; size; index++)\n            if (o.equals(elementData[index])) &#123;\n                fastRemove(index);\n                return true;\n            &#125;\n    &#125;\n    return false;\n&#125;\n\nprivate void fastRemove(int index) &#123;\n    modCount++;\n    int numMoved = size - index - 1;\n    if (numMoved > 0)\n        System.arraycopy(elementData, index+1, elementData, index,numMoved);\n    elementData[--size] = null; // clear to let GC do its work\n&#125;\n\n//get操作\npublic E get(int index) &#123;\n    rangeCheck(index);\n    return elementData(index);\n&#125;\n//由于arraylist的底层基于数组，获取元素就很简单，直接调用数组访问即可\n\n//迭代器\n//由上述源码可知，在进行remove的时候，size是时刻动态变化的，所以不能对arrayList进行for循环遍历来remove元素，这样容易造成结果不准确甚至数组下标越界\npublic Iterator&lt;E> iterator() &#123;\n    return new Itr();\n&#125;\n//当创建迭代器时 list.iterator();会直接返回一个Itr对象\n\n\n//ArrayList的内部类Itr实现了Iterator接口，该类有三个方法\nprivate class Itr implements Iterator&lt;E> &#123;\n    int cursor = 0 ;       // index of next element to return，下一个要访问的元素\n    int lastRet = -1; // index of last element returned; -1 if no such\n    int expectedModCount = modCount;//代表对ArrayList修改次数的期望值，初始为modCount\n\n    public boolean hasNext() &#123;\n        return cursor != size;\n    &#125;\n\n    @SuppressWarnings(\"unchecked\")\n    public E next() &#123;\n        //判断expectedModCount是否和modCount相等\n        checkForComodification();\n        int i = cursor;\n        //判断是否越界\n        if (i >= size)\n            throw new NoSuchElementException();\n        Object[] elementData = ArrayList.this.elementData;\n        if (i >= elementData.length)\n            throw new ConcurrentModificationException();\n        cursor = i + 1;\n        return (E) elementData[lastRet = i];//lastRet和cursor都自增1，并返回自增后的lastRet\n    &#125;\n\n    public void remove() &#123;\n        //\n        if (lastRet &lt; 0)\n            throw new IllegalStateException();\n        checkForComodification();\n\n        try &#123;\n            ArrayList.this.remove(lastRet);\n            //调用ArrayList的remove方法并将两个游标向前移动一位\n            cursor = lastRet;\n            lastRet = -1;\n            expectedModCount = modCount;\n        &#125; catch (IndexOutOfBoundsException ex) &#123;\n            throw new ConcurrentModificationException();\n        &#125;\n    &#125;\n\n    final void checkForComodification() &#123;\n        if (modCount != expectedModCount)\n            throw new ConcurrentModificationException();\n    &#125;\n&#125;\n//如果要对ArrayList进行遍历操作，就要使用迭代器，且在remove之前必须hasnext和next\n\nLinkedListlinkedlist与arraylist不同，后者基于一个被维护的数组来实现动态调整大小，而前者则是一个双向链表\n链表的优势：当插入和删除比较频繁的时候，链表相较于数组能有更高的效率(通常情况下，也有特殊情况，比如arraylist的中间插入效率就要高一些)，但是查找效率却不高。\n//内部类node的源码\n//一个对象对应一个节点\n    private static class Node&lt;E> &#123;\n       //元素的引用\n       //如果为null,表示没有存储任何元素，如果不为null,表示存储了某种类型的元素\n       E item;\n       //下一个节点的引用\n       //引用代表了对象的十六进制地址值,所以也可以注释为:下一个节点在内存中的地址\n       //如果为null,可能是空链表，也可能是尾节点\n       Node&lt;E> next;\n       Node&lt;E> prev;\n       Node(Node&lt;E> prev, E element, Node&lt;E> next) &#123;\n          //元素的引用初始化\n          this.item = element;\n          //上一个节点的引用初始化\n          this.next = next;\n          //下一个节点的引用初始化\n          this.prev = prev;\n       &#125;\n    &#125;\n\n//变量\ntransient int size = 0;\n//元素数量\ntransient Node&lt;E> last;\n//首节点的固定引用，必须先创建首节点，才能创建下一个节点\ntransient Node&lt;E> first;\n//尾节点的固定引用\n\n\n\n//头插\nprivate void linkFirst(E e) &#123;\n    //再创建一个指针f指向首节点\n\tfinal Node&lt;E> f = first;\n    //前指针为空，后指针指向f\n\tfinal Node&lt;E> newNode = new Node&lt;>(null, e, f);\n    //将first首指针指向newnode，代表newnode成为新的首元素\n\tfirst = newNode;\n    //若f指向的元素为空，证明加入newnode前链表为空，那么newnode既是首元素，也是尾元素\n\tif (f == null) last = newNode;\n    //若不为空，将前指针指向newnode，形成双向链表\n\telse f.prev = newNode;\n\tsize++; modCount++;\n&#125;\n//linkedlist的头插效率非常高，因为arraylist的头插需要进行大量的移位，元素复制的操作，还可能需要进行扩容，而链表只需调整指针的指向即可\n\n//尾插\nvoid linkLast(E e) &#123;\n    //与头插大同小异\n\tfinal Node&lt;E> l = last;\n    //最后一个节点的next为null\n\tfinal Node&lt;E> newNode = new Node&lt;>(l, e, null);\n\tlast = newNode;\n\tif (l == null) first = newNode;\n\telse l.next = newNode;\n\tsize++; modCount++;\n&#125;\n//出乎意料地是，linkedlist的尾插效率却比arraylist要低，因为arraylist无需进行移位拷贝操作，而linkedlist则需要创建对象，后者要耗时许多\n\n//中间插入\npublic void add(int index, E element) &#123;\n    //输入索引和元素，检查索引范围是否合法\n\tcheckPositionIndex(index);\n    //若索引为size则进行尾插\n\tif (index == size) linkLast(element);\n    //不是，则进行中间插入\n\telse inkBefore(element, node(index));\n&#125;\nNode&lt;E> node(int index) &#123;\n\t// assert isElementIndex(index);\n    //size>>1：size的一半，判断元素在左半区间，还是右半区间\n\tif (index &lt; (size >> 1)) &#123;\n        //在左半区间，操纵first指针找到index元素\n\t\tNode&lt;E> x = first;\n\t\tfor (int i = 0; i &lt; index; i++)\n\t\tx = x.next;\n\t\treturn x;&#125; \n    else &#123;\n        //在右半区间，操纵last指针找到index元素\n\t\tNode&lt;E> x = last;\n\t\tfor (int i = size - 1; i > index; i--)\n\t\tx = x.prev;\n\t\treturn x;&#125;\n&#125;\nvoid linkBefore(E e, Node&lt;E> succ) &#123;\n\t// assert succ != null;\n    //在index所指的元素之前插入新元素\n\tfinal Node&lt;E> pred = succ.prev;\n\tfinal Node&lt;E> newNode = new Node&lt;>(pred, e, succ);\n\tsucc.prev = newNode;\n\tif (pred == null) first = newNode;\n\telse pred.next = newNode;\n\tsize++; modCount++;\n&#125;\n//在数据量较大的时候，中间插入相比arrayList仍然会消耗较多的时间，所以CRUD效率不是绝对的可以分高下，需要根据应用场景和数据量等来综合考量\n\n//删除节点\npublic boolean remove(Object o) &#123;\nif (o == null) &#123;\nfor (Node&lt;E> x = first; x != null; x = x.next) &#123;\nif (x.item == null) &#123;\n\tunlink(x);\n\treturn true;\n\t\t&#125;\n\t&#125;\n&#125; else &#123;\n\tfor (Node&lt;E> x = first; x != null; x = x.next) &#123;\n    if (o.equals(x.item)) &#123;\n\tunlink(x);\n\treturn true;\n\t\t&#125;\n\t&#125;\n&#125;\nreturn false;\n&#125;\n//解链操作，即将这个元素从链表中移除\nE unlink(Node&lt;E> x) &#123;\n// assert x != null;\n\tfinal E element = x.item;\n\tfinal Node&lt;E> next = x.next;\n\tfinal Node&lt;E> prev = x.prev;\n    //若上个结点为空，则直接将首指针指向next\n\tif (prev == null) first = next; \n    //断掉x的prev指针\n    else &#123;prev.next = next;x.prev = null;&#125;\n    //若下一个结点为空，则直接将尾结点指向prev\n\tif (next == null) last = prev;\n    //断掉x的next指针\n    else &#123;next.prev = prev;x.next = null;&#125;\n\tx.item = null;\n\tsize--;\n\tmodCount++;\n\treturn element;\n\t&#125;\n","slug":"Java数据结构","date":"2022-08-12T05:41:02.000Z","categories_index":"","tags_index":"Java基础知识","author_index":"Samuel"}]